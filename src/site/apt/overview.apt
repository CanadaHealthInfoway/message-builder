~~
~~ Copyright 2013 Canada Health Infoway, Inc.
~~
~~ Licensed under the Apache License, Version 2.0 (the "License");
~~ you may not use this file except in compliance with the License.
~~ You may obtain a copy of the License at
~~
~~        http://www.apache.org/licenses/LICENSE-2.0
~~
~~ Unless required by applicable law or agreed to in writing, software
~~ distributed under the License is distributed on an "AS IS" BASIS,
~~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
~~ See the License for the specific language governing permissions and
~~ limitations under the License.
~~
~~ Author:        $LastChangedBy$
~~ Last modified: $LastChangedDate$
~~ Revision:      $LastChangedRevision$
~~

Overview

  The Message Builder Tool is comprised of eight key components:

   [[1]] The generated artifacts: model classes and message sets

   [[2]] The generator tools

   [[3]] Standard data type implementations

   [[4]] The marshalling/unmarshalling engine

   [[5]] The code type resolution engine (terminology service)

   [[6]] The validation tool

   [[7]] Transport layer implementations

   [[8]] Developer productivity utilities


* The Generatated Artifacts

  The output of the generation tools results in the creation of two types of artifacts.

    [[1]] Message sets -- an XML-based file that describes a complete message standard (for example, one message set might describe the MR 2009 release). In many ways, message sets resemble MIFs, but the information is organized in a simpler structure.

    [[2]] Message classes -- classes in .Net or Java that hold the message data. These classes display the characteristics described in the RFP: they are simplified by hiding fixed values, "flattening" 1-to-1 relationships, etc.

* The Generator Tools

   The Message Builder generator tools are tools that process a set of MIFs (in MIF 2.1.x format) and produce the two artifacts described above. These tools can be used in a command-line or GUI-based mode.


* Standard Data Type Implementations

   Part of the Message Builder runtime includes classes that implement the standard CHI data type definitions: AD.BASIC, TS.FULLDATETIME, TS.FULLDATE, etc. These classes support the various attributes described in the HL7 Data Types and CHI Data Types specifications.


* The Code Value Resolution Engine

   MBT makes use of a pluggable code value resolution engine. Given a particular code value, concept domain and (where applicable) code system oid, the resolution engine determines whether or not the provided code is valid.

   The resolution engine is configurable so that code values can be looked up from, say, a list of constants, an enum (useful for simple codes such as Processing Mode), a database, or any other implementation. Different concept domains can resolve codes differently so that Manufactured Drug is resolved against a drug database, whereas Professional Service code is resolved against a service type table.


* The Validation Tool

  One of the uses of MBT is as a message validation tool. MBT can be used to validate:

  [[1]] Conformance level of various elements (mandatory, populated, etc.)

  [[2]] Maximum and minimum cardinality of repeated items

  [[3]] Code value correctness (using the code value resolution engine)

  [[4]] Fixed value correctness

  [[5]] Specific datatype restrictions (e.g.: when a field is defined as II.BUS, there must be a type="BUS" attribute -- this is a more specific check than, say, what existing XML schema validation can confirm)

  [[6]] Other "constant" values in the message -- such as the HL7 Trigger Event Code.

* Transport Layer Implementations

   MBT also provides a pluggable transport layer and a number of different implementations of HL7 transports (including basic transport types such as SOAP and REST). While there is every reason to expect that individual jurisdictions will implement their transport layers in idiosyncratic ways, much of the behaviour relating to preparing and transmitting an HL7 message can be handled in a generic way. The pluggable transport layer provides a framework for abstracting away some of the jurisdicational differences.


* Development Productivity Utilities

  Creating applications that produce and consume HL7 messages often involves a lot of boilerplate code. For example, to create a Find Candidates Query message, a developer has to provide a large number of pieces of data to:

    [[1]] populate standard values in the transport layer: processing ID, processing mode, HL7 standard version code, etc.

    [[2]] generate an HL7 message id

    [[3]] generate a control act event id

    [[4]] generate a query id

  and so forth. All of these data fields can often seem overwhelming to average developers who are trying to take simple query data (names, health-card numbers, etc.) and get a corresponding HL7 message.

  If we look, for example, at the MARCH-HI framework, all of those data items must be passed in to a constructor for the message type. Our view is that all of those data fields can seem overwhelming to a developer.

  Our approach to this complexity problem is to recognize that different data elements in the message serve very different purposes, and to provide utilities, factories and other types of code helpers that can make the job of populating messages easier for developers.



