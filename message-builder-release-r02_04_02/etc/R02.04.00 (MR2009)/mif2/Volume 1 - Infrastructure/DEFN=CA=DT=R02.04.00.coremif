<?xml version="1.0" encoding="UTF-8"?>
<!-- edited with XMLSpy v2007 sp2 (http://www.altova.com) by Lloyd McKenzie (HL7) -->
<datatypeModelLibrary title="Data Types Specification" packageKind="version" name="0-alpha" schemaVersion="2.1.3" xmlns="urn:hl7-org:v3/mif2" xmlns:html="http://www.w3.org/1999/xhtml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:hl7-org:v3/mif2 C:\DOCUME~1\Office\MYDOCU~1\Hl7\MIF\MIF-SC~2.1\schemas\mif-model-datatype.xsd">
  <packageLocation root="DEFN" artifact="DT" realmNamespace="CA" version="R02.04.00"/>
  <header>
    <legalese copyrightYears="2007" copyrightOwner="Canada Health Infoway"/>
    <responsibleGroup organizationName="Canada Health Infoway" groupName="Standards Collaborative"/>
    <approvalInfo approvalStatus="Approved Affiliate DSTU" approvalDate="2007-12-07"/>
    <realmNamespace value="CA"/>
  </header>
  <importedVocabularyModelPackage root="DEFN" artifact="VO" realmNamespace="CA" version="R02.04.00"/>
  <importDatatypeModelLibrary root="DEFN" artifact="DT" realmNamespace="UV" version="1.1">
    <importedDatatype name="AD" visibility="protected"/>
    <importedDatatype name="ADXP" visibility="protected"/>
    <importedDatatype name="ANY" visibility="protected"/>
    <importedDatatype name="BIN" visibility="protected"/>
    <importedDatatype name="BN" visibility="protected"/>
    <importedDatatype name="BL" visibility="protected"/>
    <importedDatatype name="CD" visibility="protected" alias="CD.UV"/>
    <importedDatatype name="CE" visibility="protected"/>
    <importedDatatype name="CR" visibility="protected"/>
    <importedDatatype name="CS" visibility="protected"/>
    <importedDatatype name="CV" visibility="protected"/>
    <importedDatatype name="ED" visibility="protected"/>
    <importedDatatype name="ENXP" visibility="protected"/>
    <importedDatatype name="GTS" visibility="protected"/>
    <importedDatatype name="II" visibility="protected"/>
    <importedDatatype name="INT" visibility="protected"/>
    <importedDatatype name="IVL" visibility="public"/>
    <importedDatatype name="LIST" visibility="protected"/>
    <importedDatatype name="MO" visibility="protected"/>
    <importedDatatype name="OID" visibility="protected"/>
    <importedDatatype name="PIVL" visibility="protected"/>
    <importedDatatype name="PN" visibility="protected"/>
    <importedDatatype name="PQ" visibility="protected"/>
    <importedDatatype name="PQR" visibility="protected"/>
    <importedDatatype name="QTY" visibility="protected"/>
    <importedDatatype name="REAL" visibility="protected"/>
    <importedDatatype name="RTO" visibility="public"/>
    <importedDatatype name="SET" visibility="protected"/>
    <importedDatatype name="ST" visibility="protected" alias="ST.UV"/>
    <importedDatatype name="TEL" visibility="protected"/>
    <importedDatatype name="TN" visibility="public"/>
    <importedDatatype name="TS" visibility="protected"/>
    <importedDatatype name="TYPE" visibility="protected"/>
    <importedDatatype name="UID" visibility="protected"/>
    <importedDatatype name="UUID" visibility="protected"/>
  </importDatatypeModelLibrary>
  <datatype name="TS.DATE" title="Timestamp (Date Only, Partial Date Allowed)" datatypeKind="Flavor" visibility="public">
    <derivedFrom relationship="restriction">
      <targetDatatype name="TS"/>
    </derivedFrom>
    <annotations>
      <documentation>
        <definition>
          <text>Only permits the "date" portion of the timestamp to be specified. Allows for partial dates.</text>
        </definition>
        <usageNotes>
          <text>
            <html:p>The string literal representation of this form is YYYY[MM[DD]].</html:p>
            <html:p>Dates (or portions) specified must be valid dates.</html:p>
          </text>
        </usageNotes>
      </documentation>
      <appInfo>
        <formalConstraint>
          <text>Timezone is not allowed, the precision is 8 or less and the calendar is fixed to be Gregorian</text>
          <alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (TS.DATE x) where x.nonNull {
x.timezone.isNull;
x.precision.lessOrEqual(8);
x.calendar.implies(Calendar.GREG);
};</alternateFormalExpression>
        </formalConstraint>
        <staticExample itsName="XML">
          <data>
            <effectiveTime xsi:type="TS" flavorId="TS.DATE" value="200508"/>
          </data>
        </staticExample>
      </appInfo>
    </annotations>
    <property name="timezone" conformance="NP" fixedValue="NullFlavor.NI">
      <derivedFrom relationship="restriction">
        <targetDatatype name="TS"/>
      </derivedFrom>
    </property>
    <property name="precision">
      <enumerationValue>4</enumerationValue>
      <enumerationValue>6</enumerationValue>
      <enumerationValue>8</enumerationValue>
      <derivedFrom relationship="restriction">
        <targetDatatype name="TS"/>
      </derivedFrom>
    </property>
  </datatype>
  <datatype name="TS.DATETIME" title="DateTime" datatypeKind="Flavor" visibility="public">
    <derivedFrom relationship="restriction">
      <targetDatatype name="TS"/>
    </derivedFrom>
    <annotations>
      <documentation>
        <definition>
          <text>Only permits the "date" and "time" portion of the timestamp to be specified. Does allow for partial dates and partial time, but timezone is mandatory if time is specified.</text>
        </definition>
        <usageNotes>
          <text>
            <html:p>The string literal representation of this form is YYYY[MM[DD[hh[mm[ss]]]]][+/-ZZZZ].</html:p>
            <html:p>Partial dates may be specified only if no time component is specified</html:p>
            <html:p>Dates and times (or portions) specified must be valid dates and times.</html:p>
          </text>
        </usageNotes>
      </documentation>
      <appInfo>
        <formalConstraint>
          <text>If the time is specified, the "timezone" portion of the timestamp must be specified</text>
          <alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (TS.DATETIME x) {
  x.precision.greaterThan(8).implies(x.timezone.nonNull);
};
          </alternateFormalExpression>
        </formalConstraint>
        <formalConstraint>
          <text>If the value is not null, there SHALL be 14 or less digits, and there can be a timezone. This flavor is specific to the gregorian calendar.</text>
          <alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (TS.DATETIME x) where x.nonNull {
  x.precision.lessOrEqual(14);
  x.calendar.implies(Calendar.GREG);
};</alternateFormalExpression>
        </formalConstraint>
        <staticExample itsName="XML">
          <data>
            <effectiveTime xsi:type="TS" flavorId="TS.DATETIME" value="200508021730-0800"/>
          </data>
        </staticExample>
      </appInfo>
    </annotations>
  </datatype>
  <datatype name="TS.FULLDATEWITHTIME" title="Timestamp (Date or DateTime)" datatypeKind="Flavor" visibility="public">
    <derivedFrom relationship="restriction">
      <targetDatatype name="TS"/>
    </derivedFrom>
    <childDatatype name="TS.FULLDATE"/>
    <childDatatype name="TS.FULLDATETIME"/>
  </datatype>
  <datatype name="TS.FULLDATE" title="Timestamp (Date)" datatypeKind="Flavor" visibility="public">
    <derivedFrom relationship="restriction">
      <targetDatatype name="TS"/>
    </derivedFrom>
    <annotations>
      <documentation>
        <definition>
          <text>Only permits the "date" portion of the timestamp to be specified. Does not allow for partial dates.</text>
        </definition>
        <usageNotes>
          <text>
            <html:p>The string literal representation of this form is YYYYMMDD (8 characters).</html:p>
            <html:p>Dates specified must be valid dates.</html:p>
          </text>
        </usageNotes>
      </documentation>
      <appInfo>
        <formalConstraint>
          <text>If the value is not null, there SHALL be 8 digits in the literal form, with no timezone. This flavor is specific to the gregorian calendar.</text>
          <alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (TS.FULLDATE x) where x.nonNull {
  x.precision.equal(8);
  x.timezone.isNull;
  x.calendar.implies(Calendar.GREG);
};</alternateFormalExpression>
        </formalConstraint>
        <staticExample itsName="XML">
          <data>
            <effectiveTime xsi:type="TS" flavorId="TS.FULLDATE" value="20050802"/>
          </data>
        </staticExample>
      </appInfo>
    </annotations>
    <property name="timezone" conformance="NP" fixedValue="NullFlavor.NI">
      <derivedFrom relationship="restriction">
        <targetDatatype name="TS"/>
      </derivedFrom>
    </property>
    <property name="precision" fixedValue="8">
      <derivedFrom relationship="restriction">
        <targetDatatype name="TS"/>
      </derivedFrom>
    </property>
  </datatype>
  <datatype name="TS.FULLDATETIME" title="Timestamp (Date+Time)" datatypeKind="Flavor" visibility="public">
    <historyItem isSubstantiveChange="true" dateTime="2007-12-07">
      <description>Added the specification of the "width" property, specified in days, weeks, months or years</description>
    </historyItem>
    <derivedFrom relationship="restriction">
      <targetDatatype name="TS"/>
    </derivedFrom>
    <annotations>
      <documentation>
        <definition>
          <text>Requires both the "date" and "time" portion of the timestamp to be fully specified, including timezone.</text>
        </definition>
        <usageNotes>
          <text>The grammar for the date/time is: YYYYMMDDHHMMSS[.SSSS] +/-ZZZZ (19 or 24 characters).</text>
        </usageNotes>
        <requirements>
          <text>Ballot comment #18</text>
        </requirements>
      </documentation>
      <appInfo>
        <formalConstraint>
          <text>If the value is not null, there SHALL be 14 or more digits in the literal form. There SHALL be a timezone. This flavor is specific to the gregorian calendar.</text>
          <alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (TS.FULLDATETIME x) where x.nonNull {
  x.precision.greaterOrEqual(14);
  x.timezone.nonNull;
};</alternateFormalExpression>
        </formalConstraint>
        <staticExample itsName="XML">
          <data>
            <effectiveTime xsi:type="TS" flavorId="TS.FULLDATETIME" value="20050802173000-0800"/>
          </data>
        </staticExample>
      </appInfo>
    </annotations>
    <property name="timezone" conformance="R" minimumMultiplicity="1" isMandatory="true">
      <derivedFrom relationship="restriction">
        <targetDatatype name="TS"/>
      </derivedFrom>
    </property>
    <property name="precision" fixedValue="14">
      <derivedFrom relationship="restriction">
        <targetDatatype name="TS"/>
      </derivedFrom>
    </property>
  </datatype>
  <datatype name="IVL_TS.DATE" title="Partial Date Range" datatypeKind="Binding" visibility="public">
    <annotations>
      <documentation>
        <definition>
          <text>This data type is used when a date range needs to be conveyed where neither the start nor end date will always be known to the complete date</text>
        </definition>
        <usageConstraint>
          <text>When sending over the wire, a maximum of two of low, high and width should be sent.</text>
        </usageConstraint>
      </documentation>
      <appInfo>
        <formalConstraint>
          <text>Low, high and width cannot have null flavors PINF or NINF</text>
          <alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (IVL&lt;TS.DATE&gt; x) {
  x.low.nullFlavor.implies(NullFlavor.NINF).not.and(x.low.nullFlavor.implies(NullFlavor.PINF).not);
  x.high.nullFlavor.implies(NullFlavor.NINF).not.and(x.high.nullFlavor.implies(NullFlavor.PINF).not);
  x.width.nullFlavor.implies(NullFlavor.NINF).not.and(x.width.nullFlavor.implies(NullFlavor.PINF).not);
};          </alternateFormalExpression>
        </formalConstraint>
        <formalConstraint>
          <text>At least two of high, low and width must be *present* (though they can be null flavors) for the URG to satisfy a 'mandatory' constraint.</text>
          <!-- Grahame: Datatypes R3 needs a way to cleanly state this -->
        </formalConstraint>
        <staticExample itsName="XML">
          <data>
            <effectiveTime xsi:type="IVL_TS">
              <low xsi:type="TS" flavorId="TS.DATE" value="20000301"/>
              <high xsi:type="TS" flavorId="TS.DATE" value="200007"/>
            </effectiveTime>
          </data>
          <businessName name="from March 01, 2000 to July 2000"/>
        </staticExample>
        <staticExample itsName="XML">
          <data>
            <effectiveTime xsi:type="IVL_TS">
              <low xsi:type="TS" flavorId="TS.DATE" value="200003"/>
              <high xsi:type="TS" flavorId="TS.DATE" nullFlavor="NA"/>
            </effectiveTime>
          </data>
          <businessName name="beginning March 2000, not yet ended"/>
        </staticExample>
      </appInfo>
    </annotations>
    <binding>
      <targetDatatype name="IVL"/>
      <argumentDatatype name="TS.DATE"/>
    </binding>
    <property name="lowClosed" conformance="NP" fixedValue="true">
      <derivedFrom relationship="restriction">
        <targetDatatype name="IVL"/>
      </derivedFrom>
    </property>
    <property name="highClosed" conformance="NP" fixedValue="true">
      <derivedFrom relationship="restriction">
        <targetDatatype name="IVL"/>
      </derivedFrom>
    </property>
    <property name="center" conformance="NP" fixedValue="NullFlavor.NI">
      <derivedFrom relationship="restriction">
        <targetDatatype name="IVL"/>
      </derivedFrom>
    </property>
    <property name="low" conformance="R">
      <derivedFrom relationship="restriction">
        <targetDatatype name="IVL"/>
      </derivedFrom>
      <type name="TS.DATE"/>
    </property>
    <property name="high" conformance="R">
      <derivedFrom relationship="restriction">
        <targetDatatype name="IVL"/>
      </derivedFrom>
      <type name="TS.DATE"/>
    </property>
    <property name="width" conformance="R">
      <annotations>
        <appInfo>
          <formalConstraint>
            <text>Unit must be days, weeks, months or years</text>
            <alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (IVL&lt;TS.DATE&gt; x) {
  x.width.notNull.implies(x.width.unit.equal("d").or(x.width.unit.equal("wk")).or(x.width.unit.equal("mo")).or(x.width.unit.equal("a")));
};          </alternateFormalExpression>
          </formalConstraint>
        </appInfo>
      </annotations>
      <derivedFrom relationship="restriction">
        <targetDatatype name="IVL"/>
      </derivedFrom>
      <type name="PQ.TIME"/>
    </property>
  </datatype>
  <datatype name="URG_TS.DATE" title="Uncertain Date" datatypeKind="Binding" visibility="public">
    <annotations>
      <documentation>
        <definition>
          <text>This data type is used when an occurrence is tied to a specific date, but the actual date is not known, merely the range of dates within which the date falls. This differs from IVL&lt;TS.DATE&gt; in that it refers to a single occurrence rather than a period covering multiple days.</text>
        </definition>
        <usageConstraint>
          <text>When sending over the wire, a maximum of two of low, high, center and width should be sent.</text>
        </usageConstraint>
      </documentation>
      <appInfo>
        <formalConstraint>
          <text>Low, high and width cannot have null flavors PINF or NINF</text>
          <alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (URG&lt;TS.DATE&gt; x) {
  x.low.nullFlavor.implies(NullFlavor.NINF).not.and(x.low.nullFlavor.implies(NullFlavor.PINF).not);
  x.high.nullFlavor.implies(NullFlavor.NINF).not.and(x.high.nullFlavor.implies(NullFlavor.PINF).not);
  x.width.nullFlavor.implies(NullFlavor.NINF).not.and(x.width.nullFlavor.implies(NullFlavor.PINF).not);
};          </alternateFormalExpression>
        </formalConstraint>
        <formalConstraint>
          <text>At least two of high, low, center and width must be *present* (though they can be null flavors) for the URG to satisfy a 'mandatory' constraint.</text>
          <!-- Grahame: Datatypes R3 needs a way to cleanly state this -->
        </formalConstraint>
        <staticExample itsName="XML">
          <data>
            <effectiveTime xsi:type="URG_TS">
              <center xsi:type="TS" flavorId="TS.DATE" value="200404"/>
              <width xsi:type="PQ" flavorId="PQ.TIME" value="4" unit="m"/>
            </effectiveTime>
          </data>
          <businessName name="April, 2004 +/- 2 months"/>
        </staticExample>
      </appInfo>
    </annotations>
    <binding>
      <targetDatatype name="URG"/>
      <argumentDatatype name="TS.DATE"/>
    </binding>
    <property name="range" conformance="R" minimumMultiplicity="1">
      <derivedFrom relationship="restriction">
        <targetDatatype name="URG"/>
      </derivedFrom>
      <type name="IVL_TS.DATE"/>
    </property>
  </datatype>
  <datatype name="IVL_TS.DATETIME" title="Partial Date + Time Range" datatypeKind="Binding" visibility="public">
    <annotations>
      <documentation>
        <definition>
          <text>Used when a time range needs to be conveyed where the boundaries of the range can be imprecise.</text>
        </definition>
        <usageConstraint>
          <text>When sending over the wire, a maximum of two of low, high and width should be sent.</text>
        </usageConstraint>
      </documentation>
      <appInfo>
        <formalConstraint>
          <text>Low, high and width cannot have null flavors PINF or NINF</text>
          <alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (IVL&lt;TS.DATETIME&gt; x) {
  x.low.nullFlavor.implies(NullFlavor.NINF).not.and(x.low.nullFlavor.implies(NullFlavor.PINF).not);
  x.high.nullFlavor.implies(NullFlavor.NINF).not.and(x.high.nullFlavor.implies(NullFlavor.PINF).not);
  x.width.nullFlavor.implies(NullFlavor.NINF).not.and(x.width.nullFlavor.implies(NullFlavor.PINF).not);
};          </alternateFormalExpression>
        </formalConstraint>
        <formalConstraint>
          <text>At least two of high, low and width must be *present* (though they can be null flavors) for the URG to satisfy a 'mandatory' constraint.</text>
          <!-- Grahame: Datatypes R3 needs a way to cleanly state this -->
        </formalConstraint>
        <staticExample itsName="XML">
          <data>
            <effectiveTime xsi:type="IVL_TS">
              <low xsi:type="TS" flavorId="TS.DATETIME" value="200003011500-0700"/>
              <high xsi:type="TS" flavorId="TS.DATETIME" value="200007150400-0700"/>
            </effectiveTime>
          </data>
          <businessName name="from March 01, 2000 @ 3:00 PM to July 15, 2000 @ 4:00 AM (Alberta time)"/>
        </staticExample>
        <staticExample itsName="XML">
          <data>
            <effectiveTime xsi:type="IVL_TS">
              <low xsi:type="TS" flavorId="TS.DATE" value="200003"/>
              <high xsi:type="TS" flavorId="TS.DATE" nullFlavor="NA"/>
            </effectiveTime>
          </data>
          <businessName name="beginning March 2000, not yet ended"/>
        </staticExample>
      </appInfo>
    </annotations>
    <binding>
      <targetDatatype name="IVL"/>
      <argumentDatatype name="TS.DATE"/>
    </binding>
    <property name="lowClosed" conformance="NP" fixedValue="true">
      <derivedFrom relationship="restriction">
        <targetDatatype name="IVL"/>
      </derivedFrom>
    </property>
    <property name="highClosed" conformance="NP" fixedValue="true">
      <derivedFrom relationship="restriction">
        <targetDatatype name="IVL"/>
      </derivedFrom>
    </property>
    <property name="center" conformance="NP" fixedValue="NullFlavor.NI">
      <derivedFrom relationship="restriction">
        <targetDatatype name="IVL"/>
      </derivedFrom>
    </property>
    <property name="low" conformance="R">
      <derivedFrom relationship="restriction">
        <targetDatatype name="IVL"/>
      </derivedFrom>
      <type name="TS.DATETIME"/>
    </property>
    <property name="high" conformance="R">
      <derivedFrom relationship="restriction">
        <targetDatatype name="IVL"/>
      </derivedFrom>
      <type name="TS.DATETIME"/>
    </property>
    <property name="width" conformance="R">
      <derivedFrom relationship="restriction">
        <targetDatatype name="IVL"/>
      </derivedFrom>
      <type name="PQ.TIME"/>
    </property>
  </datatype>
  <datatype name="IVL_TS.FULLDATE" title="Precise Date Range" datatypeKind="Binding" visibility="public">
    <historyItem isSubstantiveChange="true" dateTime="2007-12-07">
      <description>Added the specification of the "width" property, specified in days, weeks, months or years</description>
    </historyItem>
    <annotations>
      <documentation>
        <definition>
          <text>This data type is used when a date range needs to be conveyed with precise start and/or end dates</text>
        </definition>
        <usageConstraint>
          <text>When sending over the wire, a maximum of two of low, high and width should be sent.</text>
        </usageConstraint>
        <requirements>
          <text>Ballot comment #18</text>
        </requirements>
      </documentation>
      <appInfo>
        <formalConstraint>
          <text>Low, high and width cannot have null flavors PINF or NINF</text>
          <alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (IVL&lt;TS.FULLDATE&gt; x) {
  x.low.nullFlavor.implies(NullFlavor.NINF).not.and(x.low.nullFlavor.implies(NullFlavor.PINF).not);
  x.high.nullFlavor.implies(NullFlavor.NINF).not.and(x.high.nullFlavor.implies(NullFlavor.PINF).not);
  x.width.nullFlavor.implies(NullFlavor.NINF).not.and(x.width.nullFlavor.implies(NullFlavor.PINF).not);
};          </alternateFormalExpression>
        </formalConstraint>
        <formalConstraint>
          <text>At least two of high, low and width must be *present* (though they can be null flavors) for the URG to satisfy a 'mandatory' constraint.</text>
          <!-- Grahame: Datatypes R3 needs a way to cleanly state this -->
        </formalConstraint>
        <staticExample itsName="XML">
          <data>
            <effectiveTime xsi:type="IVL_TS">
              <low xsi:type="TS" flavorId="TS.FULLDATE" value="20000301"/>
              <high xsi:type="TS" flavorId="TS.FULLDATE" value="20000715"/>
            </effectiveTime>
          </data>
          <businessName name="from March 01, 2000 to July 15, 2000"/>
        </staticExample>
      </appInfo>
    </annotations>
    <binding>
      <targetDatatype name="IVL"/>
      <argumentDatatype name="TS.FULLDATE"/>
    </binding>
    <property name="lowClosed" conformance="NP" fixedValue="true">
      <derivedFrom relationship="restriction">
        <targetDatatype name="IVL"/>
      </derivedFrom>
    </property>
    <property name="highClosed" conformance="NP" fixedValue="true">
      <derivedFrom relationship="restriction">
        <targetDatatype name="IVL"/>
      </derivedFrom>
    </property>
    <property name="center" conformance="NP" fixedValue="NullFlavor.NI">
      <derivedFrom relationship="restriction">
        <targetDatatype name="IVL"/>
      </derivedFrom>
    </property>
    <property name="low" conformance="R">
      <derivedFrom relationship="restriction">
        <targetDatatype name="IVL"/>
      </derivedFrom>
      <type name="TS.FULLDATE"/>
    </property>
    <property name="high" conformance="R">
      <derivedFrom relationship="restriction">
        <targetDatatype name="IVL"/>
      </derivedFrom>
      <type name="TS.FULLDATE"/>
    </property>
    <property name="width" conformance="R">
      <annotations>
        <appInfo>
          <formalConstraint>
            <text>Unit must be days, weeks, months or years</text>
            <alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (IVL&lt;TS.FULLDATE&gt; x) {
  x.width.notNull.implies(x.width.unit.equal("d").or(x.width.unit.equal("wk")).or(x.width.unit.equal("mo")).or(x.width.unit.equal("a")));
};          </alternateFormalExpression>
          </formalConstraint>
        </appInfo>
      </annotations>
      <derivedFrom relationship="restriction">
        <targetDatatype name="IVL"/>
      </derivedFrom>
      <type name="PQ.TIME"/>
    </property>
  </datatype>
  <datatype name="IVL_TS.FULLDATETIME" title="Precise Date-Time Range" datatypeKind="Binding" visibility="public">
    <annotations>
      <documentation>
        <definition>
          <text>Used when a time range needs to be conveyed with precise start and/or end times.</text>
        </definition>
      </documentation>
      <appInfo>
        <formalConstraint>
          <text>Low and high cannot have null flavors PINF or NINF</text>
          <alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (IVL&lt;TS.FULLDATETIME&gt; x) {
  x.low.nullFlavor.implies(NullFlavor.NINF).not.and(x.low.nullFlavor.implies(NullFlavor.PINF).not);
  x.high.nullFlavor.implies(NullFlavor.NINF).not.and(x.high.nullFlavor.implies(NullFlavor.PINF).not);
};          </alternateFormalExpression>
        </formalConstraint>
        <staticExample itsName="XML">
          <data>
            <effectiveTime xsi:type="IVL_TS">
              <low xsi:type="TS" flavorId="TS.FULLDATETIME" value="20000301153000-0500"/>
              <high xsi:type="TS" flavorId="TS.FULLDATETIME" value="20000715043000-0500"/>
            </effectiveTime>
          </data>
          <businessName name="from March 01, 2000 @ 3:30:00 PM to July 15, 2000 @ 4:30:00 AM, Ontario time"/>
        </staticExample>
      </appInfo>
    </annotations>
    <binding>
      <targetDatatype name="IVL"/>
      <argumentDatatype name="TS.FULLDATETIME"/>
    </binding>
    <property name="lowClosed" conformance="NP" fixedValue="true">
      <derivedFrom relationship="restriction">
        <targetDatatype name="IVL"/>
      </derivedFrom>
    </property>
    <property name="highClosed" conformance="NP" fixedValue="true">
      <derivedFrom relationship="restriction">
        <targetDatatype name="IVL"/>
      </derivedFrom>
    </property>
    <property name="center" conformance="NP" fixedValue="NullFlavor.NI">
      <derivedFrom relationship="restriction">
        <targetDatatype name="IVL"/>
      </derivedFrom>
    </property>
    <property name="width" conformance="NP" fixedValue="NullFlavor.NI">
      <derivedFrom relationship="restriction">
        <targetDatatype name="IVL"/>
      </derivedFrom>
    </property>
    <property name="low" conformance="R" minimumMultiplicity="1">
      <derivedFrom relationship="restriction">
        <targetDatatype name="IVL"/>
      </derivedFrom>
      <type name="TS.FULLDATETIME"/>
    </property>
    <property name="high" conformance="R" minimumMultiplicity="1">
      <derivedFrom relationship="restriction">
        <targetDatatype name="IVL"/>
      </derivedFrom>
      <type name="TS.FULLDATETIME"/>
    </property>
  </datatype>
  <datatype name="IVL.LOW_TS.DATE" title="Partial Start Date" datatypeKind="Binding" visibility="public">
    <annotations>
      <documentation>
        <definition>
          <text>Used to convey the start date of a range only. Allows for partial dates.</text>
        </definition>
      </documentation>
      <appInfo>
        <formalConstraint>
          <text>End date is Unknown</text>
          <alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (IVL.LOW&lt;TS.DATE&gt; x) {
  x.high.nullFlavor.implies(NullFlavor.UNK)
};          </alternateFormalExpression>
        </formalConstraint>
        <staticExample itsName="XML">
          <data>
            <effectiveTime xsi:type="IVL_TS">
              <low xsi:type="TS" flavorId="TS.DATE" value="200507"/>
            </effectiveTime>
          </data>
          <businessName name="Began July, 2005"/>
        </staticExample>
      </appInfo>
    </annotations>
    <binding>
      <targetDatatype name="IVL.LOW"/>
      <argumentDatatype name="TS.DATE"/>
    </binding>
    <property name="lowClosed" conformance="NP" fixedValue="true">
      <derivedFrom relationship="restriction">
        <targetDatatype name="IVL"/>
      </derivedFrom>
    </property>
    <property name="highClosed" conformance="NP" fixedValue="true">
      <derivedFrom relationship="restriction">
        <targetDatatype name="IVL"/>
      </derivedFrom>
    </property>
    <property name="center" conformance="NP" fixedValue="NullFlavor.NI">
      <derivedFrom relationship="restriction">
        <targetDatatype name="IVL"/>
      </derivedFrom>
    </property>
    <property name="width" conformance="NP" fixedValue="NullFlavor.NI">
      <derivedFrom relationship="restriction">
        <targetDatatype name="IVL"/>
      </derivedFrom>
    </property>
    <property name="high" conformance="NP" fixedValue="NullFlavor.NI">
      <derivedFrom relationship="restriction">
        <targetDatatype name="IVL"/>
      </derivedFrom>
    </property>
    <property name="low" isMandatory="true" conformance="R" minimumMultiplicity="1">
      <derivedFrom relationship="restriction">
        <targetDatatype name="IVL"/>
      </derivedFrom>
      <type name="TS.DATE"/>
    </property>
  </datatype>
  <datatype name="IVL.LOW" title="Low value" datatypeKind="Flavor" visibility="protected">
    <derivedFrom relationship="restriction">
      <targetDatatype name="IVL"/>
    </derivedFrom>
    <annotations>
      <documentation>
        <definition>
          <text>Used to convey an interval where only the lower bound is unknown.</text>
        </definition>
      </documentation>
      <appInfo>
        <formalConstraint>
          <text>End value is Unknown</text>
          <alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (IVL.LOW x) {
  x.high.nullFlavor.implies(NullFlavor.UNK)
};          </alternateFormalExpression>
        </formalConstraint>
      </appInfo>
    </annotations>
    <parameter sortKey="1" name="T">
      <type name="QTY"/>
    </parameter>
    <property name="lowClosed" conformance="NP" fixedValue="true">
      <derivedFrom relationship="restriction">
        <targetDatatype name="IVL"/>
      </derivedFrom>
    </property>
    <property name="highClosed" conformance="NP" fixedValue="true">
      <derivedFrom relationship="restriction">
        <targetDatatype name="IVL"/>
      </derivedFrom>
    </property>
    <property name="center" conformance="NP" fixedValue="NullFlavor.NI">
      <derivedFrom relationship="restriction">
        <targetDatatype name="IVL"/>
      </derivedFrom>
    </property>
    <property name="width" conformance="NP" fixedValue="NullFlavor.NI">
      <derivedFrom relationship="restriction">
        <targetDatatype name="IVL"/>
      </derivedFrom>
    </property>
    <property name="high" conformance="NP" fixedValue="NullFlavor.NI">
      <derivedFrom relationship="restriction">
        <targetDatatype name="IVL"/>
      </derivedFrom>
    </property>
    <property name="low" isMandatory="true" conformance="R" minimumMultiplicity="1">
      <derivedFrom relationship="restriction">
        <targetDatatype name="IVL"/>
      </derivedFrom>
      <type name="T" qualifier="parameter"/>
    </property>
  </datatype>
  <datatype name="IVL.LOW_TS.FULLDATE" title="Precise Start Date" datatypeKind="Binding" visibility="public">
    <annotations>
      <documentation>
        <definition>
          <text>Used to convey the start date of a range only. Does not allow for partial dates.</text>
        </definition>
      </documentation>
      <appInfo>
        <formalConstraint>
          <text>End date is Unknown</text>
          <alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (IVL.LOW&lt;TS.FULLDATE&gt; x) {
  x.high.nullFlavor.implies(NullFlavor.UNK)
};          </alternateFormalExpression>
        </formalConstraint>
        <staticExample itsName="XML">
          <data>
            <effectiveTime xsi:type="IVL_TS">
              <low xsi:type="TS" flavorId="TS.FULLDATE" value="20050706-0800"/>
            </effectiveTime>
          </data>
          <businessName name="Begin July 6, 2005"/>
        </staticExample>
      </appInfo>
    </annotations>
    <binding>
      <targetDatatype name="IVL.LOW"/>
      <argumentDatatype name="TS.FULLDATE"/>
    </binding>
    <property name="lowClosed" conformance="NP" fixedValue="true">
      <derivedFrom relationship="restriction">
        <targetDatatype name="IVL"/>
      </derivedFrom>
    </property>
    <property name="highClosed" conformance="NP" fixedValue="true">
      <derivedFrom relationship="restriction">
        <targetDatatype name="IVL"/>
      </derivedFrom>
    </property>
    <property name="center" conformance="NP" fixedValue="NullFlavor.NI">
      <derivedFrom relationship="restriction">
        <targetDatatype name="IVL"/>
      </derivedFrom>
    </property>
    <property name="width" conformance="NP" fixedValue="NullFlavor.NI">
      <derivedFrom relationship="restriction">
        <targetDatatype name="IVL"/>
      </derivedFrom>
    </property>
    <property name="high" conformance="NP" fixedValue="NullFlavor.NI">
      <derivedFrom relationship="restriction">
        <targetDatatype name="IVL"/>
      </derivedFrom>
    </property>
    <property name="low" isMandatory="true" conformance="R" minimumMultiplicity="1">
      <derivedFrom relationship="restriction">
        <targetDatatype name="IVL"/>
      </derivedFrom>
      <type name="TS.FULLDATE"/>
    </property>
  </datatype>
  <datatype name="IVL.HIGH" title="High value" datatypeKind="Flavor" visibility="protected">
    <derivedFrom relationship="restriction">
      <targetDatatype name="IVL"/>
    </derivedFrom>
    <annotations>
      <documentation>
        <definition>
          <text>This data type is used when only the high value is known.</text>
        </definition>
      </documentation>
      <appInfo>
        <formalConstraint>
          <text>Start value is Unknown</text>
          <alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (IVL.HIGH x) {
  x.low.nullFlavor.implies(NullFlavor.UNK)
};          </alternateFormalExpression>
        </formalConstraint>
      </appInfo>
    </annotations>
    <parameter sortKey="1" name="T">
      <type name="QTY"/>
    </parameter>
    <property name="lowClosed" conformance="NP" fixedValue="true">
      <derivedFrom relationship="restriction">
        <targetDatatype name="IVL"/>
      </derivedFrom>
    </property>
    <property name="highClosed" conformance="NP" fixedValue="true">
      <derivedFrom relationship="restriction">
        <targetDatatype name="IVL"/>
      </derivedFrom>
    </property>
    <property name="center" conformance="NP" fixedValue="NullFlavor.NI">
      <derivedFrom relationship="restriction">
        <targetDatatype name="IVL"/>
      </derivedFrom>
    </property>
    <property name="width" conformance="NP" fixedValue="NullFlavor.NI">
      <derivedFrom relationship="restriction">
        <targetDatatype name="IVL"/>
      </derivedFrom>
    </property>
    <property name="low" conformance="NP" fixedValue="NullFlavor.NI">
      <derivedFrom relationship="restriction">
        <targetDatatype name="IVL"/>
      </derivedFrom>
    </property>
    <property name="high" isMandatory="true" conformance="R" minimumMultiplicity="1">
      <derivedFrom relationship="restriction">
        <targetDatatype name="IVL"/>
      </derivedFrom>
      <type name="T" qualifier="parameter"/>
    </property>
  </datatype>
  <datatype name="IVL.HIGH_TS.FULLDATE" title="Precise End Date" datatypeKind="Binding" visibility="public">
    <annotations>
      <documentation>
        <definition>
          <text>This data type is used when both a start and end date may exist, but only the end date should be captured. Does not allow for partial dates.</text>
        </definition>
      </documentation>
      <appInfo>
        <formalConstraint>
          <text>Start date is Unknown</text>
          <alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (IVL.HIGH&lt;TS.FULLDATE&gt; x) {
  x.low.nullFlavor.implies(NullFlavor.UNK)
};          </alternateFormalExpression>
        </formalConstraint>
        <staticExample itsName="XML">
          <data>
            <effectiveTime xsi:type="IVL_TS">
              <high xsi:type="TS" flavorId="TS.FULLDATE" value="20030915-0430"/>
            </effectiveTime>
          </data>
          <businessName name="End, September 15, 2003"/>
        </staticExample>
      </appInfo>
    </annotations>
    <binding>
      <targetDatatype name="IVL.HIGH"/>
      <argumentDatatype name="TS.FULLDATE"/>
    </binding>
    <property name="lowClosed" conformance="NP" fixedValue="true">
      <derivedFrom relationship="restriction">
        <targetDatatype name="IVL"/>
      </derivedFrom>
    </property>
    <property name="highClosed" conformance="NP" fixedValue="true">
      <derivedFrom relationship="restriction">
        <targetDatatype name="IVL"/>
      </derivedFrom>
    </property>
    <property name="center" conformance="NP" fixedValue="NullFlavor.NI">
      <derivedFrom relationship="restriction">
        <targetDatatype name="IVL"/>
      </derivedFrom>
    </property>
    <property name="width" conformance="NP" fixedValue="NullFlavor.NI">
      <derivedFrom relationship="restriction">
        <targetDatatype name="IVL"/>
      </derivedFrom>
    </property>
    <property name="low" conformance="NP" fixedValue="NullFlavor.NI">
      <derivedFrom relationship="restriction">
        <targetDatatype name="IVL"/>
      </derivedFrom>
    </property>
    <property name="high" isMandatory="true" conformance="R" minimumMultiplicity="1">
      <derivedFrom relationship="restriction">
        <targetDatatype name="IVL"/>
      </derivedFrom>
      <type name="TS.FULLDATE"/>
    </property>
  </datatype>
  <datatype name="IVL.WIDTH" title="Duration" datatypeKind="Flavor" visibility="protected">
    <derivedFrom relationship="restriction">
      <targetDatatype name="IVL"/>
    </derivedFrom>
    <annotations>
      <documentation>
        <definition>
          <text>This data type is used to convey the width of an interval where low and high are not needed.</text>
        </definition>
      </documentation>
      <appInfo>
        <formalConstraint>
          <text>High and low are Unknown</text>
          <alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (IVL.WIDTH&lt;TS.FULLDATE&gt; x) {
  x.low.nullFlavor.implies(NullFlavor.UNK);
  x.high.nullFlavor.implies(NullFlavor.UNK);
};          </alternateFormalExpression>
        </formalConstraint>
      </appInfo>
    </annotations>
    <parameter sortKey="1" name="T">
      <type name="QTY"/>
    </parameter>
    <property name="lowClosed" conformance="NP" fixedValue="true">
      <derivedFrom relationship="restriction">
        <targetDatatype name="IVL"/>
      </derivedFrom>
    </property>
    <property name="highClosed" conformance="NP" fixedValue="true">
      <derivedFrom relationship="restriction">
        <targetDatatype name="IVL"/>
      </derivedFrom>
    </property>
    <property name="center" conformance="NP" fixedValue="NullFlavor.NI">
      <derivedFrom relationship="restriction">
        <targetDatatype name="IVL"/>
      </derivedFrom>
    </property>
    <property name="low" conformance="NP" fixedValue="NullFlavor.NI">
      <derivedFrom relationship="restriction">
        <targetDatatype name="IVL"/>
      </derivedFrom>
    </property>
    <property name="high" conformance="NP" fixedValue="NullFlavor.NI">
      <derivedFrom relationship="restriction">
        <targetDatatype name="IVL"/>
      </derivedFrom>
    </property>
    <property name="width" isMandatory="true" conformance="R" minimumMultiplicity="1">
      <derivedFrom relationship="restriction">
        <targetDatatype name="IVL"/>
      </derivedFrom>
      <type name="QTY"/>
    </property>
  </datatype>
  <datatype name="IVL.WIDTH_FULLDATE" title="Duration" datatypeKind="Binding" visibility="public">
    <annotations>
      <documentation>
        <definition>
          <text>This data type is used to convey duration where the specific start and end days are not needed.</text>
        </definition>
      </documentation>
      <appInfo>
        <formalConstraint>
          <text>Start date and end date are Unknown</text>
          <alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (IVL.WIDTH&lt;TS.FULLDATE&gt; x) {
  x.low.nullFlavor.implies(NullFlavor.UNK);
  x.high.nullFlavor.implies(NullFlavor.UNK);
};          </alternateFormalExpression>
        </formalConstraint>
        <staticExample itsName="XML">
          <data>
            <effectiveTime xsi:type="IVL_TS">
              <width xsi:type="PQ" flavorId="PQ.TIME" value="23" unit="d"/>
            </effectiveTime>
          </data>
          <businessName name="23 days"/>
        </staticExample>
      </appInfo>
    </annotations>
    <binding>
      <targetDatatype name="IVL.WIDTH"/>
      <argumentDatatype name="TS.FULLDATE"/>
    </binding>
    <property name="lowClosed" conformance="NP" fixedValue="true">
      <derivedFrom relationship="restriction">
        <targetDatatype name="IVL"/>
      </derivedFrom>
    </property>
    <property name="highClosed" conformance="NP" fixedValue="true">
      <derivedFrom relationship="restriction">
        <targetDatatype name="IVL"/>
      </derivedFrom>
    </property>
    <property name="center" conformance="NP" fixedValue="NullFlavor.NI">
      <derivedFrom relationship="restriction">
        <targetDatatype name="IVL"/>
      </derivedFrom>
    </property>
    <property name="low" conformance="NP" fixedValue="NullFlavor.NI">
      <derivedFrom relationship="restriction">
        <targetDatatype name="IVL"/>
      </derivedFrom>
    </property>
    <property name="high" conformance="NP" fixedValue="NullFlavor.NI">
      <derivedFrom relationship="restriction">
        <targetDatatype name="IVL"/>
      </derivedFrom>
    </property>
    <property name="width" isMandatory="true" conformance="R" minimumMultiplicity="1">
      <derivedFrom relationship="restriction">
        <targetDatatype name="IVL"/>
      </derivedFrom>
      <type name="PQ.TIME"/>
    </property>
  </datatype>
  <datatype name="PIVL_TS.DATETIME" title="Periodic Interval of Time" datatypeKind="Binding" visibility="public">
    <annotations>
      <documentation>
        <definition>
          <text>Allows communication of a frequency.</text>
        </definition>
      </documentation>
      <appInfo>
        <formalConstraint>
          <text>Frequency numerator and denominator cannot be null when PIVL is not null</text>
          <alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (PIVL&lt;TS.DATETIME&gt; x) {
  x.notNull.implies(x.frequency.numerator.notNull.and(x.frequency.denominator.notNull));
};          </alternateFormalExpression>
        </formalConstraint>
        <staticExample itsName="XML">
          <data>
            <effectiveTime xsi:type="PIVL_TS">
              <frequency>
                <numerator xsi:type="INT" flavorId="INT.NONNEG" value="3"/>
                <denominator xsi:type="PQ" flavorId="PQ.TIME" value="1" unit="d"/>
              </frequency>
            </effectiveTime>
          </data>
          <businessName name="3 times per day"/>
        </staticExample>
      </appInfo>
    </annotations>
    <binding>
      <targetDatatype name="PIVL"/>
      <argumentDatatype name="TS.DATETIME"/>
    </binding>
    <property name="phase" conformance="NP" fixedValue="NullFlavor.NI">
      <derivedFrom relationship="restriction">
        <targetDatatype name="PIVL"/>
      </derivedFrom>
    </property>
    <property name="period" conformance="NP">
      <derivedFrom relationship="restriction">
        <targetDatatype name="PIVL"/>
      </derivedFrom>
    </property>
    <property name="alignment" conformance="NP" fixedValue="NullFlavor.NI">
      <derivedFrom relationship="restriction">
        <targetDatatype name="PIVL"/>
      </derivedFrom>
    </property>
    <property name="institutionSpecifiedTime" conformance="NP" fixedValue="NullFlavor.NI">
      <derivedFrom relationship="restriction">
        <targetDatatype name="PIVL"/>
      </derivedFrom>
    </property>
    <property name="frequency" isMandatory="true" conformance="R" minimumMultiplicity="1">
      <annotations>
        <documentation>
          <definition>
            <text>Conveys how often the occurrence should or did happen.</text>
          </definition>
          <usageNotes>
            <text>Numerator identifies the number of repetitions within a given time period.  Denuminator identifies the time period.</text>
          </usageNotes>
        </documentation>
      </annotations>
      <derivedFrom relationship="restriction">
        <targetDatatype name="PIVL"/>
      </derivedFrom>
      <type name="RTO">
        <argumentDatatype name="INT.NONNEG"/>
        <argumentDatatype name="PQ.TIME"/>
      </type>
    </property>
  </datatype>
  <datatype name="GTS.BOUNDEDPIVL" title="General Timing Specification (Time-range and Frequency)" datatypeKind="Flavor" visibility="public">
    <derivedFrom relationship="restriction">
      <targetDatatype name="GTS"/>
    </derivedFrom>
    <annotations>
      <documentation>
        <definition>
          <text>This data type is used to convey two pieces of information: The overall time-period when something occurred (or is to occur), as well as how often it should/did occur within that time-period</text>
        </definition>
        <usageNotes>
          <text>SXPR_TS is the mechanism for implementing the GTS data type. Value is not permitted.</text>
        </usageNotes>
      </documentation>
      <appInfo>
        <formalConstraint>
          <!-- Grahame: No clue how to express this in DTDL -->
          <text>The first mandatory repetition must comply with the IVL&lt;TS.FULLDATE&gt; specification and indicates the overall timeperiod.  It must have an additional mandatory "operator" property with a value of "I" for intersection, indicating that the time of occurrence is the combination of both the outer time interval and the inner frequency.
The second mandatory repetition must comply with the PIVL&lt;TS.DATETIME&gt; specification and indicates the frequency.</text>
        </formalConstraint>
        <staticExample itsName="XML">
          <data>
            <effectiveTime xsi:type="SXPR_TS">
              <comp xsi:type="IVL_TS" operator="I">
                <low xsi:type="TS" flavorId="TS.FULLDATE" value="20050803"/>
                <width xsi:type="TS" flavorId="TS.FULLDATE" value="3" unit="wk"/>
              </comp>
              <comp xsi:type="PIVL_TS">
                <frequency>
                  <numerator xsi:type="INT" flavorId="INT.NONNEG" value="3"/>
                  <denominator xsi:type="PQ" flavorId="PQ.TIME" value="1" unit="d"/>
                </frequency>
              </comp>
            </effectiveTime>
          </data>
          <businessName name="3 times/day beginning August 3rd 2005 for 3 weeks"/>
        </staticExample>
      </appInfo>
    </annotations>
  </datatype>
  <datatype name="II" title="Instance Identifier" datatypeKind="Definition" visibility="protected" isAbstract="true">
    <derivedFrom relationship="restriction">
      <targetDatatype name="II"/>
    </derivedFrom>
    <annotations>
      <documentation>
        <definition>
          <text>
            <html:p>The instance identifier data type is used to communicate all "identifiers", including identifiers for people, records, versions, messages, etc.</html:p>
            <html:p>This data type may be referenced in Canadian specifications. If this data type is used in a message instance, it must be declared as one of the constrained version of II (e.g. II.OID) for each repetition.</html:p>
          </text>
        </definition>
        <usageNotes>
          <text>The rules stated here for II apply to <html:b>all</html:b> flavors of II.</text>
        </usageNotes>
      </documentation>
    </annotations>
    <property name="root" isMandatory="true" conformance="R" minimumMultiplicity="1" maximumLength="200">
      <annotations>
        <appInfo>
          <formalConstraint>
            <text>Root must be either an OID or a UUID (GUID)</text>
            <alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (II x) {
  x.root.type.implies(OID).or(x.root.type.implies(UUID));
};          </alternateFormalExpression>
          </formalConstraint>
        </appInfo>
      </annotations>
      <derivedFrom relationship="restriction">
        <targetDatatype name="II"/>
      </derivedFrom>
    </property>
    <property name="extension" maximumLength="20">
      <annotations>
        <documentation>
          <usageNotes>
            <text>Extension is considered case sensitive for comparison purposes. Non-case-sensitive identifiers should be exchanged in upper-case.</text>
          </usageNotes>
        </documentation>
      </annotations>
      <derivedFrom relationship="restriction">
        <targetDatatype name="II"/>
      </derivedFrom>
    </property>
    <property name="assigningAuthorityName" conformance="NP" fixedValue="NullFlavor.NI">
      <annotations>
        <documentation>
          <usageNotes>
            <text>AssigningAuthorityName is not needed for processing purposes. It is also not needed when performing identifier matches, which is the sole purpose of the II data type.</text>
          </usageNotes>
        </documentation>
      </annotations>
      <derivedFrom relationship="restriction">
        <targetDatatype name="II"/>
      </derivedFrom>
    </property>
  </datatype>
  <datatype name="II.BUS" title="Instance Identifier (Business)" datatypeKind="Flavor" visibility="public">
    <derivedFrom relationship="restriction">
      <targetDatatype name="II"/>
    </derivedFrom>
    <annotations>
      <documentation>
        <definition>
          <text>Communicates a "business" identifier. This is an identifier which remains consistent as an object evolves. i.e. The identifier does not change when the object undergoes state transitions. Examples include prescription numbers, encounter numbers, lab result numbers, etc.</text>
        </definition>
      </documentation>
      <appInfo>
        <formalConstraint>
          <text>If extension is present, root must be an OID</text>
          <alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (II.BUS x) {
  x.extension.notNull.implies(x.root.type.implies(OID));
};          </alternateFormalExpression>
        </formalConstraint>
        <staticExample itsName="XML">
          <data>
            <id root="2.16.840.1.113883.19.335.72.7" extension="R092377" scope="OBJ"/>
          </data>
          <businessName name="Rx number R092377 issued by pharmacy with OID 2.16.840.1.113883.19.335.72"/>
        </staticExample>
      </appInfo>
    </annotations>
    <property name="displayable" conformance="NP" fixedValue="true">
      <derivedFrom relationship="restriction">
        <targetDatatype name="II"/>
      </derivedFrom>
    </property>
    <property name="extension" conformance="R">
      <annotations>
        <documentation>
          <definition>
            <text>The 'human-readable' portion of the identifier </text>
          </definition>
        </documentation>
      </annotations>
      <derivedFrom relationship="restriction">
        <targetDatatype name="II"/>
      </derivedFrom>
    </property>
    <property name="scope" isMandatory="true" conformance="R" minimumMultiplicity="1">
      <!-- Was known as 'use' -->
      <derivedFrom relationship="restriction">
        <targetDatatype name="II"/>
      </derivedFrom>
      <vocabularySpecification>
        <code code="OBJ" codeSystem="2.16.840.1.113883.5.1116"/>
      </vocabularySpecification>
    </property>
  </datatype>
  <datatype name="II.BUSVER" title="Instance Identifier (Business with Version)" datatypeKind="Flavor" visibility="public">
    <derivedFrom relationship="restriction">
      <targetDatatype name="II.BUS"/>
    </derivedFrom>
    <!-- II.BUSVER can't be represented because there's no "version" attribute -->
  </datatype>
  <datatype name="II.PUBLIC" title="Instance Identifier (Public)" datatypeKind="Flavor" visibility="public">
    <derivedFrom relationship="restriction">
      <targetDatatype name="II"/>
    </derivedFrom>
    <annotations>
      <documentation>
        <definition>
          <text>This is used to convey common public identifiers such as provider license numbers, jurisdictional PHNs, etc.</text>
        </definition>
      </documentation>
      <appInfo>
        <staticExample itsName="XML">
          <data>
            <id root="2.16.840.1.113883.4.20" extension="123567890" displayable="true"/>
          </data>
          <businessName name="Alberta PHN (ULI) 12356-7890"/>
        </staticExample>
      </appInfo>
    </annotations>
    <property name="displayable" isMandatory="true" conformance="R" minimumMultiplicity="1" fixedValue="true">
      <derivedFrom relationship="restriction">
        <targetDatatype name="II"/>
      </derivedFrom>
    </property>
    <property name="extension" isMandatory="true" conformance="R" minimumMultiplicity="1">
      <annotations>
        <documentation>
          <definition>
            <text>The 'human-readable' portion of the identifier</text>
          </definition>
        </documentation>
      </annotations>
      <derivedFrom relationship="restriction">
        <targetDatatype name="II"/>
      </derivedFrom>
    </property>
    <property name="scope" conformance="NP" fixedValue="NullFlavor.NI">
      <!-- Was known as 'use' -->
      <derivedFrom relationship="restriction">
        <targetDatatype name="II"/>
      </derivedFrom>
    </property>
  </datatype>
  <datatype name="II.OID" title="Instance Identifier (OID)" datatypeKind="Flavor" visibility="public">
    <derivedFrom relationship="restriction">
      <targetDatatype name="II"/>
    </derivedFrom>
    <annotations>
      <documentation>
        <definition>
          <text>Used where an identifier is known to be constrained to only be an OID.  E.g. Conformance profile identifiers</text>
        </definition>
      </documentation>
      <appInfo>
        <staticExample itsName="XML">
          <data>
            <id root="2.16.840.1.113883.19.335.15.8885.21197"/>
          </data>
          <businessName name="A profile id representing a jurisdictional conformance profile"/>
        </staticExample>
      </appInfo>
    </annotations>
    <property name="displayable" conformance="NP" fixedValue="false">
      <derivedFrom relationship="restriction">
        <targetDatatype name="II"/>
      </derivedFrom>
    </property>
    <property name="extension" conformance="NP" fixedValue="NullFlavor.NA">
      <derivedFrom relationship="restriction">
        <targetDatatype name="II"/>
      </derivedFrom>
    </property>
    <property name="scope" conformance="NP" fixedValue="NullFlavor.NI">
      <!-- Was known as 'use' -->
      <derivedFrom relationship="restriction">
        <targetDatatype name="II"/>
      </derivedFrom>
    </property>
  </datatype>
  <datatype name="II.PUBLICVER" title="Instance Identifier (Public with Version)" datatypeKind="Flavor" visibility="public">
    <derivedFrom relationship="restriction">
      <targetDatatype name="II.PUBLIC"/>
    </derivedFrom>
    <!-- II.PUBLICVER can't be represented because there's no "version" attribute -->
  </datatype>
  <datatype name="II.TOKEN" title="Instance Identifier (Token)" datatypeKind="Flavor" visibility="public">
    <derivedFrom relationship="restriction">
      <targetDatatype name="II"/>
    </derivedFrom>
    <annotations>
      <documentation>
        <definition>
          <text>This is used to convey "internal" computer-generated on-the-fly identifiers, such as security tokens. These identifiers are not intended for human display.</text>
        </definition>
      </documentation>
      <appInfo>
        <staticExample itsName="XML">
          <data>
            <id root="64AC5370-D851-2D2F-2A18-78FBB73BFED9"/>
          </data>
          <businessName name="A temporary resolved-patient identifier"/>
        </staticExample>
      </appInfo>
    </annotations>
    <property name="root" conformance="R" isMandatory="true" minimumMultiplicity="1">
      <derivedFrom relationship="restriction">
        <targetDatatype name="II"/>
      </derivedFrom>
      <type name="UUID"/>
    </property>
    <property name="displayable" conformance="NP" fixedValue="false">
      <derivedFrom relationship="restriction">
        <targetDatatype name="II"/>
      </derivedFrom>
    </property>
    <property name="extension" conformance="NP" fixedValue="NullFlavor.NA">
      <derivedFrom relationship="restriction">
        <targetDatatype name="II"/>
      </derivedFrom>
    </property>
    <property name="scope" conformance="NP" fixedValue="NullFlavor.NI">
      <!-- Was known as 'use' -->
      <derivedFrom relationship="restriction">
        <targetDatatype name="II"/>
      </derivedFrom>
    </property>
  </datatype>
  <datatype name="II.BUS_AND_VER" title="Instance Identifier (Business and Version)" datatypeKind="Flavor" visibility="public" isAbstract="true">
    <derivedFrom relationship="restriction">
      <targetDatatype name="II.PUBLIC"/>
    </derivedFrom>
    <annotations>
      <documentation>
        <definition>
          <text>
            <html:p>This type is used when an attribute is intended to be used to convey two types of identifiers - a business identifier and a version identifier.</html:p>
            <html:p>This data type may be referenced in Canadian specifications. If this data type is used in a message instance, it must be declared as one of the constrained version of II.BUS_AND_VER (e.g. II.VER) for each repetition</html:p>
          </text>
        </definition>
        <usageNotes>
          <text>Each value sent over the wire for the two repetitions must correspond to each of the non-abstract data type flavor specifications defined in this document (i.e. II.BUS, II.VER).</text>
        </usageNotes>
      </documentation>
    </annotations>
    <childDatatype name="II.BUS"/>
    <childDatatype name="II.VER"/>
  </datatype>
  <datatype name="II.VER" title="Instance Identifier (Version)" datatypeKind="Flavor" visibility="public">
    <derivedFrom relationship="restriction">
      <targetDatatype name="II"/>
    </derivedFrom>
    <annotations>
      <documentation>
        <definition>
          <text>This is used when referencing specific versions of a particular record.</text>
        </definition>
      </documentation>
      <appInfo>
        <staticExample itsName="XML">
          <data>
            <id root="64AC5370-D851-2D2F-2A18-78FBB73BFED9" scope="VER"/>
          </data>
          <businessName name="The id of a particular allergy record version"/>
        </staticExample>
      </appInfo>
    </annotations>
    <property name="displayable" conformance="NP" fixedValue="false">
      <derivedFrom relationship="restriction">
        <targetDatatype name="II"/>
      </derivedFrom>
    </property>
    <property name="extension" conformance="NP" fixedValue="NullFlavor.NA">
      <derivedFrom relationship="restriction">
        <targetDatatype name="II"/>
      </derivedFrom>
    </property>
    <property name="root" isMandatory="true" conformance="R" minimumMultiplicity="1">
      <derivedFrom relationship="restriction">
        <targetDatatype name="II"/>
      </derivedFrom>
      <type name="UUID"/>
    </property>
    <property name="scope" isMandatory="true" conformance="R" minimumMultiplicity="1">
      <!-- Was known as 'use' -->
      <derivedFrom relationship="restriction">
        <targetDatatype name="II"/>
      </derivedFrom>
      <vocabularySpecification>
        <code code="VER" codeSystem="2.16.840.1.113883.5.1116"/>
      </vocabularySpecification>
    </property>
  </datatype>
  <datatype name="CS" title="Coded Simple" datatypeKind="Flavor" visibility="public">
    <derivedFrom relationship="restriction">
      <targetDatatype name="CS"/>
    </derivedFrom>
    <annotations>
      <documentation>
        <usageNotes>
          <text>This data type should only appear in specifications where the corresponding RIM attribute or Abstract Data type property also has a data type of CS. i.e. Other coded data types should never be constrained to CS.</text>
        </usageNotes>
      </documentation>
      <appInfo>
        <staticExample itsName="XML">
          <data>... moodCode="EVN" ...</data>
          <businessName name="A mood code indicating an event"/>
        </staticExample>
      </appInfo>
    </annotations>
    <property name="code" isMandatory="true" conformance="R" minimumMultiplicity="1" maximumLength="20">
      <derivedFrom relationship="restriction">
        <targetDatatype name="CS"/>
      </derivedFrom>
    </property>
  </datatype>
  <datatype name="CV" title="Coded Value" datatypeKind="Flavor" visibility="public">
    <derivedFrom relationship="restriction">
      <targetDatatype name="CV"/>
    </derivedFrom>
    <annotations>
      <documentation>
        <usageNotes>
          <text>
            <html:p>If the attribute or property is null, the codeSystem and originalTextproperties are still permitted but not <html:i>mandatory</html:i>.</html:p>
            <html:p>The rules for supporting the several properties vary depending on whether the element has a coding strength of CWE (Coded with extensibility) or CNE (Coded with no extensibility).</html:p>
            <html:p>For CWE, "code", "codeSystem" and "originalText" properties are required. A constraint exists that at least one of "code" and "originalText" must be present and non-null, and that if "code" is present, then "codeSystem is mandatory.</html:p>
            <html:p>For CNE, "code" and "codeSystem" are mandatory (meaning they must be non-null if the overall attribute or property is non-null). If the element is null with a flavor of OTH (Other), then the "originalText" property is mandatory (and no other properties may be specified).</html:p>
          </text>
        </usageNotes>
      </documentation>
      <appInfo>
        <staticExample itsName="XML">
          <data>
            <administrativeGenderCode code="F" codeSystem="2.16.840.1.113883.5.1"/>
          </data>
          <businessName name="a gender of female"/>
        </staticExample>
      </appInfo>
    </annotations>
    <property name="code" isMandatory="true" conformance="R" minimumMultiplicity="1" maximumLength="20">
      <derivedFrom relationship="restriction">
        <targetDatatype name="CV"/>
      </derivedFrom>
    </property>
    <property name="codeSystem" isMandatory="true" conformance="R" minimumMultiplicity="1" maximumLength="100">
      <annotations>
        <documentation>
          <usageNotes>
            <text>The specified OID for the code system must be registered as a code system in the HL7 international OID registry.</text>
          </usageNotes>
        </documentation>
      </annotations>
      <derivedFrom relationship="restriction">
        <targetDatatype name="CV"/>
      </derivedFrom>
    </property>
    <property name="originalText" conformance="R" maximumLength="150">
      <derivedFrom relationship="restriction">
        <targetDatatype name="CV"/>
      </derivedFrom>
      <type name="ST"/>
    </property>
    <property name="displayName" conformance="NP" fixedValue="NullFlavor.NI">
      <derivedFrom relationship="restriction">
        <targetDatatype name="CV"/>
      </derivedFrom>
    </property>
    <property name="codeSystemName" conformance="NP" fixedValue="NullFlavor.NI">
      <derivedFrom relationship="restriction">
        <targetDatatype name="CV"/>
      </derivedFrom>
    </property>
    <property name="codeSystemVersion" conformance="NP" fixedValue="NullFlavor.NI">
      <derivedFrom relationship="restriction">
        <targetDatatype name="CV"/>
      </derivedFrom>
    </property>
  </datatype>
  <datatype name="CE" title="Coded With Equivalents" datatypeKind="Flavor" visibility="public">
    <derivedFrom relationship="restriction">
      <targetDatatype name="CE"/>
    </derivedFrom>
    <annotations>
      <documentation>
        <usageNotes>
          <text>
            <html:p>If the attribute or property is null, the codeSystem and originalTextproperties are still permitted but not <html:i>mandatory</html:i>.</html:p>
            <html:p>The rules for supporting the several properties vary depending on whether the element has a coding strength of CWE (Coded with extensibility) or CNE (Coded with no extensibility).</html:p>
            <html:p>For CWE, "code", "codeSystem" and "originalText" properties are required. A constraint exists that at least one of "code" and "originalText" must be present and non-null, and that if "code" is present, then "codeSystem is mandatory.</html:p>
            <html:p>For CNE, "code" and "codeSystem" are mandatory (meaning they must be non-null if the overall attribute or property is non-null). If the element is null with a flavor of OTH (Other), then the "originalText" property is mandatory (and no other properties may be specified).</html:p>
          </text>
        </usageNotes>
      </documentation>
      <appInfo>
        <staticExample itsName="XML">
          <data>
            <value nullFlavor="OTH">
              <originalText>SARs</originalText>
              <translation code="AB99123788" codeSystem="2.16.840.1.113883.19.881.57"/>
            </value>
          </data>
          <businessName name="A diagnosis of SARs (prior to the issuing of an ICD10 code), using a local code"/>
        </staticExample>
      </appInfo>
    </annotations>
    <property name="code" isMandatory="true" conformance="R" minimumMultiplicity="1" maximumLength="20">
      <derivedFrom relationship="restriction">
        <targetDatatype name="CE"/>
      </derivedFrom>
    </property>
    <property name="codeSystem" isMandatory="true" conformance="R" minimumMultiplicity="1" maximumLength="100">
      <annotations>
        <documentation>
          <usageNotes>
            <text>The specified OID for the code system must be registered as a code system in the HL7 international OID registry.</text>
          </usageNotes>
        </documentation>
      </annotations>
      <derivedFrom relationship="restriction">
        <targetDatatype name="CE"/>
      </derivedFrom>
    </property>
    <property name="originalText" conformance="R" maximumLength="150">
      <derivedFrom relationship="restriction">
        <targetDatatype name="CE"/>
      </derivedFrom>
      <type name="ST"/>
    </property>
    <property name="displayName" conformance="NP" fixedValue="NullFlavor.NI">
      <derivedFrom relationship="restriction">
        <targetDatatype name="CE"/>
      </derivedFrom>
    </property>
    <property name="codeSystemName" conformance="NP" fixedValue="NullFlavor.NI">
      <derivedFrom relationship="restriction">
        <targetDatatype name="CE"/>
      </derivedFrom>
    </property>
    <property name="codeSystemVersion" conformance="NP" fixedValue="NullFlavor.NI">
      <derivedFrom relationship="restriction">
        <targetDatatype name="CE"/>
      </derivedFrom>
    </property>
    <property name="translation" conformance="R" maximumMultiplicity="10">
      <annotations>
        <documentation>
          <usageNotes>
            <text>Translations are intended to give the translation, not the fact that translation occurred. Therefore, it would not make sense to have a NullFlavor for this property/component. Qualifiers are permitted. There are no constraints on translations. Fundamentally either the base code or one of the translations must be from the approved value set, or the whole data type must have a null flavor of OTH or the coding strength must be CWE</text>
          </usageNotes>
        </documentation>
        <appInfo>
          <formalConstraint>
            <text>Translations are limited to one level of nesting. I.e. Tracking translations of translations will not be supported.</text>
            <alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (CD x) where x.isNonNull {
  x.translation.translation.isNull;
};</alternateFormalExpression>
          </formalConstraint>
        </appInfo>
      </annotations>
      <derivedFrom relationship="restriction">
        <targetDatatype name="CD"/>
      </derivedFrom>
      <type name="CD"/>
    </property>
  </datatype>
  <datatype name="CD" title="Coded Value" datatypeKind="Flavor" visibility="public">
    <derivedFrom relationship="restriction">
      <targetDatatype name="CD.UV"/>
    </derivedFrom>
    <annotations>
      <documentation>
        <usageNotes>
          <text>
            <html:p>If the attribute or property is null, the codeSystem and originalTextproperties are still permitted but not <html:i>mandatory</html:i>.</html:p>
            <html:p>The rules for supporting the several properties vary depending on whether the element has a coding strength of CWE (Coded with extensibility) or CNE (Coded with no extensibility).</html:p>
            <html:p>For CWE, "code", "codeSystem" and "originalText" properties are required. A constraint exists that at least one of "code" and "originalText" must be present and non-null, and that if "code" is present, then "codeSystem is mandatory.</html:p>
            <html:p>For CNE, "code" and "codeSystem" are mandatory (meaning they must be non-null if the overall attribute or property is non-null). If the element is null with a flavor of OTH (Other), then the "originalText" property is mandatory (and no other properties may be specified).</html:p>
          </text>
        </usageNotes>
      </documentation>
      <appInfo>
        <staticExample itsName="XML">
          <data>
            <value code="402320002" codeSystem="2.16.840.1.113883.6.96">
              <originalText>Acute, moderate facial psoriasis</originalText>
              <qualifier>
                <name code="246100006" codeSystem="2.16.840.1.113883.6.96"/>
                <value code="385315009" codeSystem="2.16.840.1.113883.6.96"/>
              </qualifier>
              <qualifier>
                <name code="246112005" codeSystem="2.16.840.1.113883.6.96"/>
                <value code="371924009" codeSystem="2.16.840.1.113883.6.96"/>
              </qualifier>
            </value>
          </data>
          <businessName name="a diagnosis of moderate to severe psoriasis of the face with sudden onset"/>
        </staticExample>
      </appInfo>
    </annotations>
    <property name="code" isMandatory="true" conformance="R" minimumMultiplicity="1" maximumLength="20">
      <derivedFrom relationship="restriction">
        <targetDatatype name="CD.UV"/>
      </derivedFrom>
    </property>
    <property name="codeSystem" isMandatory="true" conformance="R" minimumMultiplicity="1" maximumLength="100">
      <annotations>
        <documentation>
          <usageNotes>
            <text>The specified OID for the code system must be registered as a code system in the HL7 international OID registry.</text>
          </usageNotes>
        </documentation>
      </annotations>
      <derivedFrom relationship="restriction">
        <targetDatatype name="CD.UV"/>
      </derivedFrom>
    </property>
    <property name="originalText" conformance="R" maximumLength="150">
      <derivedFrom relationship="restriction">
        <targetDatatype name="CD.UV"/>
      </derivedFrom>
      <type name="ST"/>
    </property>
    <property name="displayName" conformance="NP" fixedValue="NullFlavor.NI">
      <derivedFrom relationship="restriction">
        <targetDatatype name="CD.UV"/>
      </derivedFrom>
    </property>
    <property name="codeSystemName" conformance="NP" fixedValue="NullFlavor.NI">
      <derivedFrom relationship="restriction">
        <targetDatatype name="CD.UV"/>
      </derivedFrom>
    </property>
    <property name="codeSystemVersion" conformance="NP" fixedValue="NullFlavor.NI">
      <derivedFrom relationship="restriction">
        <targetDatatype name="CD.UV"/>
      </derivedFrom>
    </property>
    <property name="qualifier" conformance="R" maximumMultiplicity="5" isMandatory="false">
      <annotations>
        <appInfo>
          <formalConstraint>
            <text>A "qualifier" cannot have a null flavor</text>
            <alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (CD x) where x.isNull {
x.nullFlavor.equals("NI");
};</alternateFormalExpression>
          </formalConstraint>
        </appInfo>
      </annotations>
      <derivedFrom relationship="restriction">
        <targetDatatype name="CD.UV"/>
      </derivedFrom>
    </property>
    <property name="translation" conformance="R" maximumMultiplicity="10">
      <annotations>
        <documentation>
          <usageNotes>
            <text>Translations are intended to give the translation, not the fact that translation occurred. Therefore, it would not make sense to have a NullFlavor for this property/component. Qualifiers are permitted. There are no constraints on translations. Fundamentally either the base code or one of the translations must be from the approved value set, or the whole data type must have a null flavor of OTH or the coding strength must be CWE</text>
          </usageNotes>
        </documentation>
        <appInfo>
          <formalConstraint>
            <text>Translations are limited to one level of nesting. I.e. Tracking translations of translations will not be supported.</text>
            <alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (CD x) where x.isNonNull {
  x.translation.translation.isNull;
};</alternateFormalExpression>
          </formalConstraint>
        </appInfo>
      </annotations>
      <derivedFrom relationship="restriction">
        <targetDatatype name="CD.UV"/>
      </derivedFrom>
      <type name="CD"/>
    </property>
  </datatype>
  <datatype name="CD.LAB" title="Coded Value (Lab)" datatypeKind="Flavor" visibility="public">
    <derivedFrom relationship="restriction">
      <targetDatatype name="CD.UV"/>
    </derivedFrom>
    <annotations>
      <documentation>
        <usageNotes>
          <text>
            <html:p>If the attribute or property is null, the codeSystem and originalTextproperties are still permitted but not <html:i>mandatory</html:i>.</html:p>
            <html:p>The rules for supporting the several properties vary depending on whether the element has a coding strength of CWE (Coded with extensibility) or CNE (Coded with no extensibility).</html:p>
            <html:p>For CWE, "code", "codeSystem" and "originalText" properties are required. A constraint exists that at least one of "code" and "originalText" must be present and non-null, and that if "code" is present, then "codeSystem is mandatory.</html:p>
            <html:p>For CNE, "code" and "codeSystem" are mandatory (meaning they must be non-null if the overall attribute or property is non-null). If the element is null with a flavor of OTH (Other), then the "originalText" property is mandatory (and no other properties may be specified).</html:p>
          </text>
        </usageNotes>
      </documentation>
      <appInfo>
        <staticExample itsName="XML">
          <data>
            <value code="402320002" codeSystem="2.16.840.1.113883.6.96">
              <originalText>Acute, moderate facial psoriasis</originalText>
              <qualifier>
                <name code="246100006" codeSystem="2.16.840.1.113883.6.96"/>
                <value code="385315009" codeSystem="2.16.840.1.113883.6.96"/>
              </qualifier>
              <qualifier>
                <name code="246112005" codeSystem="2.16.840.1.113883.6.96"/>
                <value code="371924009" codeSystem="2.16.840.1.113883.6.96"/>
              </qualifier>
            </value>
          </data>
          <businessName name="a diagnosis of moderate to severe psoriasis of the face with sudden onset"/>
        </staticExample>
      </appInfo>
    </annotations>
    <property name="code" isMandatory="true" conformance="R" minimumMultiplicity="1" maximumLength="20">
      <derivedFrom relationship="restriction">
        <targetDatatype name="CD.UV"/>
      </derivedFrom>
    </property>
    <property name="codeSystem" isMandatory="true" conformance="R" minimumMultiplicity="1" maximumLength="100">
      <annotations>
        <documentation>
          <usageNotes>
            <text>The specified OID for the code system must be registered as a code system in the HL7 international OID registry.</text>
          </usageNotes>
        </documentation>
      </annotations>
      <derivedFrom relationship="restriction">
        <targetDatatype name="CD.UV"/>
      </derivedFrom>
    </property>
    <property name="originalText" conformance="R" maximumLength="150">
      <derivedFrom relationship="restriction">
        <targetDatatype name="CD.UV"/>
      </derivedFrom>
      <type name="ST"/>
    </property>
    <property name="displayName" conformance="NP" fixedValue="NullFlavor.NI">
      <derivedFrom relationship="restriction">
        <targetDatatype name="CD.UV"/>
      </derivedFrom>
    </property>
    <property name="codeSystemName" conformance="NP" fixedValue="NullFlavor.NI">
      <derivedFrom relationship="restriction">
        <targetDatatype name="CD.UV"/>
      </derivedFrom>
    </property>
    <property name="codeSystemVersion" conformance="NP" fixedValue="NullFlavor.NI">
      <derivedFrom relationship="restriction">
        <targetDatatype name="CD.UV"/>
      </derivedFrom>
    </property>
    <property name="qualifier" conformance="R" maximumMultiplicity="5" isMandatory="false">
      <annotations>
        <appInfo>
          <formalConstraint>
            <text>A "qualifier" cannot have a null flavor</text>
            <alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (CD x) where x.isNull {
x.nullFlavor.equals("NI");
};</alternateFormalExpression>
          </formalConstraint>
        </appInfo>
      </annotations>
      <derivedFrom relationship="restriction">
        <targetDatatype name="CD.UV"/>
      </derivedFrom>
    </property>
    <property name="translation" conformance="R" maximumMultiplicity="10">
      <annotations>
        <documentation>
          <usageNotes>
            <text>Translations are intended to give the translation, not the fact that translation occurred. Therefore, it would not make sense to have a NullFlavor for this property/component. Qualifiers are permitted. There are no constraints on translations. Fundamentally either the base code or one of the translations must be from the approved value set, or the whole data type must have a null flavor of OTH or the coding strength must be CWE</text>
          </usageNotes>
        </documentation>
        <appInfo>
          <formalConstraint>
            <text>Translations are limited to one level of nesting. I.e. Tracking translations of translations will not be supported.</text>
            <alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (CD x) where x.isNonNull {
  x.translation.translation.isNull;
};</alternateFormalExpression>
          </formalConstraint>
        </appInfo>
      </annotations>
      <derivedFrom relationship="restriction">
        <targetDatatype name="CD.UV"/>
      </derivedFrom>
      <type name="CD.LAB"/>
    </property>
  </datatype>
  <datatype name="CR" title="Concept Role" datatypeKind="Flavor" visibility="protected">
    <derivedFrom relationship="restriction">
      <targetDatatype name="CR"/>
    </derivedFrom>
    <annotations>
      <appInfo>
        <formalConstraint>
          <text>The level of nesting for qualifiers is limited to 3. I.e. A code may be qualified by a code which itself is qualified, but no deeper nesting is permitted.</text>
          <alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (CR x) where x.isNonNull {
x.value.qualifier.value.qualifier.value.qualifier.isNull;
};</alternateFormalExpression>
        </formalConstraint>
        <formalConstraint>
          <text>Translations for "qualifier" is not permitted.</text>
          <alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (CR x) where x.isNonNull {
x.value.translation.isNull;
};</alternateFormalExpression>
        </formalConstraint>
      </appInfo>
    </annotations>
    <property name="name" conformance="R" isMandatory="true" minimumMultiplicity="1">
      <derivedFrom relationship="restriction">
        <targetDatatype name="CR"/>
      </derivedFrom>
    </property>
    <property name="value" conformance="R" isMandatory="true" minimumMultiplicity="1">
      <annotations>
        <documentation>
          <usageNotes>
            <text>Qualifier value takes on the coding strength of the base code. Thus if the base code is CWE, qualifier values can also be CWE. (or CNE).</text>
          </usageNotes>
        </documentation>
      </annotations>
      <derivedFrom relationship="restriction">
        <targetDatatype name="CR"/>
      </derivedFrom>
    </property>
    <property name="inverted" conformance="NP" fixedValue="false">
      <derivedFrom relationship="restriction">
        <targetDatatype name="CR"/>
      </derivedFrom>
    </property>
  </datatype>
  <datatype name="ST" title="String" datatypeKind="Flavor" visibility="public">
    <derivedFrom relationship="restriction">
      <targetDatatype name="ST.UV"/>
    </derivedFrom>
    <annotations>
      <documentation>
        <usageNotes>
          <text>Maximum length of the string is determined by the message, document or other (e.g. data type) specification that includes this data type for a specified attribute or property.</text>
        </usageNotes>
      </documentation>
      <appInfo>
        <staticExample itsName="XML">
          <data>
            <name>Royal Alexandra Hospital</name>
          </data>
        </staticExample>
      </appInfo>
    </annotations>
    <property name="language" conformance="NP" fixedValue="NullFlavor.NI">
      <derivedFrom relationship="restriction">
        <targetDatatype name="ST.UV"/>
      </derivedFrom>
    </property>
  </datatype>
  <datatype name="ST.LANG" title="String with language" datatypeKind="Flavor" visibility="public">
    <derivedFrom relationship="restriction">
      <targetDatatype name="ST.UV"/>
    </derivedFrom>
    <annotations>
      <documentation>
        <definition>
          <text>A string where there is a requirement to expose the language of the string. Effectively this means that attributes intended to convey the language of text must be explicitly declared as such</text>
        </definition>
        <usageNotes>
          <text>Maximum length is determined by the referencing specification.</text>
        </usageNotes>
      </documentation>
      <appInfo>
        <staticExample itsName="XML">
          <data>
            <name>Royal Alexandra Hospital</name>
          </data>
        </staticExample>
      </appInfo>
    </annotations>
    <property name="language" conformance="R" isMandatory="true" minimumMultiplicity="1">
      <derivedFrom relationship="restriction">
        <targetDatatype name="ST.UV"/>
      </derivedFrom>
    </property>
  </datatype>
  <datatype name="ED" title="Encapsulated Data" datatypeKind="Flavor" visibility="public" isAbstract="true">
    <historyItem isSubstantiveChange="true" dateTime="2007-12-07">
      <description>Added "representation" property.</description>
    </historyItem>
    <derivedFrom relationship="restriction">
      <targetDatatype name="ED"/>
    </derivedFrom>
    <annotations>
      <documentation>
        <definition>
          <text>
            <html:p>This defines generic rules for all uses of the ED data type within Canada.</html:p>
            <html:p>This data type may be referenced in Canadian specifications. If this data type is used in a message instance, it must be declared as one of the constrained version of ED (e.g. ED.DOC) for each repetition.</html:p>
          </text>
        </definition>
        <usageConstraint>
          <text>If the content is compressed (the compression attribute is present), or if the content is a PDF document (mediaType="application/pdf"), then the content must be MIMEencoded. Otherwise, the content will be sent as directly embedded text or XML. (NOTE: This means that uncompressed HTML must be XHTML compliant.) Content is restricted to a maximum of 1 megabyte after compression and MIME encoding.</text>
          <!-- Grahame, I don't think any of this can be expressed formally, can it? -->
        </usageConstraint>
        <requirements>
          <text>Ballot comment #21</text>
        </requirements>
      </documentation>
    </annotations>
    <property name="integrityCheck" conformance="NP" fixedValue="NullFlavor.NI">
      <derivedFrom relationship="restriction">
        <targetDatatype name="ED"/>
      </derivedFrom>
    </property>
    <property name="thumbnail" conformance="NP" fixedValue="NullFlavor.NI">
      <derivedFrom relationship="restriction">
        <targetDatatype name="ED"/>
      </derivedFrom>
    </property>
    <property name="charset" conformance="R" minimumMultiplicity="1" isMandatory="true">
      <annotations>
        <documentation>
          <usageNotes>
            <text>The character set is determined by the XML character set declared for the entire document.</text>
          </usageNotes>
        </documentation>
      </annotations>
      <derivedFrom relationship="restriction">
        <targetDatatype name="ED"/>
      </derivedFrom>
    </property>
    <property name="compression">
      <annotations>
        <documentation>
          <definition>
            <text>Indicates the compression algorithm used.</text>
          </definition>
        </documentation>
      </annotations>
      <derivedFrom relationship="restriction">
        <targetDatatype name="ED"/>
      </derivedFrom>
      <vocabularySpecification>
        <valueSet name="CanadianCompressionAlgorithm" codingStrength="CNE"/>
      </vocabularySpecification>
    </property>
    <property name="mediaType" conformance="R" isMandatory="true" minimumMultiplicity="1">
      <annotations>
        <documentation>
          <definition>
            <text>indicates the type of data being conveyed</text>
          </definition>
        </documentation>
      </annotations>
      <derivedFrom relationship="restriction">
        <targetDatatype name="ED"/>
      </derivedFrom>
    </property>
    <property name="language">
      <annotations>
        <documentation>
          <definition>
            <text>indicates the principle language of the encapsulated document. Example values include "en-CA" for English and "fr-CA" for French.</text>
          </definition>
          <usageNotes>
            <text>If not specified, the assumption is that the document uses the language associated with the overall message.</text>
          </usageNotes>
        </documentation>
      </annotations>
      <derivedFrom relationship="restriction">
        <targetDatatype name="ED"/>
      </derivedFrom>
    </property>
    <property name="representation">
      <annotations>
        <documentation>
          <definition>
            <text>Needs to be asserted for each type of media that is included in the ED data types (e.g. JPG must be B64, etc.). Note that the "representation" property does not appear in the abstract data types specification, but does exist in the XML ITS specification.</text>
          </definition>
        </documentation>
      </annotations>
      <derivedFrom relationship="extension">
        <targetDatatype name="ED"/>
      </derivedFrom>
      <type name="CS"/>
      <vocabularySpecification>
        <valueSet name="EncapsulatedDataRepresentation" codingStrength="CNE"/>
      </vocabularySpecification>
    </property>
  </datatype>
  <datatype name="ED.DOC" title="Encapsulated Data (Document)" datatypeKind="Flavor" visibility="public">
    <historyItem isSubstantiveChange="true" dateTime="2007-12-07">
      <description>Added "reference" property.</description>
    </historyItem>
    <derivedFrom relationship="restriction">
      <targetDatatype name="ED"/>
    </derivedFrom>
    <annotations>
      <documentation>
        <definition>
          <text>This allows for the encapsulation of a document within an attribute.</text>
        </definition>
        <requirements>
          <text>Ballot comment #30</text>
        </requirements>
      </documentation>
      <appInfo>
        <formalConstraint>
          <text>Content of the document is <html:i>mandatory</html:i>
          </text>
          <alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (ED.DOC x) where x.isNonNull {
x.length.greaterThan(0);
};</alternateFormalExpression>
        </formalConstraint>
        <staticExample itsName="XML">
          <data>
            <text mediaType="text/html" language="fre" xsi:type="ED" flavorId="ED.DOC">
              <html> . . . </html>
            </text>
          </data>
          <businessName name="HTML content"/>
        </staticExample>
      </appInfo>
    </annotations>
    <property name="reference" conformance="NP" fixedValue="NullFlavor.NI">
      <derivedFrom relationship="restriction">
        <targetDatatype name="ED"/>
      </derivedFrom>
      <type name="TEL.URI"/>
    </property>
    <property name="compression" conformance="R">
      <derivedFrom relationship="restriction">
        <targetDatatype name="ED"/>
      </derivedFrom>
    </property>
    <property name="language" conformance="R">
      <derivedFrom relationship="restriction">
        <targetDatatype name="ED"/>
      </derivedFrom>
    </property>
    <property name="mediaType">
      <annotations>
        <documentation>
          <usageConstraint>
            <text>If the mediaType is text/xml, the content must be a compliant HL7 CDA document.</text>
          </usageConstraint>
        </documentation>
      </annotations>
      <derivedFrom relationship="restriction">
        <targetDatatype name="ED"/>
      </derivedFrom>
      <vocabularySpecification>
        <valueSet name="DocumentMediaType" codingStrength="CNE"/>
      </vocabularySpecification>
    </property>
  </datatype>
  <datatype name="ED.DOCORREF" title="Encapsulated Data (Document or Reference)" datatypeKind="Flavor" visibility="public">
    <derivedFrom relationship="restriction">
      <targetDatatype name="ED"/>
    </derivedFrom>
    <annotations>
      <documentation>
        <definition>
          <text>This allows for the encapsulation of a document or reference to a document within the HL7 instance.</text>
        </definition>
      </documentation>
    </annotations>
    <childDatatype name="ED.DOC"/>
    <childDatatype name="ED.DOCREF"/>
  </datatype>
  <datatype name="ED.IMAGE" title="Encapsulated Data (Image)" datatypeKind="Flavor" visibility="public">
    <derivedFrom relationship="restriction">
      <targetDatatype name="ED"/>
    </derivedFrom>
    <annotations>
      <documentation>
        <definition>
          <text>This allows for the encapsulation of a picture or other graphic within an attribute.</text>
        </definition>
      </documentation>
      <appInfo>
        <formalConstraint>
          <text>Content of the document is <html:i>mandatory</html:i>
          </text>
          <alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
            <!-- Grahame - how do you say this? -->
          </alternateFormalExpression>
        </formalConstraint>
        <staticExample itsName="XML">
          <data>
            <value xsi:type="ED" flavorId="ED.IMAGE" mediaType="img/jpeg">/9j/4AAQSkZJRgABAQEAYABgAAD/2wBDAAgGBgcGBQgHBwcJCQgKDBQNDAsLDBkSEw8UHRofHh0aHBwgJC4nICIsIxwcKDcpLDAxNDQ0Hyc5PTgyPC4zNDL/2wBDAQkJCQwLDBgNDRgyIRwhMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjL/wAARCAALABMDASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwDr9d1XSfF2seH9R0vWvKhtpUDRy20sZnzd6dIow0WdpDREEbcl05278Fnb2t14Q8Fadf29jLqcf2GXS7m2gnud1vDJbNJLu8kNBuXAIbA+Zct1x5xb31xY33w+sraTy7WbULSF4go27Gh0qdgB/DmX5zjGWLE/eOafhTxfrkz/AA7eW7jd4dYl0mJmt4iUtdtmuxfl4O1mG4fNgkZ5oA9/g8c6LdW8VxbxazNBKgeOSPRL1ldSMggiLBBHOaK+LL69l1C8kupkgSR8ZEECQoMADhEAUdOw569aKAP/2Q==</value>
          </data>
        </staticExample>
      </appInfo>
    </annotations>
    <property name="reference" conformance="NP" fixedValue="NullFlavor.NI">
      <derivedFrom relationship="restriction">
        <targetDatatype name="ED"/>
      </derivedFrom>
      <type name="TEL.URI"/>
    </property>
    <property name="compression" conformance="NP" fixedValue="NullFlavor.NI">
      <derivedFrom relationship="restriction">
        <targetDatatype name="ED"/>
      </derivedFrom>
    </property>
    <property name="language" conformance="NP" fixedValue="NullFlavor.NI">
      <derivedFrom relationship="restriction">
        <targetDatatype name="ED"/>
      </derivedFrom>
    </property>
    <property name="mediaType">
      <derivedFrom relationship="restriction">
        <targetDatatype name="ED"/>
      </derivedFrom>
      <vocabularySpecification>
        <code code="image/jpeg" codeSystem="2.16.840.1.113883.5.79"/>
      </vocabularySpecification>
    </property>
  </datatype>
  <datatype name="ED.DOCREF" title="Encapsulated Data (Document Reference)" datatypeKind="Flavor" visibility="public">
    <historyItem isSubstantiveChange="true" dateTime="2007-12-07">
      <description>Added "reference" property.</description>
    </historyItem>
    <derivedFrom relationship="restriction">
      <targetDatatype name="ED"/>
    </derivedFrom>
    <annotations>
      <documentation>
        <definition>
          <text>This allows embedding a reference to a document that can be retrieved elsewhere</text>
        </definition>
        <requirements>
          <text>Ballot comment #30</text>
        </requirements>
      </documentation>
      <appInfo>
        <formalConstraint>
          <text>Content of the document is <html:i>not permitted</html:i>
          </text>
          <alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
            <!-- Grahame - how do you say this? -->
          </alternateFormalExpression>
        </formalConstraint>
        <staticExample itsName="XML">
          <data>
            <text mediaType="application/pdf">
              <reference flavorId="TEL.URI" value="ftp://monographs.somewhere.gov.ca/12345.pdf"/>
            </text>
          </data>
          <businessName name="A monograph reference"/>
        </staticExample>
      </appInfo>
    </annotations>
    <property name="reference" conformance="R" isMandatory="true" minimumMultiplicity="1">
      <derivedFrom relationship="restriction">
        <targetDatatype name="ED"/>
      </derivedFrom>
      <type name="TEL.URI"/>
    </property>
    <property name="compression" conformance="R">
      <derivedFrom relationship="restriction">
        <targetDatatype name="ED"/>
      </derivedFrom>
    </property>
    <property name="language" conformance="R">
      <derivedFrom relationship="restriction">
        <targetDatatype name="ED"/>
      </derivedFrom>
    </property>
    <property name="mediaType">
      <annotations>
        <documentation>
          <usageConstraint>
            <text>If the mediaType is text/xml, the content must be a compliant HL7 CDA document.</text>
          </usageConstraint>
        </documentation>
      </annotations>
      <derivedFrom relationship="restriction">
        <targetDatatype name="ED"/>
      </derivedFrom>
      <vocabularySpecification>
        <valueSet name="DocumentMediaType" codingStrength="CNE"/>
      </vocabularySpecification>
    </property>
  </datatype>
  <datatype name="ED.SIGNATURE" title="Encapsulated Data (Signature)" datatypeKind="Flavor" visibility="public">
    <derivedFrom relationship="restriction">
      <targetDatatype name="ED"/>
    </derivedFrom>
    <annotations>
      <documentation>
        <definition>
          <text>This allows incorporation of a digital signature as part of a message.</text>
        </definition>
        <usageConstraint>
          <text>Content must conform to the XML digital signature specification</text>
        </usageConstraint>
        <usageNotes>
          <text>
            <html:b>Additional pan-Canadian standards effort is anticipated to provide guidance on how digital signatures should be implemented within Canadian v3 instances. </html:b>
          </text>
        </usageNotes>
      </documentation>
      <appInfo>
        <formalConstraint>
          <text>Content of the document is <html:i>mandatory</html:i>
          </text>
          <alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
            <!-- Grahame - how do you say this? -->
          </alternateFormalExpression>
        </formalConstraint>
        <staticExample itsName="XML">
          <data>
            <text xsi:type="ED" flavorId="ED.SIGNATURE" mediaType="text/xml">
              <Signature xmlns="http://www.w3.org/2000/09/xmldsig#"> . . . </Signature>
            </text>
          </data>
        </staticExample>
      </appInfo>
    </annotations>
    <property name="reference" conformance="NP" fixedValue="NullFlavor.NI">
      <derivedFrom relationship="restriction">
        <targetDatatype name="ED"/>
      </derivedFrom>
      <type name="TEL.URI"/>
    </property>
    <property name="compression" conformance="NP" fixedValue="NullFlavor.NI">
      <derivedFrom relationship="restriction">
        <targetDatatype name="ED"/>
      </derivedFrom>
    </property>
    <property name="language" conformance="NP" fixedValue="NullFlavor.NI">
      <derivedFrom relationship="restriction">
        <targetDatatype name="ED"/>
      </derivedFrom>
    </property>
    <property name="mediaType">
      <derivedFrom relationship="restriction">
        <targetDatatype name="ED"/>
      </derivedFrom>
      <vocabularySpecification>
        <code code="text/xml" codeSystem="2.16.840.1.113883.5.79"/>
      </vocabularySpecification>
    </property>
  </datatype>
  <datatype name="INT.POS" title="Positive Integer" datatypeKind="Flavor" visibility="public">
    <derivedFrom relationship="restriction">
      <targetDatatype name="INT"/>
    </derivedFrom>
    <annotations>
      <documentation>
        <definition>
          <text>This is used to convey an integer number that is greater than or equal to "1".</text>
        </definition>
      </documentation>
      <appInfo>
        <formalConstraint>
          <text>Maximum length is restricted to 10 digits</text>
          <alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (INT.POS x) where x.isNonNull {
x.literal.length.lessOrEqual(10);
};</alternateFormalExpression>
        </formalConstraint>
        <formalConstraint>
          <text>Value must be >= 1</text>
          <alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (INT.POS x) where x.isNonNull {
x.greaterOrEqual(1);
};</alternateFormalExpression>
        </formalConstraint>
        <staticExample itsName="UML">
          <data>
            <sequenceNumber xsi:type="INT" flavorId="INT.POS" value="27"/>
          </data>
        </staticExample>
      </appInfo>
    </annotations>
  </datatype>
  <datatype name="INT.NONNEG" title="Non-Negative Integer" datatypeKind="Flavor" visibility="public">
    <derivedFrom relationship="restriction">
      <targetDatatype name="INT"/>
    </derivedFrom>
    <annotations>
      <documentation>
        <definition>
          <text>This is used to convey an integer number that is greater than or equal to "0".</text>
        </definition>
      </documentation>
      <appInfo>
        <formalConstraint>
          <text>Maximum length is restricted to 10 digits</text>
          <alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (INT.NONNEG x) where x.isNonNull {
x.literal.length.lessOrEqual(10);
};</alternateFormalExpression>
        </formalConstraint>
        <formalConstraint>
          <text>Value must be >= 1</text>
          <alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (INT.NONNEG x) where x.isNonNull {
x.greaterOrEqual(0);
};</alternateFormalExpression>
        </formalConstraint>
        <staticExample itsName="UML">
          <data>
            <sequenceNumber xsi:type="INT" flavorId="INT.NONNEG" value="27"/>
          </data>
        </staticExample>
      </appInfo>
    </annotations>
  </datatype>
  <datatype name="REAL.COORD" title="Real Number (Coordinate)" datatypeKind="Flavor" visibility="public">
    <derivedFrom relationship="restriction">
      <targetDatatype name="REAL"/>
    </derivedFrom>
    <annotations>
      <documentation>
        <definition>
          <text>A real number intended for use in conveying geographic coordinate values</text>
        </definition>
      </documentation>
      <appInfo>
        <formalConstraint>
          <text>Maximum length is restricted to 9 characters with 4 characters before the decimal and 4 characters after the decimal</text>
          <alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (REAL.COORD x, REAL y) where x.isNonNull.and(y.equal(x.times(10000).plus(((INT)x.times(10000)).negated))) {
x.times(0.0001).lessThan(1);
y.precision.equal(0);
y.equal(0);
};</alternateFormalExpression>
        </formalConstraint>
        <staticExample itsName="UML">
          <data>
            <value xsi:type="REAL" flavorId="REAL.COORD" value="137.2895"/>
          </data>
        </staticExample>
      </appInfo>
    </annotations>
  </datatype>
  <datatype name="REAL.CONF" title="Real Number (Confidence)" datatypeKind="Flavor" visibility="public">
    <derivedFrom relationship="restriction">
      <targetDatatype name="REAL"/>
    </derivedFrom>
    <annotations>
      <documentation>
        <definition>
          <text>A real number intended for use in conveying confidence level values in registries</text>
        </definition>
      </documentation>
      <appInfo>
        <formalConstraint>
          <text>Maximum length is restricted to 9 characters with 4 characters before the decimal and 4 characters after the decimal</text>
          <alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (REAL.CONF x, REAL y) where x.isNonNull.and(y.equal(x.times(10000).plus(((INT)x.times(10000)).negated))) {
x.times(0.1).lessThan(1);
y.precision.equal(0);
y.equal(0);
};</alternateFormalExpression>
        </formalConstraint>
        <staticExample itsName="UML">
          <data>
            <value xsi:type="REAL" flavorId="REAL.CONF" value="0.2895"/>
          </data>
          <businessName name="A confidence level value from a registry of .2895"/>
        </staticExample>
      </appInfo>
    </annotations>
  </datatype>
  <datatype name="MO.CAD" title="Canadian Money" datatypeKind="Flavor" visibility="public">
    <derivedFrom relationship="restriction">
      <targetDatatype name="MO"/>
    </derivedFrom>
    <annotations>
      <documentation>
        <definition>
          <text>Used to convey monetary values in Canadian currency</text>
        </definition>
      </documentation>
      <appInfo>
        <staticExample itsName="UML">
          <data>
            <amt xsi:type="MO" flavorId="MO.CAD" value="137.15" currency="CAD"/>
          </data>
          <businessName name="137 dollars, 15 cents Canadian"/>
        </staticExample>
      </appInfo>
    </annotations>
    <property name="value" conformance="R" isMandatory="true" minimumMultiplicity="1">
      <annotations>
        <documentation>
          <definition>
            <text>The actual dollar amount</text>
          </definition>
        </documentation>
        <appInfo>
          <formalConstraint>
            <text>value is constrained to 11 digits above the decimal and 2 digits beneath the decimal (fractions of a cent are not supported)</text>
            <alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (MO.CAD x, REAL y) where x.isNonNull.and(y.equal(x.value.times(100).plus(((INT)x.value.times(100)).negated))) {
x.value.times(.0000000001).lessThan(1);
y.precision.equal(0);
y.equal(0);
};</alternateFormalExpression>
          </formalConstraint>
        </appInfo>
      </annotations>
      <derivedFrom relationship="restriction">
        <targetDatatype name="MO"/>
      </derivedFrom>
    </property>
    <property name="currency" conformance="R" isMandatory="true" minimumMultiplicity="1">
      <derivedFrom relationship="restriction">
        <targetDatatype name="MO"/>
      </derivedFrom>
      <vocabularySpecification>
        <code code="CAD" codeSystem="2.16.840.1.113883.5.1058"/>
      </vocabularySpecification>
    </property>
  </datatype>
  <datatype name="PQ.BASIC" title="Basic Physical Quantity" datatypeKind="Flavor" visibility="public">
    <derivedFrom relationship="restriction">
      <targetDatatype name="PQ"/>
    </derivedFrom>
    <annotations>
      <documentation>
        <definition>
          <text>Used to communicate measurements using common measurement units encountered in healthcare and corresponding value</text>
        </definition>
      </documentation>
      <appInfo>
        <staticExample itsName="XML">
          <data>
            <value xsi:type="PQ" flavorId="PQ.BASIC" value="22.35" unit="mmol/l"/>
          </data>
          <businessName name="22.35 millmoles per litre"/>
        </staticExample>
      </appInfo>
    </annotations>
    <property name="translation" conformance="NP" fixedValue="NullFlavor.NI">
      <annotations>
        <documentation>
          <usageNotes>
            <text>Non-UCUM units will not be supported</text>
          </usageNotes>
        </documentation>
      </annotations>
      <derivedFrom relationship="restriction">
        <targetDatatype name="PQ"/>
      </derivedFrom>
    </property>
    <property name="value" conformance="R" isMandatory="true" minimumMultiplicity="1">
      <annotations>
        <documentation>
          <definition>
            <text>The actual amount</text>
          </definition>
        </documentation>
        <appInfo>
          <formalConstraint>
            <text>The is constrained to 11 digits above the decimal and 2 digits beneath the decimal (99999999999.99)</text>
            <alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (PQ.BASIC x, REAL y) where x.isNonNull.and(y.equal(x.value.times(100).plus(((INT)x.value.times(100)).negated))) {
x.value.times(.0000000001).lessThan(1);
y.precision.equal(0);
y.equal(0);
};</alternateFormalExpression>
          </formalConstraint>
        </appInfo>
      </annotations>
      <derivedFrom relationship="restriction">
        <targetDatatype name="PQ"/>
      </derivedFrom>
    </property>
    <property name="unit" conformance="R">
      <annotations>
        <documentation>
          <usageNotes>
            <text>The unit property must be specified unless the units of measurement are "each".  For example, "packages", "packs", "capsules", "tablets", etc. are not sent using this property.  These concepts should be explicit in the code identifying the type of item being measured.  For example, if the drug name is "100mg Acetaminophen tablets", the quantity would be "1" (or "2" or whatever) with no units specified.  The unit would be inferred from the drug name as "tablets".</text>
          </usageNotes>
        </documentation>
      </annotations>
      <derivedFrom relationship="restriction">
        <targetDatatype name="PQ"/>
      </derivedFrom>
      <vocabularySpecification>
        <valueSet name="CanadianBasicPQUnits" codingStrength="CNE"/>
      </vocabularySpecification>
    </property>
  </datatype>
  <datatype name="PQ.DRUG" title="Drug Physical Quantity" datatypeKind="Flavor" visibility="public">
    <historyItem dateTime="2007-12-07">
      <description>Added units for foot, inch, yard, centimetre, millimetre, metre.</description>
    </historyItem>
    <derivedFrom relationship="restriction">
      <targetDatatype name="PQ"/>
    </derivedFrom>
    <annotations>
      <documentation>
        <definition>
          <text>Used to convey quantities of drug products.</text>
        </definition>
        <requirements>
          <text>Ballot comment #25</text>
        </requirements>
      </documentation>
      <appInfo>
        <staticExample itsName="XML">
          <data>
            <doseQuantity xsi:type="PQ" flavorId="PQ.DRUG" value="10"/>
          </data>
          <businessName name="10 tablets"/>
        </staticExample>
      </appInfo>
    </annotations>
    <property name="translation" conformance="NP" fixedValue="NullFlavor.NI">
      <annotations>
        <documentation>
          <usageNotes>
            <text>Non-UCUM units will not be supported</text>
          </usageNotes>
        </documentation>
      </annotations>
      <derivedFrom relationship="restriction">
        <targetDatatype name="PQ"/>
      </derivedFrom>
    </property>
    <property name="value" conformance="R" isMandatory="true" minimumMultiplicity="1">
      <annotations>
        <documentation>
          <definition>
            <text>The actual amount</text>
          </definition>
        </documentation>
        <appInfo>
          <formalConstraint>
            <text>The is constrained to 11 digits above the decimal and 2 digits beneath the decimal (99999999999.99)</text>
            <alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (PQ.DRUG x, REAL y) where x.isNonNull.and(y.equal(x.value.times(100).plus(((INT)x.value.times(100)).negated))) {
x.value.times(.0000000001).lessThan(1);
y.precision.equal(0);
y.equal(0);
};</alternateFormalExpression>
          </formalConstraint>
        </appInfo>
      </annotations>
      <derivedFrom relationship="restriction">
        <targetDatatype name="PQ"/>
      </derivedFrom>
    </property>
    <property name="unit" conformance="R">
      <annotations>
        <documentation>
          <usageNotes>
            <text>The unit property must be specified unless the units of measurement are "each".  For example, "packages", "packs", "capsules", "tablets", etc. are not sent using this property.  These concepts should be explicit in the code identifying the type of item being measured.  For example, if the drug name is "100mg Acetaminophen tablets", the quantity would be "1" (or "2" or whatever) with no units specified.  The unit would be inferred from the drug name as "tablets".</text>
          </usageNotes>
        </documentation>
      </annotations>
      <derivedFrom relationship="restriction">
        <targetDatatype name="PQ"/>
      </derivedFrom>
      <vocabularySpecification>
        <valueSet name="CanadianDrugPQUnits" codingStrength="CNE"/>
      </vocabularySpecification>
    </property>
  </datatype>
  <datatype name="PQ.TIME" title="Time Quantity" datatypeKind="Flavor" visibility="public">
    <derivedFrom relationship="restriction">
      <targetDatatype name="PQ"/>
    </derivedFrom>
    <annotations>
      <documentation>
        <definition>
          <text>Used to convey quantities of drug products.</text>
        </definition>
      </documentation>
      <appInfo>
        <staticExample itsName="XML">
          <data>
            <width xsi:type="PQ" flavorId="PQ.TIME" value="14" unit="d"/>
          </data>
          <businessName name="14 days"/>
        </staticExample>
      </appInfo>
    </annotations>
    <property name="translation" conformance="NP" fixedValue="NullFlavor.NI">
      <annotations>
        <documentation>
          <usageNotes>
            <text>Non-UCUM units will not be supported</text>
          </usageNotes>
        </documentation>
      </annotations>
      <derivedFrom relationship="restriction">
        <targetDatatype name="PQ"/>
      </derivedFrom>
    </property>
    <property name="value" conformance="R" isMandatory="true" minimumMultiplicity="1">
      <annotations>
        <documentation>
          <definition>
            <text>The actual amount</text>
          </definition>
        </documentation>
        <appInfo>
          <formalConstraint>
            <text>The is constrained to 11 digits above the decimal and 2 digits beneath the decimal (99999999999.99)</text>
            <alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (PQ.TIME x, REAL y) where x.isNonNull.and(y.equal(x.value.times(100).plus(((INT)x.value.times(100)).negated))) {
x.value.times(.0000000001).lessThan(1);
y.precision.equal(0);
y.equal(0);
};</alternateFormalExpression>
          </formalConstraint>
        </appInfo>
      </annotations>
      <derivedFrom relationship="restriction">
        <targetDatatype name="PQ"/>
      </derivedFrom>
    </property>
    <property name="unit" conformance="R">
      <annotations>
        <documentation>
          <usageNotes>
            <text>The unit property must be specified unless the units of measurement are "each".  For example, "packages", "packs", "capsules", "tablets", etc. are not sent using this property.  These concepts should be explicit in the code identifying the type of item being measured.  For example, if the drug name is "100mg Acetaminophen tablets", the quantity would be "1" (or "2" or whatever) with no units specified.  The unit would be inferred from the drug name as "tablets".</text>
          </usageNotes>
        </documentation>
      </annotations>
      <derivedFrom relationship="restriction">
        <targetDatatype name="PQ"/>
      </derivedFrom>
      <vocabularySpecification>
        <valueSet name="CanadianTimePQUnits" codingStrength="CNE"/>
      </vocabularySpecification>
    </property>
  </datatype>
  <datatype name="PQ.HEIGHTWEIGHT" title="Height or Weight Quantity" datatypeKind="Flavor" visibility="public">
    <derivedFrom relationship="restriction">
      <targetDatatype name="PQ"/>
    </derivedFrom>
    <annotations>
      <documentation>
        <definition>
          <text>
            <html:p>Used to express measurements of human height and weight</html:p>
            <html:p>The data type units are constrained to the specific use-case of human height and weight resulting in a fairly narrow number of options to be supported. Future use-cases resulting in the need to communicate other types of units of measure may require the creation of a new data type flavor. The purpose of creating multiple flavors is to make it clear what units must be supported for a given attribute and to ensure that systems are not obligated to use units of measure that are inappropriate.</html:p>
          </text>
        </definition>
      </documentation>
      <appInfo>
        <staticExample itsName="XML">
          <data>
            <value xsi:type="PQ" flavorId="PQ.HEIGHTWEIGHT" value="30" unit="kg"/>
          </data>
          <businessName name="30 kilograms"/>
        </staticExample>
      </appInfo>
    </annotations>
    <property name="translation" conformance="NP" fixedValue="NullFlavor.NI">
      <annotations>
        <documentation>
          <usageNotes>
            <text>Non-UCUM units will not be supported</text>
          </usageNotes>
        </documentation>
      </annotations>
      <derivedFrom relationship="restriction">
        <targetDatatype name="PQ"/>
      </derivedFrom>
    </property>
    <property name="value" conformance="R" isMandatory="true" minimumMultiplicity="1">
      <annotations>
        <documentation>
          <definition>
            <text>The actual amount</text>
          </definition>
        </documentation>
        <appInfo>
          <formalConstraint>
            <text>The is constrained to 11 digits above the decimal and 2 digits beneath the decimal (99999999999.99)</text>
            <alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (PQ.HEIGHTWEIGHT x, REAL y) where x.isNonNull.and(y.equal(x.value.times(100).plus(((INT)x.value.times(100)).negated))) {
x.value.times(.0000000001).lessThan(1);
y.precision.equal(0);
y.equal(0);
};</alternateFormalExpression>
          </formalConstraint>
        </appInfo>
      </annotations>
      <derivedFrom relationship="restriction">
        <targetDatatype name="PQ"/>
      </derivedFrom>
    </property>
    <property name="unit" conformance="R">
      <annotations>
        <documentation>
          <usageNotes>
            <text>The unit property must be specified unless the units of measurement are "each".  For example, "packages", "packs", "capsules", "tablets", etc. are not sent using this property.  These concepts should be explicit in the code identifying the type of item being measured.  For example, if the drug name is "100mg Acetaminophen tablets", the quantity would be "1" (or "2" or whatever) with no units specified.  The unit would be inferred from the drug name as "tablets".</text>
          </usageNotes>
        </documentation>
      </annotations>
      <derivedFrom relationship="restriction">
        <targetDatatype name="PQ"/>
      </derivedFrom>
      <vocabularySpecification>
        <valueSet name="CanadianHeightWeightPQUnits" codingStrength="CNE"/>
      </vocabularySpecification>
    </property>
  </datatype>
  <datatype name="PQ.DISTANCE" title="Distance Quantity" datatypeKind="Flavor" visibility="public">
    <derivedFrom relationship="restriction">
      <targetDatatype name="PQ"/>
    </derivedFrom>
    <annotations>
      <documentation>
        <definition>
          <text>Used to express measurements of distance, specifically for geographic distances</text>
        </definition>
      </documentation>
      <appInfo>
        <staticExample itsName="XML">
          <data>
            <value xsi:type="PQ" flavorId="PQ.DISTANCE" value="22" unit="km"/>
          </data>
          <businessName name="22 kilometers"/>
        </staticExample>
      </appInfo>
    </annotations>
    <property name="translation" conformance="NP" fixedValue="NullFlavor.NI">
      <annotations>
        <documentation>
          <usageNotes>
            <text>Non-UCUM units will not be supported</text>
          </usageNotes>
        </documentation>
      </annotations>
      <derivedFrom relationship="restriction">
        <targetDatatype name="PQ"/>
      </derivedFrom>
    </property>
    <property name="value" conformance="R" isMandatory="true" minimumMultiplicity="1">
      <annotations>
        <documentation>
          <definition>
            <text>The actual amount</text>
          </definition>
        </documentation>
        <appInfo>
          <formalConstraint>
            <text>The is constrained to 11 digits above the decimal and 2 digits beneath the decimal (99999999999.99)</text>
            <alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (PQ.DISTANCE x, REAL y) where x.isNonNull.and(y.equal(x.value.times(100).plus(((INT)x.value.times(100)).negated))) {
x.value.times(.0000000001).lessThan(1);
y.precision.equal(0);
y.equal(0);
};</alternateFormalExpression>
          </formalConstraint>
        </appInfo>
      </annotations>
      <derivedFrom relationship="restriction">
        <targetDatatype name="PQ"/>
      </derivedFrom>
    </property>
    <property name="unit" conformance="R">
      <annotations>
        <documentation>
          <usageNotes>
            <text>The unit property must be specified unless the units of measurement are "each".  For example, "packages", "packs", "capsules", "tablets", etc. are not sent using this property.  These concepts should be explicit in the code identifying the type of item being measured.  For example, if the drug name is "100mg Acetaminophen tablets", the quantity would be "1" (or "2" or whatever) with no units specified.  The unit would be inferred from the drug name as "tablets".</text>
          </usageNotes>
        </documentation>
      </annotations>
      <derivedFrom relationship="restriction">
        <targetDatatype name="PQ"/>
      </derivedFrom>
      <vocabularySpecification>
        <valueSet name="CanadianDistancePQUnits" codingStrength="CNE"/>
      </vocabularySpecification>
    </property>
  </datatype>
  <datatype name="PQ.LAB" title="Laboratory Quantity" datatypeKind="Flavor" visibility="public">
    <historyItem dateTime="2007-12-07">
      <description>Units for PQ.LAB added as a result of the XProject Data Type Ballot Reconciliation process.</description>
    </historyItem>
    <derivedFrom relationship="restriction">
      <targetDatatype name="PQ"/>
    </derivedFrom>
    <annotations>
      <documentation>
        <definition>
          <text>Used to express lab results which are "measured".</text>
        </definition>
        <requirements>
          <text>Ballot comment #8</text>
        </requirements>
      </documentation>
      <appInfo>
        <staticExample itsName="XML">
          <data>
            <value xsi:type="PQ" flavorId="PQ.LAB" value="25.6" unit="ug/mg"/>
          </data>
          <businessName name="25.6 ug per mg"/>
        </staticExample>
      </appInfo>
    </annotations>
    <property name="translation" conformance="NP" fixedValue="NullFlavor.NI">
      <annotations>
        <documentation>
          <usageNotes>
            <text>Non-UCUM units will not be supported</text>
          </usageNotes>
        </documentation>
      </annotations>
      <derivedFrom relationship="restriction">
        <targetDatatype name="PQ"/>
      </derivedFrom>
    </property>
    <property name="value" conformance="R" isMandatory="true" minimumMultiplicity="1">
      <annotations>
        <documentation>
          <definition>
            <text>The actual amount</text>
          </definition>
        </documentation>
        <appInfo>
          <formalConstraint>
            <text>The is constrained to 11 digits above the decimal and 2 digits beneath the decimal (99999999999.99)</text>
            <alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (PQ.LAB x, REAL y) where x.isNonNull.and(y.equal(x.value.times(100).plus(((INT)x.value.times(100)).negated))) {
x.value.times(.0000000001).lessThan(1);
y.precision.equal(0);
y.equal(0);
};</alternateFormalExpression>
          </formalConstraint>
        </appInfo>
      </annotations>
      <derivedFrom relationship="restriction">
        <targetDatatype name="PQ"/>
      </derivedFrom>
    </property>
    <property name="unit" conformance="R">
      <annotations>
        <documentation>
          <usageNotes>
            <text>The unit property must be specified unless the units of measurement are "each".  For example, "packages", "packs", "capsules", "tablets", etc. are not sent using this property.  These concepts should be explicit in the code identifying the type of item being measured.  For example, if the drug name is "100mg Acetaminophen tablets", the quantity would be "1" (or "2" or whatever) with no units specified.  The unit would be inferred from the drug name as "tablets".</text>
          </usageNotes>
        </documentation>
      </annotations>
      <derivedFrom relationship="restriction">
        <targetDatatype name="PQ"/>
      </derivedFrom>
      <vocabularySpecification>
        <valueSet name="CanadianLabPQUnits" codingStrength="CNE"/>
      </vocabularySpecification>
    </property>
  </datatype>
  <datatype name="IVL_PQ" title="Quantity Range" datatypeKind="Flavor" visibility="public">
    <annotations>
      <documentation>
        <definition>
          <text>This is used to express an allowed range of quantities.</text>
        </definition>
      </documentation>
      <appInfo>
        <formalConstraint>
          <text>At least one of the low property or high property must be specifed with a non null value.</text>
          <alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (IVL&lt;PQ&gt; x) where x.isNonNull {
x.low.nonNull.or(x.high.nonNull);
};</alternateFormalExpression>
        </formalConstraint>
        <staticExample itsName="XML">
          <data>
            <value xsi:type="IVL_PQ">
              <low xsi:type="PQ" flavorId="PQ.BASIC" value="40" unit="CEL"/>
              <high xsi:type="PQ" nullFlavor="PINF"/>
            </value>
          </data>
          <businessName name="above 40 degrees Celcius"/>
        </staticExample>
      </appInfo>
    </annotations>
    <binding>
      <targetDatatype name="IVL"/>
      <argumentDatatype name="PQ"/>
    </binding>
    <property name="lowClosed" conformance="NP" fixedValue="true">
      <derivedFrom relationship="restriction">
        <targetDatatype name="IVL"/>
      </derivedFrom>
    </property>
    <property name="highClosed" conformance="NP" fixedValue="true">
      <derivedFrom relationship="restriction">
        <targetDatatype name="IVL"/>
      </derivedFrom>
    </property>
    <property name="width" conformance="NP" fixedValue="NullFlavor.NI">
      <derivedFrom relationship="restriction">
        <targetDatatype name="IVL"/>
      </derivedFrom>
    </property>
    <property name="center" conformance="NP" fixedValue="NullFlavor.NI">
      <derivedFrom relationship="restriction">
        <targetDatatype name="IVL"/>
      </derivedFrom>
    </property>
    <property name="low" conformance="R" minimumMultiplicity="1">
      <annotations>
        <documentation>
          <definition>
            <text>Identifies the lower bound of the range</text>
          </definition>
          <usageConstraint>
            <text>Must follow one of the pan-Canadian PQ flavors</text>
          </usageConstraint>
        </documentation>
      </annotations>
      <derivedFrom relationship="restriction">
        <targetDatatype name="IVL"/>
      </derivedFrom>
    </property>
    <property name="high" conformance="R" minimumMultiplicity="1">
      <annotations>
        <documentation>
          <definition>
            <text>Identifies the upper bound of the range</text>
          </definition>
          <usageConstraint>
            <text>Must follow one of the pan-Canadian PQ flavors</text>
          </usageConstraint>
        </documentation>
      </annotations>
      <derivedFrom relationship="restriction">
        <targetDatatype name="IVL"/>
      </derivedFrom>
    </property>
  </datatype>
  <datatype name="URG_PQ" title="Uncertain Quantity" datatypeKind="Binding" visibility="public">
    <annotations>
      <documentation>
        <definition>
          <text>
            <html:p>This is used to express a single quantity whose specific value is not known, but whose upper and lower bounds are known. The URG data type already places implicit constraints on probability.  Outside the range, probability is 0, within the range, probability is unknown.</html:p>
            <html:p>PQ.x implies any of the PQ.x data types in the specification (e.g. PQ.LAB, PQ.DISTANCE), not the PQ data type by itself.</html:p>
          </text>
        </definition>
      </documentation>
      <appInfo>
        <staticExample itsName="XML">
          <data>
            <value xsi:type="URG_PQ">
              <low xsi:type="PQ" flavorId="PQ.DRUG" value="1"/>
              <high xsi:type="PQ" flavorId="PQ.DRUG" value="3"/>
            </value>
          </data>
          <businessName name="1 to 3"/>
        </staticExample>
      </appInfo>
    </annotations>
    <binding>
      <targetDatatype name="URG"/>
      <argumentDatatype name="PQ"/>
    </binding>
    <property name="range" conformance="R" minimumMultiplicity="1">
      <derivedFrom relationship="restriction">
        <targetDatatype name="URG"/>
      </derivedFrom>
      <type name="IVL_PQ"/>
    </property>
  </datatype>
  <datatype name="RTO_PQ.DRUG_PQ.TIME" title="Drug Quantity per Time Duration" datatypeKind="Binding" visibility="public">
    <annotations>
      <documentation>
        <definition>
          <text>Used to express a quantity of drug over a particular time-period.</text>
        </definition>
      </documentation>
      <appInfo>
        <staticExample itsName="XML">
          <data>
            <maxDoseQuantity xsi:type="RTO_PQ">
              <numerator xsi:type="PQ" flavorId="PQ.DRUG" value="10"/>
              <denominator xsi:type="PQ" flavorId="PQ.TIME" value="1" unit="d"/>
            </maxDoseQuantity>
          </data>
          <businessName name="10 per day"/>
        </staticExample>
      </appInfo>
    </annotations>
    <binding>
      <targetDatatype name="RTO"/>
      <argumentDatatype name="PQ.DRUG"/>
      <argumentDatatype name="PQ.TIME"/>
    </binding>
    <property name="numerator" conformance="R" isMandatory="true" minimumMultiplicity="1">
      <annotations>
        <documentation>
          <definition>
            <text>Indicates the quantity of drug</text>
          </definition>
        </documentation>
      </annotations>
      <derivedFrom relationship="restriction">
        <targetDatatype name="RTO"/>
      </derivedFrom>
      <type name="PQ.DRUG"/>
    </property>
    <property name="denominator" conformance="R" isMandatory="true" minimumMultiplicity="1">
      <annotations>
        <documentation>
          <definition>
            <text>Indicates the time duration over which that quantity of drug should be given</text>
          </definition>
        </documentation>
      </annotations>
      <derivedFrom relationship="restriction">
        <targetDatatype name="RTO"/>
      </derivedFrom>
      <type name="PQ.TIME"/>
    </property>
  </datatype>
  <datatype name="RTO_MO.CAD_PQ.BASIC" title="Money per Unit Quantity" datatypeKind="Binding" visibility="public">
    <annotations>
      <documentation>
        <definition>
          <text>Used to express a monetary value over quantity.</text>
        </definition>
      </documentation>
      <appInfo>
        <staticExample itsName="XML">
          <data>
            <unitPriceAmt xsi:type="RTO_PQ">
              <numerator xsi:type="MO" flavorId="MO.CAD" value="20.00"/>
              <denominator xsi:type="PQ" flavorId="PQ.BASIC" value="1" unit="gram"/>
            </unitPriceAmt>
          </data>
          <businessName name="$20 per gram"/>
        </staticExample>
      </appInfo>
    </annotations>
    <binding>
      <targetDatatype name="RTO"/>
      <argumentDatatype name="MO.CAD"/>
      <argumentDatatype name="PQ.BASIC"/>
    </binding>
    <property name="numerator" conformance="R" isMandatory="true" minimumMultiplicity="1">
      <annotations>
        <documentation>
          <definition>
            <text>indicates the monetary value</text>
          </definition>
        </documentation>
      </annotations>
      <derivedFrom relationship="restriction">
        <targetDatatype name="RTO"/>
      </derivedFrom>
      <type name="MO.CAD"/>
    </property>
    <property name="denominator" conformance="R" isMandatory="true" minimumMultiplicity="1">
      <annotations>
        <documentation>
          <definition>
            <text>indicates the unit quantity</text>
          </definition>
        </documentation>
      </annotations>
      <derivedFrom relationship="restriction">
        <targetDatatype name="RTO"/>
      </derivedFrom>
      <type name="PQ.BASIC"/>
    </property>
  </datatype>
  <datatype name="ENXP.REQUIRED_PART" title="Typed Entity Name Part" datatypeKind="Flavor" visibility="protected">
    <derivedFrom relationship="restriction">
      <targetDatatype name="ENXP"/>
    </derivedFrom>
    <annotations>
      <documentation>
        <definition>
          <text>Used to express person names for general identification and communication purposes.</text>
        </definition>
      </documentation>
      <appInfo>
        <formalConstraint>
          <text>Each name part is constrained to a 50 character string (ST)</text>
          <alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (ENXP x) where x.isNonNull {
  x.length.lessThanOrEqual(50)
};</alternateFormalExpression>
        </formalConstraint>
      </appInfo>
    </annotations>
    <property name="partType" conformance="R" isMandatory="true" minimumMultiplicity="1">
      <derivedFrom relationship="restriction">
        <targetDatatype name="ENXP"/>
      </derivedFrom>
      <vocabularySpecification>
        <valueSet name="CanadianEntityNamePartType" codingStrength="CNE"/>
      </vocabularySpecification>
    </property>
    <property name="qualifier" conformance="R" isMandatory="true">
      <derivedFrom relationship="restriction">
        <targetDatatype name="ENXP"/>
      </derivedFrom>
      <vocabularySpecification>
        <valueSet name="CanadianEntityNamePartQualifier" codingStrength="CNE"/>
      </vocabularySpecification>
    </property>
  </datatype>
  <datatype name="ENXP.OPTIONAL_PART" title="Optional Entity Name Part" datatypeKind="Flavor" visibility="protected">
    <derivedFrom relationship="restriction">
      <targetDatatype name="ENXP"/>
    </derivedFrom>
    <annotations>
      <documentation>
        <definition>
          <text>Used to express person names for general identification and communication purposes.</text>
        </definition>
      </documentation>
      <appInfo>
        <formalConstraint>
          <text>Each name part is constrained to a 50 character string (ST)</text>
          <alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (ENXP x) where x.isNonNull {
<!-- Grahame: Not sure how to check the number of characters in a string -->
};</alternateFormalExpression>
        </formalConstraint>
      </appInfo>
    </annotations>
    <property name="partType" conformance="R">
      <derivedFrom relationship="restriction">
        <targetDatatype name="ENXP"/>
      </derivedFrom>
      <vocabularySpecification>
        <valueSet name="CanadianEntityNamePartType" codingStrength="CNE"/>
      </vocabularySpecification>
    </property>
    <property name="qualifier" conformance="R">
      <derivedFrom relationship="restriction">
        <targetDatatype name="ENXP"/>
      </derivedFrom>
      <vocabularySpecification>
        <valueSet name="CanadianEntityNamePartQualifier" codingStrength="CNE"/>
      </vocabularySpecification>
    </property>
  </datatype>
  <datatype name="ENXP.NO_PART" title="Un-typed Entity Name Part" datatypeKind="Flavor" visibility="protected">
    <derivedFrom relationship="restriction">
      <targetDatatype name="ENXP"/>
    </derivedFrom>
    <annotations>
      <documentation>
        <definition>
          <text>Used to express person names for general identification and communication purposes.</text>
        </definition>
      </documentation>
      <appInfo>
        <formalConstraint>
          <text>Each name part is constrained to a 50 character string (ST)</text>
          <alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (ENXP x) where x.isNonNull {
<!-- Grahame: Not sure how to check the number of characters in a string -->
};</alternateFormalExpression>
        </formalConstraint>
      </appInfo>
    </annotations>
    <property name="partType" conformance="NP" fixedValue="NullFlavor.NI">
      <derivedFrom relationship="restriction">
        <targetDatatype name="ENXP"/>
      </derivedFrom>
    </property>
    <property name="qualifier" conformance="R">
      <derivedFrom relationship="restriction">
        <targetDatatype name="ENXP"/>
      </derivedFrom>
      <vocabularySpecification>
        <valueSet name="CanadianEntityNamePartQualifier" codingStrength="CNE"/>
      </vocabularySpecification>
    </property>
  </datatype>
  <datatype name="PN.BASIC" title="Basic Person Name" datatypeKind="Flavor" visibility="public">
    <historyItem dateTime="2007-12-07" isSubstantiveChange="true">
      <description>Added "C" (License) and "HC" (Health Care Card as new values for use property.</description>
    </historyItem>
    <derivedFrom relationship="restriction">
      <targetDatatype name="PN"/>
    </derivedFrom>
    <annotations>
      <documentation>
        <definition>
          <text>Used to express person names for general identification and communication purposes.</text>
        </definition>
        <usageNotes>
          <text>There is no constraint on the allowed values of either the "prefix" or "suffix" components.  The requirement for middle name is met through additional repetitions of "given names".  Designation is met through use of the "suffix".</text>
        </usageNotes>
        <requirements>
          <text>Ballot comment #13</text>
        </requirements>
      </documentation>
      <appInfo>
        <formalConstraint>
          <text>No more than seven name parts must be present.</text>
          <alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (PN.BASIC x) where x.isNonNull {
x.length.lessOrEqual(7);
};</alternateFormalExpression>
        </formalConstraint>
        <formalConstraint>
          <text>Declaration of part types is optional.  I.e. Name may be expressed as a plain string or mixed content</text>
          <alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (PN.BASIC x, INT y) where x.isNonNull.and(y.lessOrEqual(x.length)) {
x.item(y).type.equal(ENXP.OPTIONAL_PART);
<!-- Grahame: Not sure how to check the number of characters in a string -->
};</alternateFormalExpression>
        </formalConstraint>
        <staticExample itsName="XML">
          <data>
            <name use="L" xsi:type="PN" flavorId="PN.BASIC">
              <prefix>Mr</prefix>
              <given>John</given>
              <given qualifier="IN">W</given>
              <family>Smith</family>
            </name>
          </data>
        </staticExample>
      </appInfo>
    </annotations>
    <property name="validTime" conformance="NP" fixedValue="NullFlavor.NI">
      <derivedFrom relationship="restriction">
        <targetDatatype name="PN"/>
      </derivedFrom>
    </property>
    <property name="use" conformance="R" isMandatory="true" minimumMultiplicity="1">
      <derivedFrom relationship="restriction">
        <targetDatatype name="PN"/>
      </derivedFrom>
      <vocabularySpecification>
        <valueSet name="CanadianEntityNameUse" codingStrength="CNE"/>
      </vocabularySpecification>
    </property>
  </datatype>
  <datatype name="PN.SIMPLE" title="Simple Person Name" datatypeKind="Flavor" visibility="public">
    <historyItem dateTime="2007-12-07" isSubstantiveChange="true">
      <description>Added data type as distinct from PN.BASIC for string names.</description>
    </historyItem>
    <derivedFrom relationship="restriction">
      <targetDatatype name="PN"/>
    </derivedFrom>
    <annotations>
      <documentation>
        <definition>
          <text>Used to express person names without name parts.</text>
        </definition>
        <requirements>
          <text>Ballot comment #42</text>
        </requirements>
      </documentation>
      <appInfo>
        <formalConstraint>
          <text>The names are to be expressed as a simple string with parts not distinguished.  Systems are expected to be able to support names entered or transmitted in this format, though discrete name parts should be captured whenever feasible.</text>
          <alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (PN.BASIC x, INT y) where x.isNonNull.and(y.lessOrEqual(x.length)) {
x.item(y).type.equal(ENXP.NO_PART);
<!-- Grahame: Not sure how to check the number of characters in a string -->
};</alternateFormalExpression>
        </formalConstraint>
        <staticExample itsName="XML">
          <data>
            <name use="L" xsi:type="PN" flavorId="PN.SIMPLE">Mr. John W. Smith</name>
          </data>
        </staticExample>
      </appInfo>
    </annotations>
    <property name="validTime" conformance="NP" fixedValue="NullFlavor.NI">
      <derivedFrom relationship="restriction">
        <targetDatatype name="PN"/>
      </derivedFrom>
    </property>
    <property name="use" conformance="R" isMandatory="true" minimumMultiplicity="1">
      <derivedFrom relationship="restriction">
        <targetDatatype name="PN"/>
      </derivedFrom>
      <vocabularySpecification>
        <valueSet name="CanadianEntityNameUse" codingStrength="CNE"/>
      </vocabularySpecification>
    </property>
  </datatype>
  <datatype name="PN.FULL" title="Full Person Name" datatypeKind="Flavor" visibility="public">
    <derivedFrom relationship="restriction">
      <targetDatatype name="PN"/>
    </derivedFrom>
    <annotations>
      <documentation>
        <definition>
          <text>Used to express person names within a registry where full qualification is needed.</text>
        </definition>
        <usageNotes>
          <text>There is no constraint on the allowed values of either the "prefix" or "suffix" components.  The requirement for middle name is met through additional repetitions of "given names".  Designation is met through use of the "suffix".</text>
        </usageNotes>
      </documentation>
      <appInfo>
        <formalConstraint>
          <text>No more than seven name parts must be present.</text>
          <alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (PN.BASIC x) where x.isNonNull {
x.length.lessOrEqual(7);
};</alternateFormalExpression>
        </formalConstraint>
        <formalConstraint>
          <text>Declaration of part types is mandatory.  I.e. All name parts must be typed.  Plain strings and mixed content is prohibited</text>
          <alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (PN.BASIC x, INT y) where x.isNonNull.and(y.lessOrEqual(x.length)) {
x.item(y).type.equal(ENXP.REQUIRED_PART);
<!-- Grahame: Not sure how to check the number of characters in a string -->
};</alternateFormalExpression>
        </formalConstraint>
        <staticExample itsName="XML">
          <data>
            <name use="L" xsi:type="PN" flavorId="PN.FULL">
              <prefix>Mr</prefix>
              <given>John</given>
              <given qualifier="IN">W</given>
              <family>Smith</family>
            </name>
          </data>
        </staticExample>
      </appInfo>
    </annotations>
    <property name="validTime" conformance="NP" fixedValue="NullFlavor.NI">
      <derivedFrom relationship="restriction">
        <targetDatatype name="PN"/>
      </derivedFrom>
    </property>
    <property name="use" conformance="R" isMandatory="true" minimumMultiplicity="1">
      <derivedFrom relationship="restriction">
        <targetDatatype name="PN"/>
      </derivedFrom>
      <vocabularySpecification>
        <valueSet name="CanadianEntityNameUse" codingStrength="CNE"/>
      </vocabularySpecification>
    </property>
  </datatype>
  <datatype name="PN.SEARCH" title="Searchable Name" datatypeKind="Flavor" visibility="public">
    <derivedFrom relationship="restriction">
      <targetDatatype name="PN"/>
    </derivedFrom>
    <annotations>
      <documentation>
        <definition>
          <text>
            <html:p>This type is used to convey name information for searching purposes.</html:p>
            <html:p>All matches are considered to be "starts with" for each specified property.</html:p>
          </text>
        </definition>
        <usageNotes>
          <text>There is no constraint on the allowed values of either the "prefix" or "suffix" components.  The requirement for middle name is met through additional repetitions of "given names".  Designation is met through use of the "suffix".</text>
        </usageNotes>
      </documentation>
      <appInfo>
        <formalConstraint>
          <text>No more than seven name parts must be present.</text>
          <alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (PN.BASIC x) where x.isNonNull {
x.length.lessOrEqual(7);
};</alternateFormalExpression>
        </formalConstraint>
        <formalConstraint>
          <text>Declaration of part types is mandatory.  I.e. All name parts must be typed.  Plain strings and mixed content is prohibited</text>
          <alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (PN.BASIC x, INT y) where x.isNonNull.and(y.lessOrEqual(x.length)) {
x.item(y).type.equal(ENXP.REQUIRED_PART);
<!-- Grahame: Not sure how to check the number of characters in a string -->
};</alternateFormalExpression>
        </formalConstraint>
        <staticExample itsName="XML">
          <data>
            <name xsi:type="PN" flavorId="PN.SEARCH">
              <family>Smith</family>
            </name>
          </data>
        </staticExample>
      </appInfo>
    </annotations>
    <property name="validTime" conformance="NP" fixedValue="NullFlavor.NI">
      <derivedFrom relationship="restriction">
        <targetDatatype name="PN"/>
      </derivedFrom>
    </property>
    <property name="use">
      <derivedFrom relationship="restriction">
        <targetDatatype name="PN"/>
      </derivedFrom>
      <vocabularySpecification>
        <valueSet name="CanadianEntityNameUse" codingStrength="CNE"/>
      </vocabularySpecification>
    </property>
  </datatype>
  <datatype name="ADXP.BASIC" title="Address Part Basic" datatypeKind="Flavor" visibility="protected">
    <derivedFrom relationship="restriction">
      <targetDatatype name="ADXP"/>
    </derivedFrom>
    <annotations>
      <documentation>
        <usageNotes>
          <text>
            <html:p>Use of ISO-3166-1 (alpha-3) is not permitted with this specification (alpha-2 is the only coding system suggested).  Using multiple methods (aplha-2, alpha-3 or numeric) would require implementors to support all methods.  The alpha-2 approach was used to be consistent with Canada Post.</html:p>
            <html:ul>
              <html:li>For example, Canada would be "CA" and British Columbia would be "BC".  These are the same codes used by Canada Post.</html:li>
              <html:li>The complete listing of codes may be found here: <html:a href="http://en.wikipedia.org/wiki/ISO_3166-1"/>.</html:li>
            </html:ul>
          </text>
        </usageNotes>
      </documentation>
      <appInfo>
        <formalConstraint>
          <text>Both address parts and delimiter-separated text are constrained to a length of 80 characters.</text>
          <alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (ADXP x) where x.isNonNull {
<!-- Grahame: Don't know how to enforce length limit on strings -->
};</alternateFormalExpression>
        </formalConstraint>
        <formalConstraint>
          <text>For country and state address parts, coded values are optional (taking advantages of the SC data type)</text>
          <alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (ADXP x) where x.isNonNull.and(x.partType.implies(CNT).or(x.partType.implies(STA)).not) {
x.code.isNull;
};</alternateFormalExpression>
        </formalConstraint>
        <formalConstraint>
          <text>For country, code is restricted to ISO 3166-1 2-character alpha codes</text>
          <alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (ADXP x) where x.isNonNull.and(x.partType.implies(CNT)) {
<!-- Grahame: Don't know how to enforce a conditional binding to a value-set (Should be ISOCountry-2Char) -->
};</alternateFormalExpression>
        </formalConstraint>
        <formalConstraint>
          <text>For state, code is restricted to ISO 3166-2 code suffixes</text>
          <alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (ADXP x) where x.isNonNull.and(x.partType.implies(STA)) {
<!-- Grahame: Don't know how to enforce a conditional binding to a value-set (Should be ISOCountryDivision) -->
};</alternateFormalExpression>
        </formalConstraint>
      </appInfo>
    </annotations>
    <!-- Grahame, please confirm that for Canadian purposes, ADXP is derived from SC, not ST? -->
    <property name="partType" conformance="R">
      <annotations>
        <documentation>
          <usageNotes>
            <text>Part type codes other than those explicitly allowed here are <html:i>Not Permitted</html:i>.  All other address information is sent as plain text, separated by delimiter tags.</text>
          </usageNotes>
        </documentation>
      </annotations>
      <derivedFrom relationship="restriction">
        <targetDatatype name="ADXP"/>
      </derivedFrom>
      <vocabularySpecification>
        <valueSet name="CanadianBasicAddressPartType" codingStrength="CNE"/>
      </vocabularySpecification>
    </property>
  </datatype>
  <datatype name="ADXP.FULL" title="Address Part Full" datatypeKind="Flavor" visibility="protected">
    <derivedFrom relationship="restriction">
      <targetDatatype name="ADXP"/>
    </derivedFrom>
    <annotations>
      <documentation>
        <usageNotes>
          <text>
            <html:p>Use of ISO-3166-1 (alpha-3) is not permitted with this specification (alpha-2 is the only coding system suggested).  Using multiple methods (aplha-2, alpha-3 or numeric) would require implementors to support all methods.  The alpha-2 approach was used to be consistent with Canada Post.</html:p>
            <html:ul>
              <html:li>For example, Canada would be "CA" and British Columbia would be "BC".  These are the same codes used by Canada Post.</html:li>
              <html:li>The complete listing of codes may be found here: <html:a href="http://en.wikipedia.org/wiki/ISO_3166-1"/>.</html:li>
            </html:ul>
          </text>
        </usageNotes>
      </documentation>
      <appInfo>
        <formalConstraint>
          <text>Both address parts and delimiter-separated text are constrained to a length of 80 characters.</text>
          <alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (ADXP x) where x.isNonNull {
<!-- Grahame: Don't know how to enforce length limit on strings -->
};</alternateFormalExpression>
        </formalConstraint>
        <formalConstraint>
          <text>For country and state address parts, coded values are optional (taking advantages of the SC data type)</text>
          <alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (ADXP x) where x.isNonNull.and(x.partType.implies(CNT).or(x.partType.implies(STA)).not) {
x.code.isNull;
};</alternateFormalExpression>
        </formalConstraint>
        <formalConstraint>
          <text>For country, code is restricted to ISO 3166-1 2-character alpha codes</text>
          <alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (ADXP x) where x.isNonNull.and(x.partType.implies(CNT)) {
<!-- Grahame: Don't know how to enforce a conditional binding to a value-set (Should be ISOCountry-2Char) -->
};</alternateFormalExpression>
        </formalConstraint>
        <formalConstraint>
          <text>For state, code is restricted to ISO 3166-2 code suffixes</text>
          <alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (ADXP x) where x.isNonNull.and(x.partType.implies(STA)) {
<!-- Grahame: Don't know how to enforce a conditional binding to a value-set (Should be ISOCountryDivision) -->
};</alternateFormalExpression>
        </formalConstraint>
      </appInfo>
    </annotations>
    <property name="partType" conformance="R">
      <annotations>
        <documentation>
          <usageNotes>
            <text>Part type codes other than those explicitly allowed here are <html:i>Not Permitted</html:i>.  All other address information is sent as plain text, separated by delimiter tags.</text>
          </usageNotes>
        </documentation>
      </annotations>
      <derivedFrom relationship="restriction">
        <targetDatatype name="ADXP"/>
      </derivedFrom>
      <vocabularySpecification>
        <valueSet name="CanadianFullAddressPartType" codingStrength="CNE"/>
      </vocabularySpecification>
    </property>
  </datatype>
  <datatype name="ADXP.SEARCH" title="Address Part Search" datatypeKind="Flavor" visibility="protected">
    <derivedFrom relationship="restriction">
      <targetDatatype name="ADXP"/>
    </derivedFrom>
    <annotations>
      <documentation>
        <usageNotes>
          <text>
            <html:p>Use of ISO-3166-1 (alpha-3) is not permitted with this specification (alpha-2 is the only coding system suggested).  Using multiple methods (aplha-2, alpha-3 or numeric) would require implementors to support all methods.  The alpha-2 approach was used to be consistent with Canada Post.</html:p>
            <html:ul>
              <html:li>For example, Canada would be "CA" and British Columbia would be "BC".  These are the same codes used by Canada Post.</html:li>
              <html:li>The complete listing of codes may be found here: <html:a href="http://en.wikipedia.org/wiki/ISO_3166-1"/>.</html:li>
            </html:ul>
          </text>
        </usageNotes>
      </documentation>
      <appInfo>
        <formalConstraint>
          <text>Both address parts and delimiter-separated text are constrained to a length of 80 characters.</text>
          <alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (ADXP x) where x.isNonNull {
<!-- Grahame: Don't know how to enforce length limit on strings -->
};</alternateFormalExpression>
        </formalConstraint>
        <formalConstraint>
          <text>For country and state address parts, coded values are optional (taking advantages of the SC data type)</text>
          <alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (ADXP x) where x.isNonNull.and(x.partType.implies(CNT).or(x.partType.implies(STA)).not) {
x.code.isNull;
};</alternateFormalExpression>
        </formalConstraint>
        <formalConstraint>
          <text>For country, code is restricted to ISO 3166-1 2-character alpha codes</text>
          <alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (ADXP x) where x.isNonNull.and(x.partType.implies(CNT)) {
<!-- Grahame: Don't know how to enforce a conditional binding to a value-set (Should be ISOCountry-2Char) -->
};</alternateFormalExpression>
        </formalConstraint>
        <formalConstraint>
          <text>For state, code is restricted to ISO 3166-2 code suffixes</text>
          <alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (ADXP x) where x.isNonNull.and(x.partType.implies(STA)) {
<!-- Grahame: Don't know how to enforce a conditional binding to a value-set (Should be ISOCountryDivision) -->
};</alternateFormalExpression>
        </formalConstraint>
      </appInfo>
    </annotations>
    <property name="partType" conformance="R">
      <annotations>
        <documentation>
          <usageNotes>
            <text>Part type codes other than those explicitly allowed here are <html:i>Not Permitted</html:i>.  All other address information is sent as plain text, separated by delimiter tags.</text>
          </usageNotes>
        </documentation>
      </annotations>
      <derivedFrom relationship="restriction">
        <targetDatatype name="ADXP"/>
      </derivedFrom>
      <vocabularySpecification>
        <valueSet name="CanadianSearchAddressPartType" codingStrength="CNE"/>
      </vocabularySpecification>
    </property>
  </datatype>
  <datatype name="AD.BASIC" title="Basic Address" datatypeKind="Flavor" visibility="public">
    <historyItem dateTime="2007-12-07" isSubstantiveChange="true">
      <description>Added maximum number of "use" properties for 1 address specification.</description>
    </historyItem>
    <derivedFrom relationship="restriction">
      <targetDatatype name="AD"/>
    </derivedFrom>
    <annotations>
      <documentation>
        <definition>
          <text>Used to communicate addresses for simple display, mailing and contact purposes.  The data type is not generally suitable for registries</text>
        </definition>
        <requirements>
          <text>Ballot comment #31</text>
        </requirements>
      </documentation>
      <appInfo>
        <formalConstraint>
          <text>There may be up to 4 lines of delimiter-separated information in addition to the specified address parts.</text>
          <alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (AD.BASIC x, INT y) where x.isNonNull.and(y.lessOrEqual(x.length)) {
  count(x.item(y).partType.isNull).lessOrEqual(4);
  <!-- Grahame, I'm pretty sure the 'count' thing is illegal, but wasn't sure how to do it correctly -->
};</alternateFormalExpression>
        </formalConstraint>
        <formalConstraint>
          <text>Address parts are rescricted to basic address parts</text>
          <alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (AD.BASIC x, INT y) where x.isNonNull.and(y.lessOrEqual(x.length)) {
  x.item(y).partType.type.equal(ADXP.BASIC);
};</alternateFormalExpression>
        </formalConstraint>
        <staticExample itsName="XML">
          <data>
            <addr use="H PST" xsi:type="AD" flavorId="AD.BASIC">Apt A5 123 Some Street N.W.<delimiter/>
              <city>Edmonton</city>
              <state code="AB">Alberta</state>
              <postalCode>A1B 2C3</postalCode>
              <delimiter/>
              <country code="CA">Canada</country>
            </addr>
          </data>
        </staticExample>
      </appInfo>
    </annotations>
    <property name="useablePeriod" conformance="NP" fixedValue="NullFlavor.NI">
      <derivedFrom relationship="restriction">
        <targetDatatype name="AD"/>
      </derivedFrom>
    </property>
    <property name="isNotOrdered" conformance="NP" fixedValue="false">
      <derivedFrom relationship="restriction">
        <targetDatatype name="AD"/>
      </derivedFrom>
    </property>
    <property name="use" conformance="R" maximumMultiplicity="3">
      <derivedFrom relationship="restriction">
        <targetDatatype name="AD"/>
      </derivedFrom>
      <vocabularySpecification>
        <valueSet name="CanadianPostalAddressUse" codingStrength="CNE"/>
      </vocabularySpecification>
    </property>
  </datatype>
  <datatype name="AD.FULL" title="Full Address" datatypeKind="Flavor" visibility="public">
    <derivedFrom relationship="restriction">
      <targetDatatype name="AD"/>
    </derivedFrom>
    <annotations>
      <documentation>
        <definition>
          <text>Used to communicate fully validatable addresses.  Usually appropriate only for registry-type situations.</text>
        </definition>
      </documentation>
      <appInfo>
        <formalConstraint>
          <text>There may be up to 4 lines of delimiter-separated information in addition to the specified address parts.</text>
          <alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (AD.FULL x, INT y) where x.isNonNull.and(y.lessOrEqual(x.length)) {
  count(x.item(y).partType.isNull).lessOrEqual(4);
  <!-- Grahame, I'm pretty sure the 'count' thing is illegal, but wasn't sure how to do it correctly -->
};</alternateFormalExpression>
        </formalConstraint>
        <formalConstraint>
          <text>Address parts are rescricted to basic address parts</text>
          <alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (AD.FULL x, INT y) where x.isNonNull.and(y.lessOrEqual(x.length)) {
  x.item(y).partType.type.equal(ADXP.FULL);
};</alternateFormalExpression>
        </formalConstraint>
        <formalConstraint>
          <text>The "city", "postalCode" and "country" properties are mandatory.</text>
          <alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (AD.FULL x) where x.isNonNull {
  exists(ADXP.FULL e) {
         x.contains(e);
         e.partType.implies(CTY);
         e.isNonNull;
         };        
  exists(ADXP.FULL e) {
         x.contains(e);
         e.partType.implies(ZIP);
         e.isNonNull;
         };        
  exists(ADXP.FULL e) {
         x.contains(e);
         e.partType.implies(CNT);
         e.isNonNull;
         };        
};</alternateFormalExpression>
        </formalConstraint>
        <staticExample itsName="XML">
          <data>
            <addr use="H PST" xsi:type="AD" flavorId="AD.FULL">
              <unitId>Apt A5</unitId>
              <houseNumber>123</houseNumber>
              <streetNameBase>Some</streetNameBase>
              <streetNameType>Street</streetNameType>
              <direction>N.W.</direction>
              <delimiter/>
              <city>Edmonton</city>
              <state code="AB">Alberta</state>
              <postalCode>A1B 2C3</postalCode>
              <delimiter/>
              <country code="CA">Canada</country>
            </addr>
          </data>
        </staticExample>
      </appInfo>
    </annotations>
    <property name="useablePeriod">
      <derivedFrom relationship="restriction">
        <targetDatatype name="AD"/>
      </derivedFrom>
      <type name="IVL">
        <argumentDatatype name="TS.DATE"/>
      </type>
    </property>
    <property name="isNotOrdered" conformance="NP" fixedValue="false">
      <derivedFrom relationship="restriction">
        <targetDatatype name="AD"/>
      </derivedFrom>
    </property>
    <property name="use" conformance="R" maximumMultiplicity="3">
      <derivedFrom relationship="restriction">
        <targetDatatype name="AD"/>
      </derivedFrom>
      <vocabularySpecification>
        <valueSet name="CanadianPostalAddressUse" codingStrength="CNE"/>
      </vocabularySpecification>
    </property>
  </datatype>
  <datatype name="AD.SEARCH" title="Searchable Address" datatypeKind="Flavor" visibility="public">
    <historyItem dateTime="2007-12-07" isSubstantiveChange="true">
      <description>Allow for search on postal code</description>
    </historyItem>
    <derivedFrom relationship="restriction">
      <targetDatatype name="AD"/>
    </derivedFrom>
    <annotations>
      <documentation>
        <definition>
          <text>
            <html:p>This type is used to convey high level address information for searching purposes.</html:p>
            <html:p>All matches are considered to be "starts with" for each specified property.</html:p>
          </text>
        </definition>
        <requirements>
          <text>Ballot comment #10</text>
        </requirements>
      </documentation>
      <appInfo>
        <formalConstraint>
          <text>Address parts are rescricted to searchable address parts</text>
          <alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (AD.SEARCH x, INT y) where x.isNonNull.and(y.lessOrEqual(x.length)) {
  x.item(y).partType.type.equal(ADXP.SEARCH);
};</alternateFormalExpression>
        </formalConstraint>
        <formalConstraint>
          <text>at least one part type must be specified (e.g. city)</text>
          <alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (AD.SEARCH x) where x.isNonNull {
  x.length.greaterOrEqual(1);
};</alternateFormalExpression>
        </formalConstraint>
        <staticExample itsName="XML">
          <data>
            <addr xsi:type="AD" flavorId="AD.SEARCH">
              <city>Edmonton</city>
              <state code="AB">Alberta</state>
              <country code="CA">Canada</country>
            </addr>
          </data>
        </staticExample>
      </appInfo>
    </annotations>
    <property name="useablePeriod" conformance="NP" fixedValue="NullFlavor.NI">
      <derivedFrom relationship="restriction">
        <targetDatatype name="AD"/>
      </derivedFrom>
    </property>
    <property name="isNotOrdered" conformance="NP" fixedValue="false">
      <derivedFrom relationship="restriction">
        <targetDatatype name="AD"/>
      </derivedFrom>
    </property>
    <property name="use" conformance="NP" fixedValue="NullFlavor.NI">
      <derivedFrom relationship="restriction">
        <targetDatatype name="AD"/>
      </derivedFrom>
    </property>
  </datatype>
  <datatype name="TEL.PHONEMAIL" title="Phone or E-mail" datatypeKind="Flavor" visibility="public" isAbstract="true">
    <derivedFrom relationship="restriction">
      <targetDatatype name="TEL"/>
    </derivedFrom>
    <annotations>
      <documentation>
        <definition>
          <text>Allows phone and fax numbers as well as e-mail addresses to be communicated.</text>
        </definition>
        <usageNotes>
          <text>This data type may be referenced in Canadian specifications.  If this data type is used in a message instance, it must be declared as TEL.PHONE or TEL.EMAIL for each repetition.</text>
        </usageNotes>
      </documentation>
    </annotations>
    <childDatatype name="TEL.PHONE"/>
    <childDatatype name="TEL.EMAIL"/>
  </datatype>
  <datatype name="TEL.PHONE" title="Phone Number" datatypeKind="Flavor" visibility="public">
    <historyItem dateTime="2007-12-07" isSubstantiveChange="true">
      <description>Added "DIR" as address use</description>
    </historyItem>
    <derivedFrom relationship="restriction">
      <targetDatatype name="TEL"/>
    </derivedFrom>
    <annotations>
      <documentation>
        <definition>
          <text>Allows phone and fax numbers to be communicated.</text>
        </definition>
        <requirements>
          <text>Ballot comment #69</text>
        </requirements>
      </documentation>
      <appInfo>
        <staticExample itsName="XML">
          <data>
            <telecom use="EC MC" xsi:type="TEL" flavorId="TEL.PHONE" value="tel:+1-780-123-4567"/>
          </data>
        </staticExample>
      </appInfo>
    </annotations>
    <property name="useablePeriod" conformance="NP" fixedValue="NullFlavor.NI">
      <derivedFrom relationship="restriction">
        <targetDatatype name="TEL"/>
      </derivedFrom>
    </property>
    <property name="use" conformance="R" maximumMultiplicity="3">
      <annotations>
        <documentation>
          <usageNotes>
            <text>Additional guidance for DIR: to be used for immediate direct communications between providers (e.g. pharmacist to physician for potential medication interaction issues).</text>
          </usageNotes>
        </documentation>
      </annotations>
      <derivedFrom relationship="restriction">
        <targetDatatype name="TEL"/>
      </derivedFrom>
      <vocabularySpecification>
        <valueSet name="CanadianPhoneTelecommunicationAddressUse" codingStrength="CNE"/>
      </vocabularySpecification>
    </property>
    <property name="scheme" conformance="R" isMandatory="true" minimumMultiplicity="1">
      <derivedFrom relationship="restriction">
        <targetDatatype name="TEL"/>
      </derivedFrom>
      <vocabularySpecification>
        <valueSet name="CanadianPhoneURIScheme" codingStrength="CNE"/>
      </vocabularySpecification>
    </property>
    <property name="address" conformance="R" isMandatory="true" minimumMultiplicity="1" maximumLength="21">
      <annotations>
        <documentation>
          <usageNotes>
            <text>Address must follow the format described in <html:a href="http://www.ietf.org/rfc/rfc2806.txt"/>.  The maximum length is 25 characters.  Note: There is no constraint to support only Canadian country codes, nor is there any specific formatting necessary to distinguish area codes and country codes within the phone number.  Best practice is to always include country code and area code when known.</text>
          </usageNotes>
        </documentation>
      </annotations>
      <derivedFrom relationship="restriction">
        <targetDatatype name="TEL"/>
      </derivedFrom>
    </property>
  </datatype>
  <datatype name="TEL.EMAIL" title="E-mail Address" datatypeKind="Flavor" visibility="public">
    <historyItem dateTime="2007-12-07" isSubstantiveChange="true">
      <description>Added "URL" property specification</description>
    </historyItem>
    <derivedFrom relationship="restriction">
      <targetDatatype name="TEL"/>
    </derivedFrom>
    <annotations>
      <documentation>
        <definition>
          <text>Allows e-mail addresses to be communicated.</text>
        </definition>
        <requirements>
          <text>Ballot comment #32</text>
        </requirements>
      </documentation>
      <appInfo>
        <staticExample itsName="XML">
          <data>
            <telecom url="mailto" use="WP" xsi:type="TEL" flavorId="TEL.EMAIL" value="mailto:someone@somewhere.com"/>
          </data>
        </staticExample>
      </appInfo>
    </annotations>
    <property name="useablePeriod" conformance="NP" fixedValue="NullFlavor.NI">
      <derivedFrom relationship="restriction">
        <targetDatatype name="TEL"/>
      </derivedFrom>
    </property>
    <property name="use" conformance="R" maximumMultiplicity="3">
      <derivedFrom relationship="restriction">
        <targetDatatype name="TEL"/>
      </derivedFrom>
      <vocabularySpecification>
        <valueSet name="CanadianEmailTelecommunicationAddressUse" codingStrength="CNE"/>
      </vocabularySpecification>
    </property>
    <property name="scheme" conformance="R" isMandatory="true" minimumMultiplicity="1">
      <derivedFrom relationship="restriction">
        <targetDatatype name="TEL"/>
      </derivedFrom>
      <vocabularySpecification>
        <code code="mailto" codeSystem="2.16.840.1.113883.5.143"/>
      </vocabularySpecification>
    </property>
    <property name="address" conformance="R" isMandatory="true" minimumMultiplicity="1" maximumLength="43">
      <derivedFrom relationship="restriction">
        <targetDatatype name="TEL"/>
      </derivedFrom>
    </property>
  </datatype>
  <datatype name="TEL.URI" title="Uniform Resource Identifier" datatypeKind="Flavor" visibility="public">
    <derivedFrom relationship="restriction">
      <targetDatatype name="TEL"/>
    </derivedFrom>
    <annotations>
      <documentation>
        <definition>
          <text>Used to communicate web addresses and other internet communication schemes.</text>
        </definition>
      </documentation>
      <appInfo>
        <formalConstraint>
          <text>Length of value must be less than or equal to 255</text>
          <alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (TEL.URI x) where x.isNonNull {
  x.address.length.plus(x.scheme.length).lessOrEqual(244);
};</alternateFormalExpression>
        </formalConstraint>
        <staticExample itsName="XML">
          <data>
            <telecom xsi:type="TEL" flavorId="TEL.URI" value="https://www.someserver.ca/somelocation"/>
          </data>
        </staticExample>
      </appInfo>
    </annotations>
    <property name="useablePeriod" conformance="NP" fixedValue="NullFlavor.NI">
      <derivedFrom relationship="restriction">
        <targetDatatype name="TEL"/>
      </derivedFrom>
    </property>
    <property name="use" conformance="NP" fixedValue="NullFlavor.NI">
      <derivedFrom relationship="restriction">
        <targetDatatype name="TEL"/>
      </derivedFrom>
    </property>
    <property name="scheme" conformance="R" isMandatory="true" minimumMultiplicity="1">
      <derivedFrom relationship="restriction">
        <targetDatatype name="TEL"/>
      </derivedFrom>
      <vocabularySpecification>
        <valueSet name="CanadianURIScheme" codingStrength="CNE"/>
      </vocabularySpecification>
    </property>
    <property name="address" conformance="R" isMandatory="true" minimumMultiplicity="1">
      <annotations>
        <documentation>
          <usageNotes>
            <text>Address must conform to the format associated with the identified telecommunication scheme</text>
          </usageNotes>
        </documentation>
      </annotations>
      <derivedFrom relationship="restriction">
        <targetDatatype name="TEL"/>
      </derivedFrom>
    </property>
  </datatype>
  <datatype name="ANY" title="Unrestricted" datatypeKind="Flavor" visibility="public" isAbstract="true">
    <derivedFrom relationship="annotated">
      <targetDatatype name="ANY"/>
    </derivedFrom>
    <annotations>
      <documentation>
        <definition>
          <text>Used in a specification where the specific types to be communicated may vary.</text>
        </definition>
        <usageNotes>
          <text>
            <html:p>This data type may be referenced in Canadian specifications.  If this data type is used in a message instance, it must be declared as one of the constrained version of ANY (e.g. ST) for each repetition.</html:p>
            <html:p>Each value sent over the wire must correspond to one of the non-abstract data type flavor specifications defined in this document.</html:p>
            <html:p>The specific data type must be declared using xsi:type.</html:p>
            <html:p>The use of this type is discouraged in specifications unless additional constraints are included indicating what specific data type flavors may be substituted.</html:p>
          </text>
        </usageNotes>
      </documentation>
    </annotations>
  </datatype>
  <datatype name="ANY.LAB" title="Lab result types" datatypeKind="Flavor" visibility="public" isAbstract="true">
    <derivedFrom relationship="annotated">
      <targetDatatype name="ANY"/>
    </derivedFrom>
    <annotations>
      <documentation>
        <definition>
          <text>Used in a specification where the specific types to be communicated may vary.</text>
        </definition>
        <usageNotes>
          <text>
            <html:p>This data type may be referenced in Canadian specifications.  If this data type is used in a message instance, it must be declared as one of the constrained version of ANY (e.g. ST) for each repetition.</html:p>
            <html:p>The specific data type must be declared using xsi:type.</html:p>
            <html:p>The use of this type is restricted to messages in the LAB domain</html:p>
          </text>
        </usageNotes>
      </documentation>
    </annotations>
    <childDatatype name="CD.LAB"/>
    <childDatatype name="ST"/>
    <childDatatype name="PQ.LAB"/>
    <childDatatype name="IVL">
      <argumentDatatype name="PQ"/>
    </childDatatype>
    <childDatatype name="INT.NONNEG"/>
    <childDatatype name="INT.POS"/>
    <childDatatype name="TS.FULLDATETIME"/>
  </datatype>
  <datatype name="ANY.PATH" title="Pathology result types" datatypeKind="Flavor" visibility="public" isAbstract="true">
    <derivedFrom relationship="annotated">
      <targetDatatype name="ANY"/>
    </derivedFrom>
    <annotations>
      <documentation>
        <definition>
          <text>Used in a specification where the specific types to be communicated may vary.</text>
        </definition>
        <usageNotes>
          <text>
            <html:p>This data type may be referenced in Canadian specifications.  If this data type is used in a message instance, it must be declared as one of the constrained version of ANY (e.g. ST) for each repetition.</html:p>
            <html:p>Each value sent over the wire must correspond to one of the non-abstract data type flavor specifications defined in this document.</html:p>
            <html:p>The specific data type must be declared using xsi:type.</html:p>
            <html:p>The use of this type is discouraged in specifications unless additional constraints are included indicating what specific data type flavors may be substituted.</html:p>
          </text>
        </usageNotes>
      </documentation>
    </annotations>
    <childDatatype name="ST"/>
    <childDatatype name="PQ"/>
    <childDatatype name="ED.DOCORREF"/>
    <childDatatype name="CD.LAB"/>
  </datatype>
  <datatype name="BL" title="Boolean" datatypeKind="Flavor" visibility="public">
    <derivedFrom relationship="annotated">
      <targetDatatype name="BL"/>
    </derivedFrom>
    <annotations>
      <documentation>
        <definition>
          <text>Allows conveying true-false information.</text>
        </definition>
        <usageNotes>
          <text>The "value" property is mandatory and case-sensitive.  It must be either "true" or "false".  Note that unless the attribute declaring this type is marked as mandatory, the value is allowed to be null.  This must be taken into account when performing boolean logic.  Consult the HL7 international abstract data types specification for further details.</text>
        </usageNotes>
      </documentation>
      <appInfo>
        <staticExample itsName="XML">
          <data>
            <negationInd value="true"/>
          </data>
        </staticExample>
      </appInfo>
    </annotations>
  </datatype>
  <datatype name="LIST" title="List" datatypeKind="Flavor" visibility="public">
    <derivedFrom relationship="annotated">
      <targetDatatype name="LIST"/>
    </derivedFrom>
    <annotations>
      <documentation>
        <definition>
          <text>Used when multiple repetitions are allowed and order matters.</text>
        </definition>
        <usageNotes>
          <text>
            <html:p>Each repetition must follow the specification defined for type of list item.</html:p>
            <html:p>Applications are expected to retain information about the sequence of the repetitions.  The semantics of the sequence can be found in the description of the attribute or property.  Duplicate repetitions are technically allowed, but should occur only if they make sense in the context of use.</html:p>
          </text>
        </usageNotes>
      </documentation>
    </annotations>
    <parameter sortKey="1" name="T">
      <type name="ANY"/>
    </parameter>
  </datatype>
  <datatype name="SET" title="Set" datatypeKind="Flavor" visibility="public">
    <derivedFrom relationship="annotated">
      <targetDatatype name="SET"/>
    </derivedFrom>
    <annotations>
      <documentation>
        <definition>
          <text>Used when multiple repetitions are allowed, order is irrelevant and duplicates are prohibited.</text>
        </definition>
        <usageNotes>
          <text>
            <html:p>Each repetition must follow the specification defined for type of list item.</html:p>
            <html:p>Duplicate repetitions are not allowed.</html:p>
          </text>
        </usageNotes>
      </documentation>
    </annotations>
    <parameter sortKey="1" name="T">
      <type name="ANY"/>
    </parameter>
  </datatype>
  <datatype name="URG" title="UncertainRange" datatypeKind="Definition" visibility="public">
    <derivedFrom relationship="extension">
      <targetDatatype name="T" qualifier="parameter"/>
    </derivedFrom>
    <annotations>
      <documentation>
        <definition>
          <text>
					Indicates that the value comes from a range of possible values from an ordered base data type value.
				</text>
        </definition>
        <designComments>
          <text>
            <html:p>
              <html:object name="itemName">
                <html:param name="item" value="datatype"/>
              </html:object> is used where the actual value is unknown, but it is known that the 
					value comes from a known range of possible values. 
				</html:p>
            <html:p>
              <html:object name="itemName">
                <html:param name="item" value="datatype"/>
              </html:object> differs from <html:object name="datatypeRef">
                <html:param name="datatypeName" value="PPD"/>
              </html:object> in that <html:object name="datatypeRef">
                <html:param name="datatypeName" value="PPD"/>
              </html:object> is used to report a 
					particular value along with an associated distribution of uncertainty for the 
					value, or to report the summary distribution of a set of data, whereas <html:object name="itemName">
                <html:param name="item" value="datatype"/>
              </html:object> indicates
					that there is a single value that, although unknown, must come from a particular range
					of values. No inference regarding distribution of values can be taken. <html:object name="itemName">
                <html:param name="item" value="datatype"/>
              </html:object> 
					is often associated with an instruction to perform a particular operation at 
					some point within a given time interval.  
				</html:p>
            <html:p>
					Any ordered type can be the basis of an <html:object name="itemName">
                <html:param name="item" value="datatype"/>
              </html:object>; it does not matter
					whether the base type is discrete or continuous. If the base data type
					is only partially ordered, all possible values for the <html:object name="itemName">
                <html:param name="item" value="datatype"/>
              </html:object> are
					elements of a totally ordered subset of the partially ordered data
					type.
				</html:p>
            <html:p>
					For example, <html:object name="datatypeRef">
                <html:param name="datatypeName" value="PQ"/>
              </html:object> is considered ordered. However the
					ordering of <html:object name="datatypeRef">
                <html:param name="datatypeName" value="PQ"/>
              </html:object>s is only partial; a total order is only
					defined among comparable quantities (quantities of the same physical
					dimension).  While <html:object name="itemName">
                <html:param name="item" value="datatype"/>
              </html:object>s between 2 and 4 meter exists, there is no
					<html:object name="itemName">
                <html:param name="item" value="datatype"/>
              </html:object> between 2 meters and 4 seconds.
				</html:p>
          </text>
        </designComments>
        <otherAnnotation type="DTDL">
          <data>
template&lt;QTY T&gt;
type UncertainRange&lt;T&gt; alias URG&lt;T&gt; specializes T {
   IVL&lt;T&gt;   range;
   BL       couldBe(T value);
};</data>
        </otherAnnotation>
      </documentation>
      <appInfo>
        <formalConstraint>
          <text>
					Implicit in the use of <html:object name="itemName">
              <html:param name="item" value="datatype"/>
            </html:object> is a statement that the actual value is
					unknown.
				</text>
          <alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(URG&lt;T&gt; x) {
  x.unknown;
};
</alternateFormalExpression>
        </formalConstraint>
      </appInfo>
    </annotations>
    <parameter name="T" sortKey="1">
      <type name="QTY"/>
    </parameter>
    <property name="range" sortKey="01" propertyKind="variableProperty" visibility="public" isMandatory="false" minimumMultiplicity="0" maximumMultiplicity="1" conformance="R">
      <businessName name="Range"/>
      <annotations>
        <documentation>
          <definition>
            <text>
							Defines the range of possible values.
						</text>
          </definition>
          <designComments>
            <text>
              <html:p>
							When a range is specified, it SHALL be anchored to known values, not just a width,
							and the property <html:object name="propertyRef">
                  <html:param name="propertyName" value="any"/>
                  <html:param name="datatypeName" value="IVL"/>
                </html:object> SHALL be null.
						</html:p>
            </text>
          </designComments>
        </documentation>
        <appInfo>
          <formalConstraint>
            <text/>
            <alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(URG&lt;T&gt; x) 
      where x.range.nonNull {
   x.range.any.isNull;
   x.range.center.nonNull;
};</alternateFormalExpression>
          </formalConstraint>
        </appInfo>
      </annotations>
      <type name="IVL">
        <argumentDatatype name="T" qualifier="parameter"/>
      </type>
    </property>
    <property name="couldBe" sortKey="02" propertyKind="variableProperty" visibility="public" isMandatory="false" minimumMultiplicity="0" maximumMultiplicity="1" conformance="R">
      <businessName name="Could Be"/>
      <annotations>
        <documentation>
          <definition>
            <text/>
          </definition>
          <designComments>
            <text>
              <html:p>
							Although the actual value is unknown, it is possible to determine whether
							a <html:object name="itemName">
                  <html:param name="item" value="datatype"/>
                </html:object> could be a particular value. A particular value is possible if
							it is contained within the specified range.
						</html:p>
            </text>
          </designComments>
        </documentation>
        <appInfo>
          <formalConstraint>
            <text/>
            <alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(URG&lt;T&gt; x, T t) 
    where x.range.nonNull {
  x.couldBe(t).equals(x.range.contains(t));
};</alternateFormalExpression>
          </formalConstraint>
        </appInfo>
      </annotations>
      <parameter name="value" sortKey="1">
        <type name="T" qualifier="parameter"/>
      </parameter>
      <type name="BL"/>
    </property>
    <property name="equal" sortKey="03" propertyKind="variableProperty" visibility="public" isMandatory="false" minimumMultiplicity="0" maximumMultiplicity="1" conformance="R">
      <businessName name="Equality"/>
      <annotations>
        <documentation>
          <definition>
            <text/>
          </definition>
          <designComments>
            <text>
              <html:p>
						Since the actual value is not known, it is not possible to
						evaluate the equality of a <html:object name="itemName">
                  <html:param name="item" value="datatype"/>
                </html:object>
              </html:p>
            </text>
          </designComments>
        </documentation>
        <appInfo>
          <formalConstraint>
            <text/>
            <alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(URG&lt;T&gt; x, T t) 
    where x.compares(t) {
  x.equal(t).unknown;
};</alternateFormalExpression>
          </formalConstraint>
        </appInfo>
      </annotations>
      <derivedFrom>
        <targetDatatype name="ANY"/>
      </derivedFrom>
      <parameter name="x" sortKey="1">
        <type name="T" qualifier="parameter"/>
      </parameter>
      <type name="BL"/>
    </property>
  </datatype>
</datatypeModelLibrary>
