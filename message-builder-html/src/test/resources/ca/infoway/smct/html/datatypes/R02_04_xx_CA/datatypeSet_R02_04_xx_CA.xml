<!--

    Copyright 2013 Canada Health Infoway, Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

           http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    Author:        $LastChangedBy: gng $
    Last modified: $LastChangedDate: 2011-05-04 16:47:15 -0300 (Wed, 08 May 2013) $
    Revision:      $LastChangedRevision: $

-->
<datatypeSet version="R02.04.00" realmCode="CA" combinedId="DEFN=CA=DT=R02.04.00">
   <datatypeEntry name="GTS.BOUNDEDPIVL">
      <datatype isAbstract="false" name="GTS.BOUNDEDPIVL" businessName="General Timing Specification (Time-range and Frequency)" visibility="public" superType="GTS" isMerged="false">
         <documentation>
            <businessName>General Timing Specification (Time-range and Frequency)</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[This data type is used to convey two pieces of information: The overall time-period when something occurred (or is to occur), as well as how often it should/did occur within that time-period]]></text>
            </annotation>
            <annotation annotationType="USAGE_NOTES">
               <text><![CDATA[SXPR_TS is the mechanism for implementing the GTS data type. Value is not permitted.]]></text>
            </annotation>
            <annotation annotationType="CONSTRAINT">
               <text><![CDATA[The first mandatory repetition must comply with the IVL<TS.FULLDATE> specification and indicates the overall timeperiod.  It must have an additional mandatory "operator" property with a value of "I" for intersection, indicating that the time of occurrence is the combination of both the outer time interval and the inner frequency.
The second mandatory repetition must comply with the PIVL<TS.DATETIME> specification and indicates the frequency.]]></text>
            </annotation>
         </documentation>
         <staticExampleEntry annotationType="STATIC_EXAMPLE" businessName="3 times/day beginning August 3rd 2005 for 3 weeks">
            <text><![CDATA[&lt;effectiveTime type=&apos;SXPR_TS&apos;&gt;
	&lt;comp type=&apos;IVL_TS&apos; operator=&apos;I&apos;&gt;
		&lt;low flavorId=&apos;TS.FULLDATE&apos; value=&apos;20050803&apos; type=&apos;TS&apos;/&gt;
		&lt;width unit=&apos;wk&apos; flavorId=&apos;TS.FULLDATE&apos; value=&apos;3&apos; type=&apos;TS&apos;/&gt;
	&lt;/comp&gt;
	&lt;comp type=&apos;PIVL_TS&apos;&gt;
		&lt;frequency&gt;
			&lt;numerator flavorId=&apos;INT.NONNEG&apos; value=&apos;3&apos; type=&apos;INT&apos;/&gt;
			&lt;denominator unit=&apos;d&apos; flavorId=&apos;PQ.TIME&apos; value=&apos;1&apos; type=&apos;PQ&apos;/&gt;
		&lt;/frequency&gt;
	&lt;/comp&gt;
&lt;/effectiveTime&gt;
]]></text>
         </staticExampleEntry>
         <parentDatatype isAbstract="false" name="GTS" businessName="GeneralTimingSpecification" visibility="public" superType="SET" isMerged="false">
            <documentation>
               <businessName>GeneralTimingSpecification</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
A set of points in time, specifying the timing of events and actions
and the cyclical validity-patterns that may exist for certain kinds of
information, such as phone numbers (evening, daytime), addresses (so
called "snowbirds," residing closer to the equator during winter and
farther from the equator during summer) and office hours.
    ]]></text>
               </annotation>
               <annotation annotationType="DESIGN_COMMENTS">
                  <text><![CDATA[
<p>
The GTS data type has the following aspects:
    </p>
<p>
                     &lt;li&gt;&lt;p&gt;&lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;SET&apos;/&gt;&lt;/object&gt;
&lt;&lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;TS&apos;/&gt;&lt;/object&gt;&gt;). From this aspect GTS answers
whether any given point in time falls in the schedule described by the
GTS value.&lt;/p&gt;&lt;/li&gt;
                     &lt;li&gt;&lt;p&gt;GTS as the combination of multiple periodic intervals of time. This
aspect describes how both simple and complex repeat-patterns are
specified with the GTS.&lt;/p&gt;&lt;/li&gt;
                     &lt;li&gt;&lt;p&gt;&lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;LIST&apos;/&gt;&lt;/object&gt;&lt;&lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;IVL&apos;/&gt;&lt;/object&gt;
&lt;&lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;TS&apos;/&gt;&lt;/object&gt;&gt;&gt;).
From this aspect, GTS can generate all occurrence intervals of an event or
action, or all validity periods for a fact.&lt;/p&gt;&lt;/li&gt;
                     &lt;li&gt;&lt;p&gt;GTS as an expression-syntax defined for a calendar. This aspect is the
GTS literal form.&lt;/p&gt;&lt;/li&gt;
                  </p>
<p>
In all cases the GTS is defined as a set of point in time (&lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;SET&apos;/&gt;&lt;/object&gt;
&lt;&lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;TS&apos;/&gt;&lt;/object&gt;&gt;). Using the set operations,
union, intersection and difference, more complex sets of time can be
constructed from simpler ones. Ultimately the building blocks from
which all GTS values are constructed are interval, periodic interval,
and event-related periodic interval. The construction of the GTS can
be specified in the literal form. No special data type structure is
defined that would generate a combination of simpler time-sets from a
given GTS value. While any implementation would have to contain such a
structured representation, it is not needed in order to exchange GTS
values given the literal form.&lt;object name=&apos;footnote&apos;&gt;The GTS is an example of a data type that is only defined
algebraically without giving any definition of a data structure that
might implement the behavior of such a data type. The algebraic
definition looks extremely simple, so that one might assume it is
incomplete. Since at this point we are relying entirely on the literal
form to represent GTS values, all the definition of data structur&lt;/object&gt;
				              </p>
<p>
The GTS data type is defined as using intervals, periodic intervals,
and event-related periodic intervals. Intervals of time have been
defined above
    </p>
<p>
A convex hull is the least interval that is a superset of all
occurrence intervals. As noted in , all
totally ordered sets have a convex hull. Because a GTS is a 
&lt;&gt; and because a 
&lt;&gt; is a totally ordered set, all
GTS values have a convex hull.
      
The convex hull of a GTS can less formally be called &quot;outer bound
interval&quot;. Thus, the convex hull of a GTS describes the absolute
beginning and end of the repeating schedule. For infinite repetitions
(e.g., a simple periodic interval) the convex hull has infinite
bounds.
      
						
						Convex Hull of a Schedule
					</p>
<p>
A  value is a generator of a sequence of time
intervals during which an event or activity occurs, or during which a
state is effective.
      
The nextTo-property maps to every point in
time t the greatest continuous subset (an &quot;occurrence
interval&quot;) v of the  value
S, where v is the interval closest to
t that begins later than t or that contains
t.
      
invariant(GTS S, TS t, IVL&lt;TS&gt; v) {
  v.equal(S.nextTo(t)).equal(
         S.contains(o)
    .and(forall(IVL&lt;TS&gt; u) where x.contains(u) {
           u.contains(v).implies(u.equal(v)); })
    .and(    v.contains(t)
         .or(forall(TS i) where t.lessOrEqual(i)
                           .and(i.lessThan(v.low)) {
               S.conatins(i).not; })));
};
      
The nextAfter-property maps to every point
in time t the greatest continuous subset (an &quot;occurrence
interval&quot;) v of the  value
S, where v is the interval closest to
t that begins later than t.
      
invariant(GTS S, TS t) where {
  S.contains(t).not
     .implies(S.nextAfter(t).equal(S.nextTo(t)));
  S.contains(t)
     .implies(S.nextAfter(t).equal(
            S.except(nextTo(t)).nextTo(t)));
};
      
A  value can be converted into a generic Sequence
of time intervals (&lt;&gt;)
of occurrence intervals.
      
invariant(GTS x) where x.isEmpty { ((LIST&lt;IVL&lt;TS&gt;&gt;)x).isEmpty; };

invariant(GTS x, IVL&lt;TS&gt; first)
    where x.notEmpty
     .and(x.hull.low.nonNull)
     .and(first.equal(x.nextTo(x.hull.low))
{
  ((LIST&lt;IVL&lt;TS&gt;&gt;)x).head.equal(first);
  ((LIST&lt;IVL&lt;TS&gt;&gt;)x).tail.equal(
             (LIST&lt;IVL&lt;TS&gt;&gt;)x.except(first));
};
      </p>
<p>
						
						Interleaving Schedules and Periodic Hull
					
For two  values A and B we
say that A interleaves B if their occurrence
intervals interleave on the time line. This concept is visualized in
Figure 15.
      
For the  values A and B
to interleave the occurrence intervals of both groups can be arranged
in pairs of corresponding occurrence intervals. It must further hold
that for all corresponding occurrence intervals a
&#8838; A and b &#8838; B,
a starts before b starts (or at the same
time) and b ends after a ends (or at the
same time).
      
The interleaves-relation holds when two schedules have the same
average frequency, and when the second schedule never &quot;outpaces&quot; the
first schedule. That is, no occurrence interval in the second schedule
may start before its corresponding occurrence interval in the first
schedule.
      
With two interleaving  values one can derive a
periodic hull such that the occurrence intervals of the periodic hull
is the convex hull of the corresponding occurrence intervals.
      
The periodic hull is important to construct two schedules by combining
 expressions. For example, to construct the periodic
interval from Memorial Day to Labor Day every year, one first needs to
set up the schedules M for Memorial Day (the last Monday
in May) and L for Labor Day (the first Monday in
September) and then combine these two schedules using the periodic
hull of M and L.
      
invariant(GTS A, B) where x.nonNull.and(y.nonNull) {
  A.interleaves(B).equal(
    forall(IVL&lt;TS&gt; a, b, c; TS t)
        where a.equal(A.nextTo(t))
         .and(b.equal(B.nextTo(a.low)))
         .and(c.equal(A.nextTo(b.high))) {
      b.equal(B.nextTo(a.high));
      a.low.lessOrEqual(b.low);
      c.equal(A.nextTo(b.high));
      c.equal(a).or(c.equal(A.nextAfter(a.high)));
    });
};
      
For two  values A and B
where A interleaves B, a periodic hull is
defined as the pair wise convex hull of the corresponding occurrence
intervals of A and B.
      
invariant(GTS A, B, C) where A.interleaves(B) {
  A.periodicHull(B).equal(C).equal(
    forall(IVL&lt;TS&gt; a, b; TS t)
        where a.equal(A.nextTo(t))
         .and(b.equal(B.nextTo(a.low))) {
      C.contains(c).equal(c.equal(a.hull(b)));
    });
};
      
The interleaves-relation is reflexive, asymmetric, and
intransitive. The periodic hull operation is non-commutative and
non-associative.
The interleaves property may appear overly constrained. However, these
constraints are reasonable for the use case for which the interleaves
and periodic hull properties are defined. To safely and predictably
combine two schedules one would want to know which of the operands
sets the start points and which sets the endpoints of the periodic
hull&apos;s occurrence intervals.
          
					</p>
]]></text>
               </annotation>
            </documentation>
         </parentDatatype>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="CD.LAB">
      <datatype isAbstract="false" name="CD.LAB" businessName="Coded Value (Lab)" visibility="public" superType="CD.UV" isMerged="false">
         <documentation>
            <businessName>Coded Value (Lab)</businessName>
            <annotation annotationType="USAGE_NOTES">
               <text><![CDATA[
<p>If the attribute or property is null, the codeSystem and originalTextproperties are still permitted but not &lt;i&gt;mandatory&lt;/i&gt;.</p>
<p>The rules for supporting the several properties vary depending on whether the element has a coding strength of CWE (Coded with extensibility) or CNE (Coded with no extensibility).</p>
<p>For CWE, &quot;code&quot;, &quot;codeSystem&quot; and &quot;originalText&quot; properties are required. A constraint exists that at least one of &quot;code&quot; and &quot;originalText&quot; must be present and non-null, and that if &quot;code&quot; is present, then &quot;codeSystem is mandatory.</p>
<p>For CNE, &quot;code&quot; and &quot;codeSystem&quot; are mandatory (meaning they must be non-null if the overall attribute or property is non-null). If the element is null with a flavor of OTH (Other), then the &quot;originalText&quot; property is mandatory (and no other properties may be specified).</p>
]]></text>
            </annotation>
         </documentation>
         <staticExampleEntry annotationType="STATIC_EXAMPLE" businessName="a diagnosis of moderate to severe psoriasis of the face with sudden onset">
            <text><![CDATA[&lt;value codeSystem=&apos;2.16.840.1.113883.6.96&apos; code=&apos;402320002&apos;&gt;
	&lt;originalText&gt;Acute, moderate facial psoriasis&lt;/originalText&gt;
	&lt;qualifier&gt;
		&lt;name codeSystem=&apos;2.16.840.1.113883.6.96&apos; code=&apos;246100006&apos;/&gt;
		&lt;value codeSystem=&apos;2.16.840.1.113883.6.96&apos; code=&apos;385315009&apos;/&gt;
	&lt;/qualifier&gt;
	&lt;qualifier&gt;
		&lt;name codeSystem=&apos;2.16.840.1.113883.6.96&apos; code=&apos;246112005&apos;/&gt;
		&lt;value codeSystem=&apos;2.16.840.1.113883.6.96&apos; code=&apos;371924009&apos;/&gt;
	&lt;/qualifier&gt;
&lt;/value&gt;
]]></text>
         </staticExampleEntry>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="IVL.HIGH_TS.FULLDATE">
      <datatype isAbstract="false" name="IVL.HIGH_TS.FULLDATE" businessName="Precise End Date" visibility="public" isMerged="false">
         <documentation>
            <businessName>Precise End Date</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[This data type is used when both a start and end date may exist, but only the end date should be captured. Does not allow for partial dates.]]></text>
            </annotation>
            <annotation annotationType="CONSTRAINT">
               <text><![CDATA[Start date is Unknown]]></text>
            </annotation>
         </documentation>
         <staticExampleEntry annotationType="STATIC_EXAMPLE" businessName="End, September 15, 2003">
            <text><![CDATA[&lt;effectiveTime type=&apos;IVL_TS&apos;&gt;
	&lt;high flavorId=&apos;TS.FULLDATE&apos; value=&apos;20030915-0430&apos; type=&apos;TS&apos;/&gt;
&lt;/effectiveTime&gt;
]]></text>
         </staticExampleEntry>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="ED">
      <datatype isAbstract="true" name="ED" businessName="Encapsulated Data" visibility="public" superType="BIN" isMerged="true">
         <documentation>
            <businessName>Encapsulated Data</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[
<p>This defines generic rules for all uses of the ED data type within Canada.</p>
<p>This data type may be referenced in Canadian specifications. If this data type is used in a message instance, it must be declared as one of the constrained version of ED (e.g. ED.DOC) for each repetition.</p>
]]></text>
            </annotation>
            <annotation annotationType="REQUIREMENTS">
               <text><![CDATA[Ballot comment #21]]></text>
            </annotation>
            <annotation annotationType="USAGE_CONSTRAINT">
               <text><![CDATA[If the content is compressed (the compression attribute is present), or if the content is a PDF document (mediaType="application/pdf"), then the content must be MIMEencoded. Otherwise, the content will be sent as directly embedded text or XML. (NOTE: This means that uncompressed HTML must be XHTML compliant.) Content is restricted to a maximum of 1 megabyte after compression and MIME encoding.]]></text>
            </annotation>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[
<p>
                     &lt;param name=&apos;datatypeName&apos; value=&apos;ED&apos;/&gt;
                  </p>
<p>
                     &lt;param name=&apos;datatypeName&apos; value=&apos;TEL&apos;/&gt;
                  </p>
<p>
                     &lt;param name=&apos;datatypeName&apos; value=&apos;ST&apos;/&gt;
                  </p>
<p>
                     &lt;param name=&apos;datatypeName&apos; value=&apos;ED&apos;/&gt;
                  </p>
<p>
                     &lt;param name=&apos;datatypeName&apos; value=&apos;ED&apos;/&gt;
                  </p>
]]></text>
            </annotation>
            <annotation annotationType="DESIGN_COMMENTS">
               <text><![CDATA[
<p>
Encapsulated data can be present in two forms, inline or by
reference. Inline data is communicated or moved as part of the
encapsulated data value, whereas by-reference data may reside at a
different (remote) location. The data is the same whether it is
located inline or remote.
    </p>
]]></text>
            </annotation>
         </documentation>
         <parentDatatype isAbstract="false" name="ED" businessName="EncapsulatedData" visibility="public" superType="BIN" isMerged="false">
            <documentation>
               <businessName>EncapsulatedData</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
<p>
                     &lt;param name=&apos;datatypeName&apos; value=&apos;ED&apos;/&gt;
                  </p>
<p>
                     &lt;param name=&apos;datatypeName&apos; value=&apos;TEL&apos;/&gt;
                  </p>
<p>
                     &lt;param name=&apos;datatypeName&apos; value=&apos;ST&apos;/&gt;
                  </p>
<p>
                     &lt;param name=&apos;datatypeName&apos; value=&apos;ED&apos;/&gt;
                  </p>
<p>
                     &lt;param name=&apos;datatypeName&apos; value=&apos;ED&apos;/&gt;
                  </p>
]]></text>
               </annotation>
               <annotation annotationType="DESIGN_COMMENTS">
                  <text><![CDATA[
<p>
Encapsulated data can be present in two forms, inline or by
reference. Inline data is communicated or moved as part of the
encapsulated data value, whereas by-reference data may reside at a
different (remote) location. The data is the same whether it is
located inline or remote.
    </p>
]]></text>
               </annotation>
            </documentation>
         </parentDatatype>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="IVL_TS.FULLDATE">
      <datatype isAbstract="false" name="IVL_TS.FULLDATE" businessName="Precise Date Range" visibility="public" isMerged="false">
         <documentation>
            <businessName>Precise Date Range</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[This data type is used when a date range needs to be conveyed with precise start and/or end dates]]></text>
            </annotation>
            <annotation annotationType="REQUIREMENTS">
               <text><![CDATA[Ballot comment #18]]></text>
            </annotation>
            <annotation annotationType="USAGE_CONSTRAINT">
               <text><![CDATA[When sending over the wire, a maximum of two of low, high and width should be sent.]]></text>
            </annotation>
            <annotation annotationType="CONSTRAINT">
               <text><![CDATA[Low, high and width cannot have null flavors PINF or NINF]]></text>
            </annotation>
            <annotation annotationType="CONSTRAINT">
               <text><![CDATA[At least two of high, low and width must be *present* (though they can be null flavors) for the URG to satisfy a 'mandatory' constraint.]]></text>
            </annotation>
         </documentation>
         <staticExampleEntry annotationType="STATIC_EXAMPLE" businessName="from March 01, 2000 to July 15, 2000">
            <text><![CDATA[&lt;effectiveTime type=&apos;IVL_TS&apos;&gt;
	&lt;low flavorId=&apos;TS.FULLDATE&apos; value=&apos;20000301&apos; type=&apos;TS&apos;/&gt;
	&lt;high flavorId=&apos;TS.FULLDATE&apos; value=&apos;20000715&apos; type=&apos;TS&apos;/&gt;
&lt;/effectiveTime&gt;
]]></text>
         </staticExampleEntry>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="IVL.WIDTH_TS.FULLDATE">
      <datatype isAbstract="false" name="IVL.WIDTH_TS.FULLDATE" businessName="Duration" visibility="public" isMerged="false">
         <documentation>
            <businessName>Duration</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[This data type is used to convey duration where the specific start and end days are not needed.]]></text>
            </annotation>
            <annotation annotationType="CONSTRAINT">
               <text><![CDATA[Start date and end date are Unknown]]></text>
            </annotation>
         </documentation>
         <staticExampleEntry annotationType="STATIC_EXAMPLE" businessName="23 days">
            <text><![CDATA[&lt;effectiveTime type=&apos;IVL_TS&apos;&gt;
	&lt;width unit=&apos;d&apos; flavorId=&apos;PQ.TIME&apos; value=&apos;23&apos; type=&apos;PQ&apos;/&gt;
&lt;/effectiveTime&gt;
]]></text>
         </staticExampleEntry>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="ED.DOCORREF">
      <datatype isAbstract="false" name="ED.DOCORREF" businessName="Encapsulated Data (Document or Reference)" visibility="public" superType="ED" isMerged="false">
         <documentation>
            <businessName>Encapsulated Data (Document or Reference)</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[This allows for the encapsulation of a document or reference to a document within the HL7 instance.]]></text>
            </annotation>
         </documentation>
         <parentDatatype isAbstract="false" name="ED" businessName="EncapsulatedData" visibility="public" superType="BIN" isMerged="false">
            <documentation>
               <businessName>EncapsulatedData</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
<p>
                     &lt;param name=&apos;datatypeName&apos; value=&apos;ED&apos;/&gt;
                  </p>
<p>
                     &lt;param name=&apos;datatypeName&apos; value=&apos;TEL&apos;/&gt;
                  </p>
<p>
                     &lt;param name=&apos;datatypeName&apos; value=&apos;ST&apos;/&gt;
                  </p>
<p>
                     &lt;param name=&apos;datatypeName&apos; value=&apos;ED&apos;/&gt;
                  </p>
<p>
                     &lt;param name=&apos;datatypeName&apos; value=&apos;ED&apos;/&gt;
                  </p>
]]></text>
               </annotation>
               <annotation annotationType="DESIGN_COMMENTS">
                  <text><![CDATA[
<p>
Encapsulated data can be present in two forms, inline or by
reference. Inline data is communicated or moved as part of the
encapsulated data value, whereas by-reference data may reside at a
different (remote) location. The data is the same whether it is
located inline or remote.
    </p>
]]></text>
               </annotation>
            </documentation>
         </parentDatatype>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="URG_PQ">
      <datatype isAbstract="false" name="URG_PQ" businessName="Uncertain Quantity" visibility="public" isMerged="false">
         <documentation>
            <businessName>Uncertain Quantity</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[
<p>This is used to express a single quantity whose specific value is not known, but whose upper and lower bounds are known. The URG data type already places implicit constraints on probability.  Outside the range, probability is 0, within the range, probability is unknown.</p>
<p>PQ.x implies any of the PQ.x data types in the specification (e.g. PQ.LAB, PQ.DISTANCE), not the PQ data type by itself.</p>
]]></text>
            </annotation>
         </documentation>
         <staticExampleEntry annotationType="STATIC_EXAMPLE" businessName="1 to 3">
            <text><![CDATA[&lt;value type=&apos;URG_PQ&apos;&gt;
	&lt;low flavorId=&apos;PQ.DRUG&apos; value=&apos;1&apos; type=&apos;PQ&apos;/&gt;
	&lt;high flavorId=&apos;PQ.DRUG&apos; value=&apos;3&apos; type=&apos;PQ&apos;/&gt;
&lt;/value&gt;
]]></text>
         </staticExampleEntry>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="TYPE">
      <datatype isAbstract="false" name="TYPE" businessName="DataType" visibility="private" superType="ANY" isMerged="false">
         <documentation>
            <businessName>DataType</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[
A meta-type declared in order to allow the formal definitions to speak
about the data type of a value. Any data type defined in this
specification is a value of the type DataType.
        ]]></text>
            </annotation>
         </documentation>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="URG_TS.DATE">
      <datatype isAbstract="false" name="URG_TS.DATE" businessName="Uncertain Date" visibility="public" isMerged="false">
         <documentation>
            <businessName>Uncertain Date</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[This data type is used when an occurrence is tied to a specific date, but the actual date is not known, merely the range of dates within which the date falls. This differs from IVL<TS.DATE> in that it refers to a single occurrence rather than a period covering multiple days.]]></text>
            </annotation>
            <annotation annotationType="USAGE_CONSTRAINT">
               <text><![CDATA[When sending over the wire, a maximum of two of low, high, center and width should be sent.]]></text>
            </annotation>
            <annotation annotationType="CONSTRAINT">
               <text><![CDATA[Low, high and width cannot have null flavors PINF or NINF]]></text>
            </annotation>
            <annotation annotationType="CONSTRAINT">
               <text><![CDATA[At least two of high, low, center and width must be *present* (though they can be null flavors) for the URG to satisfy a 'mandatory' constraint.]]></text>
            </annotation>
         </documentation>
         <staticExampleEntry annotationType="STATIC_EXAMPLE" businessName="April, 2004 +/- 2 months">
            <text><![CDATA[&lt;effectiveTime type=&apos;URG_TS&apos;&gt;
	&lt;center flavorId=&apos;TS.DATE&apos; value=&apos;200404&apos; type=&apos;TS&apos;/&gt;
	&lt;width unit=&apos;m&apos; flavorId=&apos;PQ.TIME&apos; value=&apos;4&apos; type=&apos;PQ&apos;/&gt;
&lt;/effectiveTime&gt;
]]></text>
         </staticExampleEntry>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="TEL.EMAIL">
      <datatype isAbstract="false" name="TEL.EMAIL" businessName="E-mail Address" visibility="public" superType="TEL" isMerged="false">
         <documentation>
            <businessName>E-mail Address</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[Allows e-mail addresses to be communicated.]]></text>
            </annotation>
            <annotation annotationType="REQUIREMENTS">
               <text><![CDATA[Ballot comment #32]]></text>
            </annotation>
         </documentation>
         <staticExampleEntry annotationType="STATIC_EXAMPLE" businessName="">
            <text><![CDATA[&lt;telecom flavorId=&apos;TEL.EMAIL&apos; value=&apos;mailto:someone@somewhere.com&apos; use=&apos;WP&apos; type=&apos;TEL&apos; url=&apos;mailto&apos;&gt;
	
&lt;/telecom&gt;
]]></text>
         </staticExampleEntry>
         <parentDatatype isAbstract="false" name="TEL" businessName="TelecommunicationAddress" visibility="public" superType="URL" isMerged="false">
            <documentation>
               <businessName>TelecommunicationAddress</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
A telephone number (voice or fax), e-mail address, or other locator
for a resource mediated by telecommunication equipment. The address is
specified as a Universal Resource Locator (URL) qualified by time
specification and use codes that help in deciding which address to use
for a given time and purpose.
    ]]></text>
               </annotation>
               <annotation annotationType="DESIGN_COMMENTS">
                  <text><![CDATA[
<p>
The semantics of a telecommunication address is that a communicating
entity (the responder) listens and responds to that address, and
therefore can be contacted by an other communicating entity (the
initiator.)
    </p>
<p>
The responder of a telecommunication address may be an automatic
service that can respond with information (e.g., FTP or HTTP
services.)  In such case a telecommunication address is a reference to
that information accessible through that address. A telecommunication
address value can thus be resolved to some information (in the form of
encapsulated data, &lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;ED&apos;/&gt;&lt;/object&gt;.)
    </p>
<p>
The telecommunication address is an extension of the Universal
Resource Locator (&lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;URL&apos;/&gt;&lt;/object&gt;) specified according to Internet
standard RFC 2396 [&lt;a href=&apos;http://www.ietf.org/rfc/rfc2396.txt&apos;/&gt;].
The &lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;URL&apos;/&gt;&lt;/object&gt; specifies the protocol and the contact point
defined by that protocol for the resource. Notable use cases for the
telecommunication address data type are for telephone and fax numbers,
e-mail addresses, Hypertext references, FTP references, etc.
    </p>
]]></text>
               </annotation>
            </documentation>
         </parentDatatype>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="ED.IMAGE">
      <datatype isAbstract="false" name="ED.IMAGE" businessName="Encapsulated Data (Image)" visibility="public" superType="ED" isMerged="false">
         <documentation>
            <businessName>Encapsulated Data (Image)</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[This allows for the encapsulation of a picture or other graphic within an attribute.]]></text>
            </annotation>
            <annotation annotationType="CONSTRAINT">
               <text><![CDATA[
<p>mandatory</p>
]]></text>
            </annotation>
         </documentation>
         <staticExampleEntry annotationType="STATIC_EXAMPLE" businessName="">
            <text><![CDATA[&lt;value flavorId=&apos;ED.IMAGE&apos; type=&apos;ED&apos; mediaType=&apos;img/jpeg&apos;&gt;
	/9j/4AAQSkZJRgABAQEAYABgAAD/2wBDAAgGBgcGBQgHBwcJCQgKDBQNDAsLDBkSEw8UHRofHh0aHBwgJC4nICIsIxwcKDcpLDAxNDQ0Hyc5PTgyPC4zNDL/2wBDAQkJCQwLDBgNDRgyIRwhMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjL/wAARCAALABMDASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwDr9d1XSfF2seH9R0vWvKhtpUDRy20sZnzd6dIow0WdpDREEbcl05278Fnb2t14Q8Fadf29jLqcf2GXS7m2gnud1vDJbNJLu8kNBuXAIbA+Zct1x5xb31xY33w+sraTy7WbULSF4go27Gh0qdgB/DmX5zjGWLE/eOafhTxfrkz/AA7eW7jd4dYl0mJmt4iUtdtmuxfl4O1mG4fNgkZ5oA9/g8c6LdW8VxbxazNBKgeOSPRL1ldSMggiLBBHOaK+LL69l1C8kupkgSR8ZEECQoMADhEAUdOw569aKAP/2Q==
&lt;/value&gt;
]]></text>
         </staticExampleEntry>
         <parentDatatype isAbstract="false" name="ED" businessName="EncapsulatedData" visibility="public" superType="BIN" isMerged="false">
            <documentation>
               <businessName>EncapsulatedData</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
<p>
                     &lt;param name=&apos;datatypeName&apos; value=&apos;ED&apos;/&gt;
                  </p>
<p>
                     &lt;param name=&apos;datatypeName&apos; value=&apos;TEL&apos;/&gt;
                  </p>
<p>
                     &lt;param name=&apos;datatypeName&apos; value=&apos;ST&apos;/&gt;
                  </p>
<p>
                     &lt;param name=&apos;datatypeName&apos; value=&apos;ED&apos;/&gt;
                  </p>
<p>
                     &lt;param name=&apos;datatypeName&apos; value=&apos;ED&apos;/&gt;
                  </p>
]]></text>
               </annotation>
               <annotation annotationType="DESIGN_COMMENTS">
                  <text><![CDATA[
<p>
Encapsulated data can be present in two forms, inline or by
reference. Inline data is communicated or moved as part of the
encapsulated data value, whereas by-reference data may reside at a
different (remote) location. The data is the same whether it is
located inline or remote.
    </p>
]]></text>
               </annotation>
            </documentation>
         </parentDatatype>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="REAL.CONF">
      <datatype isAbstract="false" name="REAL.CONF" businessName="Real Number (Confidence)" visibility="public" superType="REAL" isMerged="false">
         <documentation>
            <businessName>Real Number (Confidence)</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[A real number intended for use in conveying confidence level values in registries]]></text>
            </annotation>
            <annotation annotationType="CONSTRAINT">
               <text><![CDATA[Maximum length is restricted to 9 characters with 4 characters before the decimal and 4 characters after the decimal]]></text>
            </annotation>
         </documentation>
         <staticExampleEntry annotationType="STATIC_EXAMPLE" businessName="A confidence level value from a registry of .2895">
            <text><![CDATA[&lt;value flavorId=&apos;REAL.CONF&apos; value=&apos;0.2895&apos; type=&apos;REAL&apos;&gt;
	
&lt;/value&gt;
]]></text>
         </staticExampleEntry>
         <parentDatatype isAbstract="false" name="REAL" businessName="RealNumber" visibility="public" superType="QTY" isMerged="false">
            <documentation>
               <businessName>RealNumber</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
Fractional numbers. Typically used whenever quantities are measured,
estimated, or computed from other real numbers.  The typical
representation is decimal, where the number of significant decimal
digits is known as the precision.
    ]]></text>
               </annotation>
               <annotation annotationType="DESIGN_COMMENTS">
                  <text><![CDATA[
<p>
The term &quot;Real number&quot; in this specification is used to mean that
fractional values are covered without necessarily implying the full
set of the mathematical real numbers that would include irrational
numbers such as &#961;, Euler&apos;s number, etc.&lt;object name=&apos;footnote&apos;&gt;The term &quot;Real&quot; for a fractional number data type originates and is
well established in the Algol, Pascal tradition of programming
languages.&lt;/object&gt;
				              </p>
<p>
This specification offers two choices for a number data type. The
choice is made as follows: Any number attribute is a real if it is not
known for sure that it is an integer. A number is an integer if it is
&lt;b&gt;always&lt;/b&gt; counted, typically representing an ordinal
number. If there are conceivable use cases where such a number would
be estimated or averaged, it is not always an integer and thus should
use the Real data type.
    </p>
<p>
The algebraic operations are specified here as characterizing
operations in the sense of ISO 11404, and because these operations are
needed in other parts of this specification.
    </p>
<p>
Unlike the integer numbers, the real numbers semantics are not
inductively constructed but only intuitively described by their axioms
of their algebraic properties. The completeness axioms are
intentionally left out so as to make no statement about irrational
numbers.
    </p>
]]></text>
               </annotation>
            </documentation>
         </parentDatatype>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="PN.SIMPLE">
      <datatype isAbstract="false" name="PN.SIMPLE" businessName="Simple Person Name" visibility="public" superType="PN" isMerged="false">
         <documentation>
            <businessName>Simple Person Name</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[Used to express person names without name parts.]]></text>
            </annotation>
            <annotation annotationType="REQUIREMENTS">
               <text><![CDATA[Ballot comment #42]]></text>
            </annotation>
            <annotation annotationType="CONSTRAINT">
               <text><![CDATA[The names are to be expressed as a simple string with parts not distinguished.  Systems are expected to be able to support names entered or transmitted in this format, though discrete name parts should be captured whenever feasible.]]></text>
            </annotation>
         </documentation>
         <staticExampleEntry annotationType="STATIC_EXAMPLE" businessName="">
            <text><![CDATA[&lt;name flavorId=&apos;PN.SIMPLE&apos; use=&apos;L&apos; type=&apos;PN&apos;&gt;
	Mr. John W. Smith
&lt;/name&gt;
]]></text>
         </staticExampleEntry>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="MO.CAD">
      <datatype isAbstract="false" name="MO.CAD" businessName="Canadian Money" visibility="public" superType="MO" isMerged="false">
         <documentation>
            <businessName>Canadian Money</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[Used to convey monetary values in Canadian currency]]></text>
            </annotation>
         </documentation>
         <staticExampleEntry annotationType="STATIC_EXAMPLE" businessName="137 dollars, 15 cents Canadian">
            <text><![CDATA[&lt;amt flavorId=&apos;MO.CAD&apos; value=&apos;137.15&apos; type=&apos;MO&apos; currency=&apos;CAD&apos;&gt;
	
&lt;/amt&gt;
]]></text>
         </staticExampleEntry>
         <parentDatatype isAbstract="false" name="MO" businessName="MonetaryAmount" visibility="public" superType="QTY" isMerged="false">
            <documentation>
               <businessName>MonetaryAmount</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
A monetary amount is a quantity expressing the amount of money in some
currency. Currencies are the units in which monetary amounts are
denominated in different economic regions. While the monetary amount
is a single kind of quantity (money) the exchange rates between the
different units are variable.  This is the principle difference
between physical quantity and monetary amounts, and the reason why
currency units are not physical units.
    ]]></text>
               </annotation>
            </documentation>
         </parentDatatype>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="PQ.TIME">
      <datatype isAbstract="false" name="PQ.TIME" businessName="Time Quantity" visibility="public" superType="PQ" isMerged="false">
         <documentation>
            <businessName>Time Quantity</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[Used to convey quantities of drug products.]]></text>
            </annotation>
         </documentation>
         <staticExampleEntry annotationType="STATIC_EXAMPLE" businessName="14 days">
            <text><![CDATA[&lt;width unit=&apos;d&apos; flavorId=&apos;PQ.TIME&apos; value=&apos;14&apos; type=&apos;PQ&apos;&gt;
	
&lt;/width&gt;
]]></text>
         </staticExampleEntry>
         <parentDatatype isAbstract="false" name="PQ" businessName="PhysicalQuantity" visibility="public" superType="QTY" isMerged="false">
            <documentation>
               <businessName>PhysicalQuantity</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
A dimensioned quantity expressing the result of measuring.
    ]]></text>
               </annotation>
            </documentation>
         </parentDatatype>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="REAL.COORD">
      <datatype isAbstract="false" name="REAL.COORD" businessName="Real Number (Coordinate)" visibility="public" superType="REAL" isMerged="false">
         <documentation>
            <businessName>Real Number (Coordinate)</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[A real number intended for use in conveying geographic coordinate values]]></text>
            </annotation>
            <annotation annotationType="CONSTRAINT">
               <text><![CDATA[Maximum length is restricted to 9 characters with 4 characters before the decimal and 4 characters after the decimal]]></text>
            </annotation>
         </documentation>
         <staticExampleEntry annotationType="STATIC_EXAMPLE" businessName="">
            <text><![CDATA[&lt;value flavorId=&apos;REAL.COORD&apos; value=&apos;137.2895&apos; type=&apos;REAL&apos;&gt;
	
&lt;/value&gt;
]]></text>
         </staticExampleEntry>
         <parentDatatype isAbstract="false" name="REAL" businessName="RealNumber" visibility="public" superType="QTY" isMerged="false">
            <documentation>
               <businessName>RealNumber</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
Fractional numbers. Typically used whenever quantities are measured,
estimated, or computed from other real numbers.  The typical
representation is decimal, where the number of significant decimal
digits is known as the precision.
    ]]></text>
               </annotation>
               <annotation annotationType="DESIGN_COMMENTS">
                  <text><![CDATA[
<p>
The term &quot;Real number&quot; in this specification is used to mean that
fractional values are covered without necessarily implying the full
set of the mathematical real numbers that would include irrational
numbers such as &#961;, Euler&apos;s number, etc.&lt;object name=&apos;footnote&apos;&gt;The term &quot;Real&quot; for a fractional number data type originates and is
well established in the Algol, Pascal tradition of programming
languages.&lt;/object&gt;
				              </p>
<p>
This specification offers two choices for a number data type. The
choice is made as follows: Any number attribute is a real if it is not
known for sure that it is an integer. A number is an integer if it is
&lt;b&gt;always&lt;/b&gt; counted, typically representing an ordinal
number. If there are conceivable use cases where such a number would
be estimated or averaged, it is not always an integer and thus should
use the Real data type.
    </p>
<p>
The algebraic operations are specified here as characterizing
operations in the sense of ISO 11404, and because these operations are
needed in other parts of this specification.
    </p>
<p>
Unlike the integer numbers, the real numbers semantics are not
inductively constructed but only intuitively described by their axioms
of their algebraic properties. The completeness axioms are
intentionally left out so as to make no statement about irrational
numbers.
    </p>
]]></text>
               </annotation>
            </documentation>
         </parentDatatype>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="ANY.CA.IZ">
      <datatype isAbstract="true" name="ANY.CA.IZ" businessName="Immunization result types" visibility="public" superType="ANY" isMerged="false">
         <documentation>
            <businessName>Immunization result types</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[Used in a specification where the specific types to be communicated may vary.]]></text>
            </annotation>
            <annotation annotationType="USAGE_NOTES">
               <text><![CDATA[
<p>This data type may be referenced in Canadian specifications.  If this data type is used in a message instance, it must be declared as one of the constrained version of ANY (e.g. ST) for each repetition.</p>
<p>The specific data type must be declared using xsi:type.</p>
]]></text>
            </annotation>
         </documentation>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="EIVL">
      <datatype isAbstract="false" name="EIVL" businessName="EventRelatedPeriodicInterval" visibility="public" superType="SET" isMerged="false">
         <documentation>
            <businessName>EventRelatedPeriodicInterval</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[
Specifies a periodic interval of time where the recurrence is based on
activities of daily living or other important events that are
time-related but not fully determined by time.
    ]]></text>
            </annotation>
            <annotation annotationType="DESIGN_COMMENTS">
               <text><![CDATA[
<p>
For example, &quot;one hour after breakfast&quot; specifies the beginning of the
interval at one hour after breakfast is finished. Breakfast is assumed
to occur before lunch but is not determined to occur at any specific
time.
    </p>
<p>
An event-related periodic interval of time is a set of time, that is,
one can test whether a particular time or time interval is an element
of the set. Whether an event-related periodic interval of time
contains a given interval of time is decided using a relation event
&#967; time referred to as EVENT(event,
time). The property occurrenceAt(t) is the
occurrence interval that would exist if the event occurred at time
t.
      
invariant(EIVL&lt;T&gt; x, T eventTime, IVL&lt;T&gt; v)
     where v.equal(x.occurrenceAt(eventTime)) {
  v.low.equal(eventTime.plus(x.offset.low));
  v.high.equal(eventTime.plus(x.offset.high));
  v.lowClosed.equal(x.offset.lowClosed);
  v.highClosed.equal(x.offset.highClosed);
};
      
Thus, an event related interval of time contains a point in time
t if there is an event time e with an
occurrence interval v such that v contains
t.
      
invariant(EIVL&lt;T&gt; x, T y) {
  x.contains(y).equal(exists(T e, IVL&lt;T&gt; v)
                           where EVENT(x.event, y)
                            .and(v.resolvedAt(y)) {
                         v.contains(y);
                       });
};
      </p>
]]></text>
            </annotation>
         </documentation>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="MO">
      <datatype isAbstract="false" name="MO" businessName="MonetaryAmount" visibility="public" superType="QTY" isMerged="false">
         <documentation>
            <businessName>MonetaryAmount</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[
A monetary amount is a quantity expressing the amount of money in some
currency. Currencies are the units in which monetary amounts are
denominated in different economic regions. While the monetary amount
is a single kind of quantity (money) the exchange rates between the
different units are variable.  This is the principle difference
between physical quantity and monetary amounts, and the reason why
currency units are not physical units.
    ]]></text>
            </annotation>
         </documentation>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="II.OID">
      <datatype isAbstract="false" name="II.OID" businessName="Instance Identifier (OID)" visibility="public" superType="II" isMerged="false">
         <documentation>
            <businessName>Instance Identifier (OID)</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[Used where an identifier is known to be constrained to only be an OID.  E.g. Conformance profile identifiers]]></text>
            </annotation>
         </documentation>
         <staticExampleEntry annotationType="STATIC_EXAMPLE" businessName="A profile id representing a jurisdictional conformance profile">
            <text><![CDATA[&lt;id root=&apos;2.16.840.1.113883.19.335.15.8885.21197&apos;&gt;
	
&lt;/id&gt;
]]></text>
         </staticExampleEntry>
         <parentDatatype isAbstract="false" name="II" businessName="InstanceIdentifier" visibility="public" superType="ANY" isMerged="false">
            <documentation>
               <businessName>InstanceIdentifier</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
An identifier that uniquely identifies a thing or object. Examples
are object identifier for HL7 RIM objects, medical record number,
order id, service catalog item id, Vehicle Identification Number
(VIN), etc. Instance identifiers are defined based on ISO object
identifiers.
    ]]></text>
               </annotation>
            </documentation>
         </parentDatatype>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="EN">
      <datatype isAbstract="false" name="EN" businessName="EntityName" visibility="public" superType="LIST" isMerged="false">
         <documentation>
            <businessName>EntityName</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[
A name for a person, organization, place or thing. A sequence of name
parts, such as given name or family name, prefix, suffix, etc.
Examples for entity name values are "Jim Bob Walton, Jr.", "Health
Level Seven, Inc.", "Lake Tahoe", etc. An entity name may be as simple
as a character string or may consist of several entity name parts,
such as, "Jim", "Bob", "Walton", and "Jr.", "Health Level Seven" and
"Inc.", "Lake" and "Tahoe".
    ]]></text>
            </annotation>
            <annotation annotationType="DESIGN_COMMENTS">
               <text><![CDATA[
<p>
Entity names are conceptualized as text with added logical mark-up.
Name parts occur in a natural order in which they would be displayed,
as opposed to in a order detemined by name part. The ordeing of the
name parts is significant a feature that replaces the need for a
separate &quot;display name&quot; property. Applications may change that
ordering of name parts to account for their user&apos;s customary ordering
of name parts. The approach is similar to HTML or XML markup of text
(but it is not technically limited to XML representations.)
    </p>
<p>
Entity names are essentially sequences of entity name parts, but add a
&quot;use&quot; code and a valid time range for information about when the name
was used and how to choose between multiple aliases that may be valid
at the same point in time.
    </p>
<p>
Three restrictions to Entity Name are defined in order to allow making
specific constraints for certain kinds of entities, trivial name
(&lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;TN&apos;/&gt;&lt;/object&gt;), person name (&lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;PN&apos;/&gt;&lt;/object&gt;), and
organization name (&lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;ON&apos;/&gt;&lt;/object&gt;).
    </p>
<p>
A very simple encoding of  &quot;Adam A. Everyman&quot; would be:
      

  Adam
  A.
  Everyman

					
None of the special qualifiers need to be mentioned if they are
unknown or irrelevant. The next example shows extensive use of
multiple given names, prefixes, suffixes, for academic degrees,
nobility titles, vorvoegsels (&quot;van&quot;), and professional
designations.
      

  Dr. phil. 
  Regina
  Johanna
  Maria
  Gr&#228;fin 
  Hochheim-Weilenfels
  NCFSA


The next example is an organization name, &quot;Health Level Seven, Inc.&quot;
in simple string form:
      
Health Level Seven, Inc.
					
and as a fully parsed name
      
Health Level Seven, Inc.

					
The following example shows a Japanese name in the three forms:
ideographic (Kanji), syllabic (Hiragana), and alphabetic (Romaji).
      

  &#26408;&#26449;
  &#36890;&#30007;


  &#12365;&#12416;&#12425;
  &#12415;&#12385;&#12362;


  KIMURA
  MICHIO

					</p>
]]></text>
            </annotation>
         </documentation>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="IVL.LOW_TS.FULLDATE">
      <datatype isAbstract="false" name="IVL.LOW_TS.FULLDATE" businessName="Precise Start Date" visibility="public" isMerged="false">
         <documentation>
            <businessName>Precise Start Date</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[Used to convey the start date of a range only. Does not allow for partial dates.]]></text>
            </annotation>
            <annotation annotationType="CONSTRAINT">
               <text><![CDATA[End date is Unknown]]></text>
            </annotation>
         </documentation>
         <staticExampleEntry annotationType="STATIC_EXAMPLE" businessName="Begin July 6, 2005">
            <text><![CDATA[&lt;effectiveTime type=&apos;IVL_TS&apos;&gt;
	&lt;low flavorId=&apos;TS.FULLDATE&apos; value=&apos;20050706-0800&apos; type=&apos;TS&apos;/&gt;
&lt;/effectiveTime&gt;
]]></text>
         </staticExampleEntry>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="CD.TRANS">
      <datatype isAbstract="false" name="CD.TRANS" businessName="Coded Value" visibility="private" superType="CD.UV" isMerged="false">
         <documentation>
            <businessName>Coded Value</businessName>
            <annotation annotationType="USAGE_NOTES">
               <text><![CDATA[
<p>If the attribute or property is null, the codeSystem and originalTextproperties are still permitted but not &lt;i&gt;mandatory&lt;/i&gt;.</p>
<p>The rules for supporting the several properties vary depending on whether the element has a coding strength of CWE (Coded with extensibility) or CNE (Coded with no extensibility).</p>
<p>For CWE, &quot;code&quot;, &quot;codeSystem&quot; and &quot;originalText&quot; properties are required. A constraint exists that at least one of &quot;code&quot; and &quot;originalText&quot; must be present and non-null, and that if &quot;code&quot; is present, then &quot;codeSystem is mandatory.</p>
<p>For CNE, &quot;code&quot; and &quot;codeSystem&quot; are mandatory (meaning they must be non-null if the overall attribute or property is non-null). If the element is null with a flavor of OTH (Other), then the &quot;originalText&quot; property is mandatory (and no other properties may be specified).</p>
]]></text>
            </annotation>
         </documentation>
         <staticExampleEntry annotationType="STATIC_EXAMPLE" businessName="a diagnosis of moderate to severe psoriasis of the face with sudden onset">
            <text><![CDATA[&lt;value codeSystem=&apos;2.16.840.1.113883.6.96&apos; code=&apos;402320002&apos;&gt;
	&lt;originalText&gt;Acute, moderate facial psoriasis&lt;/originalText&gt;
	&lt;qualifier&gt;
		&lt;name codeSystem=&apos;2.16.840.1.113883.6.96&apos; code=&apos;246100006&apos;/&gt;
		&lt;value codeSystem=&apos;2.16.840.1.113883.6.96&apos; code=&apos;385315009&apos;/&gt;
	&lt;/qualifier&gt;
	&lt;qualifier&gt;
		&lt;name codeSystem=&apos;2.16.840.1.113883.6.96&apos; code=&apos;246112005&apos;/&gt;
		&lt;value codeSystem=&apos;2.16.840.1.113883.6.96&apos; code=&apos;371924009&apos;/&gt;
	&lt;/qualifier&gt;
&lt;/value&gt;
]]></text>
         </staticExampleEntry>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="IVL.LOW">
      <datatype isAbstract="false" name="IVL.LOW" businessName="Low value" visibility="protected" superType="IVL" isMerged="false">
         <documentation>
            <businessName>Low value</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[Used to convey an interval where only the lower bound is unknown.]]></text>
            </annotation>
            <annotation annotationType="CONSTRAINT">
               <text><![CDATA[End value is Unknown]]></text>
            </annotation>
         </documentation>
         <parentDatatype isAbstract="false" name="IVL" businessName="Interval" visibility="public" superType="SET" isMerged="false">
            <documentation>
               <businessName>Interval</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
A set of consecutive values of an ordered base data type.
    ]]></text>
               </annotation>
               <annotation annotationType="DESIGN_COMMENTS">
                  <text><![CDATA[
<p>
Any ordered type can be the basis of an interval; it does not matter
whether the base type is discrete or continuous. If the base data type
is only partially ordered, all elements of the interval must be
elements of a totally ordered subset of the partially ordered data
type.
    </p>
<p>
For example, physical quantities are considered ordered. However the
ordering of physical quantities is only partial; a total order is only
defined among comparable quantities (quantities of the same physical
dimension.)  While intervals between 2 and 4 meter exists, there is no
interval between 2 meters and 4 seconds.
    </p>
<p>
Intervals are sets and have all the properties of sets. However, union
and differences of intervals may not be intervals any more, since the
elements of these union and difference sets might not be
contiguous. Intersections of intervals are always intervals.
    </p>
]]></text>
               </annotation>
            </documentation>
         </parentDatatype>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="IVL.LOW_TS.DATE">
      <datatype isAbstract="false" name="IVL.LOW_TS.DATE" businessName="Partial Start Date" visibility="public" isMerged="false">
         <documentation>
            <businessName>Partial Start Date</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[Used to convey the start date of a range only. Allows for partial dates.]]></text>
            </annotation>
            <annotation annotationType="CONSTRAINT">
               <text><![CDATA[End date is Unknown]]></text>
            </annotation>
         </documentation>
         <staticExampleEntry annotationType="STATIC_EXAMPLE" businessName="Began July, 2005">
            <text><![CDATA[&lt;effectiveTime type=&apos;IVL_TS&apos;&gt;
	&lt;low flavorId=&apos;TS.DATE&apos; value=&apos;200507&apos; type=&apos;TS&apos;/&gt;
&lt;/effectiveTime&gt;
]]></text>
         </staticExampleEntry>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="TS.DATETIME">
      <datatype isAbstract="false" name="TS.DATETIME" businessName="DateTime" visibility="public" superType="TS" isMerged="false">
         <documentation>
            <businessName>DateTime</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[Only permits the "date" and "time" portion of the timestamp to be specified. Does allow for partial dates and partial time, but timezone is mandatory if time is specified.]]></text>
            </annotation>
            <annotation annotationType="USAGE_NOTES">
               <text><![CDATA[
<p>The string literal representation of this form is YYYY[MM[DD[hh[mm[ss]]]]][+/-ZZZZ].</p>
<p>Partial dates may be specified only if no time component is specified</p>
<p>Dates and times (or portions) specified must be valid dates and times.</p>
]]></text>
            </annotation>
            <annotation annotationType="CONSTRAINT">
               <text><![CDATA[If the time is specified, the "timezone" portion of the timestamp must be specified]]></text>
            </annotation>
            <annotation annotationType="CONSTRAINT">
               <text><![CDATA[If the value is not null, there SHALL be 14 or less digits, and there can be a timezone. This flavor is specific to the gregorian calendar.]]></text>
            </annotation>
         </documentation>
         <staticExampleEntry annotationType="STATIC_EXAMPLE" businessName="">
            <text><![CDATA[&lt;effectiveTime flavorId=&apos;TS.DATETIME&apos; value=&apos;200508021730-0800&apos; type=&apos;TS&apos;&gt;
	
&lt;/effectiveTime&gt;
]]></text>
         </staticExampleEntry>
         <parentDatatype isAbstract="false" name="TS" businessName="PointInTime" visibility="public" superType="QTY" isMerged="false">
            <documentation>
               <businessName>PointInTime</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
A quantity specifying a point on the axis of natural time. A point
in time is most often represented as a calendar expression.
    ]]></text>
               </annotation>
               <annotation annotationType="DESIGN_COMMENTS">
                  <text><![CDATA[
<p>
Semantically, however, time is independent from calendars and best
described by its relationship to elapsed time (measured as a physical
quantity in the dimension of time.)  A point in time plus an elapsed
time yields another point in time.  Inversely, a point in time minus
another point in time yields an elapsed time.
    </p>
<p>
As nobody knows when time began, a point in time is conceptualized as
the amount of time that has elapsed from some arbitrary zero-point,
called an epoch.  Because there is no absolute zero-point on the time
axis natural time is a difference-scale quantity, where only
differences are defined but no ratios. (For example, no point in time
is &#8212; absolutely speaking &#8212; &quot;twice as late&quot; as another
point in time.)
    </p>
<p>
Given some arbitrary zero-point, one can express any point in time as
an elapsed time measured from that offset. Such an arbitrary
zero-point is called an epoch. This epoch-offset form is used as a
semantic representation here, without implying that any system would
have to implement the TS data type in that way. Systems that do not
need to compute distances between points in time will not need any
other representation than a calendar expression literal.
    </p>
]]></text>
               </annotation>
            </documentation>
         </parentDatatype>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="ED.DOC">
      <datatype isAbstract="false" name="ED.DOC" businessName="Encapsulated Data (Document)" visibility="public" superType="ED" isMerged="false">
         <documentation>
            <businessName>Encapsulated Data (Document)</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[This allows for the encapsulation of a document within an attribute.]]></text>
            </annotation>
            <annotation annotationType="REQUIREMENTS">
               <text><![CDATA[Ballot comment #30]]></text>
            </annotation>
            <annotation annotationType="CONSTRAINT">
               <text><![CDATA[
<p>mandatory</p>
]]></text>
            </annotation>
         </documentation>
         <staticExampleEntry annotationType="STATIC_EXAMPLE" businessName="HTML content">
            <text><![CDATA[&lt;text flavorId=&apos;ED.DOC&apos; type=&apos;ED&apos; language=&apos;fre&apos; mediaType=&apos;text/html&apos;&gt;
	&lt;html&gt;. . .&lt;/html&gt;
&lt;/text&gt;
]]></text>
         </staticExampleEntry>
         <parentDatatype isAbstract="false" name="ED" businessName="EncapsulatedData" visibility="public" superType="BIN" isMerged="false">
            <documentation>
               <businessName>EncapsulatedData</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
<p>
                     &lt;param name=&apos;datatypeName&apos; value=&apos;ED&apos;/&gt;
                  </p>
<p>
                     &lt;param name=&apos;datatypeName&apos; value=&apos;TEL&apos;/&gt;
                  </p>
<p>
                     &lt;param name=&apos;datatypeName&apos; value=&apos;ST&apos;/&gt;
                  </p>
<p>
                     &lt;param name=&apos;datatypeName&apos; value=&apos;ED&apos;/&gt;
                  </p>
<p>
                     &lt;param name=&apos;datatypeName&apos; value=&apos;ED&apos;/&gt;
                  </p>
]]></text>
               </annotation>
               <annotation annotationType="DESIGN_COMMENTS">
                  <text><![CDATA[
<p>
Encapsulated data can be present in two forms, inline or by
reference. Inline data is communicated or moved as part of the
encapsulated data value, whereas by-reference data may reside at a
different (remote) location. The data is the same whether it is
located inline or remote.
    </p>
]]></text>
               </annotation>
            </documentation>
         </parentDatatype>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="ADXP.BASIC">
      <datatype isAbstract="false" name="ADXP.BASIC" businessName="Address Part Basic" visibility="protected" superType="ADXP" isMerged="false">
         <documentation>
            <businessName>Address Part Basic</businessName>
            <annotation annotationType="USAGE_NOTES">
               <text><![CDATA[
<p>Use of ISO-3166-1 (alpha-3) is not permitted with this specification (alpha-2 is the only coding system suggested).  Using multiple methods (aplha-2, alpha-3 or numeric) would require implementors to support all methods.  The alpha-2 approach was used to be consistent with Canada Post.</p>
<p>
							&lt;li&gt;For example, Canada would be &quot;CA&quot; and British Columbia would be &quot;BC&quot;.  These are the same codes used by Canada Post.&lt;/li&gt;
							&lt;li&gt;&lt;a href=&apos;http://en.wikipedia.org/wiki/ISO_3166-1&apos;/&gt;.&lt;/li&gt;
						</p>
]]></text>
            </annotation>
            <annotation annotationType="CONSTRAINT">
               <text><![CDATA[Both address parts and delimiter-separated text are constrained to a length of 80 characters.]]></text>
            </annotation>
            <annotation annotationType="CONSTRAINT">
               <text><![CDATA[For country and state address parts, coded values are optional (taking advantages of the SC data type)]]></text>
            </annotation>
            <annotation annotationType="CONSTRAINT">
               <text><![CDATA[For country, code is restricted to ISO 3166-1 2-character alpha codes]]></text>
            </annotation>
            <annotation annotationType="CONSTRAINT">
               <text><![CDATA[For state, code is restricted to ISO 3166-2 code suffixes]]></text>
            </annotation>
         </documentation>
         <parentDatatype isAbstract="false" name="ADXP" businessName="AddressPart" visibility="protected" superType="SC" isMerged="false">
            <documentation>
               <businessName>AddressPart</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
A character string that may have a type-tag signifying its role in the
address. Typical parts that exist in about every address are street,
house number, or post box, postal code, city, country but other roles
may be defined regionally, nationally, or on an enterprise level
(e.g. in military addresses). Addresses are usually broken up into
lines, which are indicated by special line-breaking delimiter elements
(e.g., DEL).
    ]]></text>
               </annotation>
            </documentation>
         </parentDatatype>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="TS.DATE">
      <datatype isAbstract="false" name="TS.DATE" businessName="Timestamp (Date Only, Partial Date Allowed)" visibility="public" superType="TS" isMerged="false">
         <documentation>
            <businessName>Timestamp (Date Only, Partial Date Allowed)</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[Only permits the "date" portion of the timestamp to be specified. Allows for partial dates.]]></text>
            </annotation>
            <annotation annotationType="USAGE_NOTES">
               <text><![CDATA[
<p>The string literal representation of this form is YYYY[MM[DD]].</p>
<p>Dates (or portions) specified must be valid dates.</p>
]]></text>
            </annotation>
            <annotation annotationType="CONSTRAINT">
               <text><![CDATA[Timezone is not allowed, the precision is 8 or less and the calendar is fixed to be Gregorian]]></text>
            </annotation>
         </documentation>
         <staticExampleEntry annotationType="STATIC_EXAMPLE" businessName="">
            <text><![CDATA[&lt;effectiveTime flavorId=&apos;TS.DATE&apos; value=&apos;200508&apos; type=&apos;TS&apos;&gt;
	
&lt;/effectiveTime&gt;
]]></text>
         </staticExampleEntry>
         <parentDatatype isAbstract="false" name="TS" businessName="PointInTime" visibility="public" superType="QTY" isMerged="false">
            <documentation>
               <businessName>PointInTime</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
A quantity specifying a point on the axis of natural time. A point
in time is most often represented as a calendar expression.
    ]]></text>
               </annotation>
               <annotation annotationType="DESIGN_COMMENTS">
                  <text><![CDATA[
<p>
Semantically, however, time is independent from calendars and best
described by its relationship to elapsed time (measured as a physical
quantity in the dimension of time.)  A point in time plus an elapsed
time yields another point in time.  Inversely, a point in time minus
another point in time yields an elapsed time.
    </p>
<p>
As nobody knows when time began, a point in time is conceptualized as
the amount of time that has elapsed from some arbitrary zero-point,
called an epoch.  Because there is no absolute zero-point on the time
axis natural time is a difference-scale quantity, where only
differences are defined but no ratios. (For example, no point in time
is &#8212; absolutely speaking &#8212; &quot;twice as late&quot; as another
point in time.)
    </p>
<p>
Given some arbitrary zero-point, one can express any point in time as
an elapsed time measured from that offset. Such an arbitrary
zero-point is called an epoch. This epoch-offset form is used as a
semantic representation here, without implying that any system would
have to implement the TS data type in that way. Systems that do not
need to compute distances between points in time will not need any
other representation than a calendar expression literal.
    </p>
]]></text>
               </annotation>
            </documentation>
         </parentDatatype>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="PIVL">
      <datatype isAbstract="false" name="PIVL" businessName="PeriodicIntervalOfTime" visibility="public" superType="SET" isMerged="false">
         <documentation>
            <businessName>PeriodicIntervalOfTime</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[
An interval of time that recurs periodically. Periodic intervals have
two properties, phase and period. The phase specifies the "interval
prototype" that is repeated every period.
    ]]></text>
            </annotation>
            <annotation annotationType="DESIGN_COMMENTS">
               <text><![CDATA[
<p>
For example, &quot;every eight hours for two minutes&quot; is a periodic
interval where the interval&apos;s width equals 2 minutes and the period
at which the interval recurs equals 8 hours.
    </p>
<p>
The phase also marks the anchor point in time for the entire series of
periodically recurring intervals. The recurrence of a periodic interval has no
beginning or ending, but is infinite in both future and past.
    </p>
<p>
A periodic interval is fully specified when both the period and the
phase are fully specified. The interval may be only partially
specified where either only the width or only one boundary is
specified.
    </p>
<p>
For example: &quot;every eight hours for two minutes&quot; specifies only the
period and the phase&apos;s width but no boundary of the phase. Conversely,
&quot;every eight hours starting at 4 o&apos;clock&quot; specifies only the period
and the phase&apos;s low boundary but not the phase&apos;s high boundary. &quot;Every
eight hours for two minutes starting at 4 o&apos;clock&quot; is fully specified
since the period, and both the phase&apos;s low boundary and width are
specified (low boundary and width implies the high boundary.)
    </p>
<p>
The periodic interval of time is a generic type extension whose type
parameter T is restricted to the point in time (&lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;TS&apos;/&gt;&lt;/object&gt;)
data type and its extensions. The parametric probability distribution
of point in time (&lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;PPD&apos;/&gt;&lt;/object&gt;&lt;&lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;TS&apos;/&gt;&lt;/object&gt;&gt;) is
an extension of point in time and therefore can be used to form
periodic intervals of probability distributions of point in time
(&lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;PIVL&apos;/&gt;&lt;/object&gt;&lt;&lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;PPD&apos;/&gt;&lt;/object&gt;
&lt;&lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;TS&apos;/&gt;&lt;/object&gt;&gt;&gt;) values (uncertain periodic interval.)
    </p>
<p>
Oftentimes repeating schedules are only approximately specified. For
instance &quot;three times a day for ten minutes each&quot; does not usually
mean a period of precisely 8 hours and does often not mean exactly 10
minutes intervals. Rather the distance between each occurrence may
vary as much as between 3 and 12 hours and the width of the interval
may be less than 5 minutes or more than 15 minutes. An uncertain
periodic interval can be used to indicate how much leeway is allowed
or how &quot;timing-critical&quot; the specification is.
    </p>
<p>
The essential property of a set is that it contains elements. For
non-aligned periodic intervals, the contains-property is
defined as follows. A point in time t is contained in the
periodic interval of time if and only if there is an integer
i for which t plus the period times
i is an element of the phase interval.
      
invariant (PIVL&lt;TS&gt; x, TS t)
    where x.nonNull.and(x.alignment.isNull) {
  x.contains(t).equal(exists(INT i) {
       x.phase.contains(t.plus(x.period.times(i)));
     });
};
      
For calendar-aligned periodic intervals the contains
property is defined using the calendar-cycle&apos;s sum(t,
n) property that adds n such calendar cycles
to the time t.
      
invariant (PIVL&lt;TS&gt; x, TS t, CalendarCycle c)
    where x.nonNull.and(c.equal(x.alignment)) {
  x.contains(t).equal(exists(INT i) {
        x.phase.contains(c.sum(t, i));
     });
};
      </p>
]]></text>
            </annotation>
         </documentation>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="IVL.HIGH">
      <datatype isAbstract="false" name="IVL.HIGH" businessName="High value" visibility="protected" superType="IVL" isMerged="false">
         <documentation>
            <businessName>High value</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[This data type is used when only the high value is known.]]></text>
            </annotation>
            <annotation annotationType="CONSTRAINT">
               <text><![CDATA[Start value is Unknown]]></text>
            </annotation>
         </documentation>
         <parentDatatype isAbstract="false" name="IVL" businessName="Interval" visibility="public" superType="SET" isMerged="false">
            <documentation>
               <businessName>Interval</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
A set of consecutive values of an ordered base data type.
    ]]></text>
               </annotation>
               <annotation annotationType="DESIGN_COMMENTS">
                  <text><![CDATA[
<p>
Any ordered type can be the basis of an interval; it does not matter
whether the base type is discrete or continuous. If the base data type
is only partially ordered, all elements of the interval must be
elements of a totally ordered subset of the partially ordered data
type.
    </p>
<p>
For example, physical quantities are considered ordered. However the
ordering of physical quantities is only partial; a total order is only
defined among comparable quantities (quantities of the same physical
dimension.)  While intervals between 2 and 4 meter exists, there is no
interval between 2 meters and 4 seconds.
    </p>
<p>
Intervals are sets and have all the properties of sets. However, union
and differences of intervals may not be intervals any more, since the
elements of these union and difference sets might not be
contiguous. Intersections of intervals are always intervals.
    </p>
]]></text>
               </annotation>
            </documentation>
         </parentDatatype>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="ED.SIGNATURE">
      <datatype isAbstract="false" name="ED.SIGNATURE" businessName="Encapsulated Data (Signature)" visibility="public" superType="ED" isMerged="false">
         <documentation>
            <businessName>Encapsulated Data (Signature)</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[This allows incorporation of a digital signature as part of a message.]]></text>
            </annotation>
            <annotation annotationType="USAGE_NOTES">
               <text><![CDATA[
<p>Additional pan-Canadian standards effort is anticipated to provide guidance on how digital signatures should be implemented within Canadian v3 instances. </p>
]]></text>
            </annotation>
            <annotation annotationType="USAGE_CONSTRAINT">
               <text><![CDATA[Content must conform to the XML digital signature specification]]></text>
            </annotation>
            <annotation annotationType="CONSTRAINT">
               <text><![CDATA[
<p>mandatory</p>
]]></text>
            </annotation>
         </documentation>
         <staticExampleEntry annotationType="STATIC_EXAMPLE" businessName="">
            <text><![CDATA[&lt;text flavorId=&apos;ED.SIGNATURE&apos; type=&apos;ED&apos; mediaType=&apos;text/xml&apos;&gt;
	&lt;Signature&gt;. . .&lt;/Signature&gt;
&lt;/text&gt;
]]></text>
         </staticExampleEntry>
         <parentDatatype isAbstract="false" name="ED" businessName="EncapsulatedData" visibility="public" superType="BIN" isMerged="false">
            <documentation>
               <businessName>EncapsulatedData</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
<p>
                     &lt;param name=&apos;datatypeName&apos; value=&apos;ED&apos;/&gt;
                  </p>
<p>
                     &lt;param name=&apos;datatypeName&apos; value=&apos;TEL&apos;/&gt;
                  </p>
<p>
                     &lt;param name=&apos;datatypeName&apos; value=&apos;ST&apos;/&gt;
                  </p>
<p>
                     &lt;param name=&apos;datatypeName&apos; value=&apos;ED&apos;/&gt;
                  </p>
<p>
                     &lt;param name=&apos;datatypeName&apos; value=&apos;ED&apos;/&gt;
                  </p>
]]></text>
               </annotation>
               <annotation annotationType="DESIGN_COMMENTS">
                  <text><![CDATA[
<p>
Encapsulated data can be present in two forms, inline or by
reference. Inline data is communicated or moved as part of the
encapsulated data value, whereas by-reference data may reside at a
different (remote) location. The data is the same whether it is
located inline or remote.
    </p>
]]></text>
               </annotation>
            </documentation>
         </parentDatatype>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="IVL_PQ">
      <datatype isAbstract="false" name="IVL_PQ" businessName="Quantity Range" visibility="public" isMerged="false">
         <documentation>
            <businessName>Quantity Range</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[This is used to express an allowed range of quantities.]]></text>
            </annotation>
            <annotation annotationType="CONSTRAINT">
               <text><![CDATA[At least one of the low property or high property must be specifed with a non null value.]]></text>
            </annotation>
         </documentation>
         <staticExampleEntry annotationType="STATIC_EXAMPLE" businessName="above 40 degrees Celcius">
            <text><![CDATA[&lt;value type=&apos;IVL_PQ&apos;&gt;
	&lt;low unit=&apos;CEL&apos; flavorId=&apos;PQ.BASIC&apos; value=&apos;40&apos; type=&apos;PQ&apos;/&gt;
	&lt;high nullFlavor=&apos;PINF&apos; type=&apos;PQ&apos;/&gt;
&lt;/value&gt;
]]></text>
         </staticExampleEntry>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="INT">
      <datatype isAbstract="false" name="INT" businessName="IntegerNumber" visibility="public" superType="QTY" isMerged="false">
         <documentation>
            <businessName>IntegerNumber</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[
Integer numbers (-1,0,1,2, 100, 3398129, etc.) are precise numbers
that are results of counting and enumerating. Integer numbers are
discrete, the set of integers is infinite but countable.  No arbitrary
limit is imposed on the range of integer numbers. Two NULL flavors are
defined for the positive and negative infinity.
    ]]></text>
            </annotation>
            <annotation annotationType="DESIGN_COMMENTS">
               <text><![CDATA[
<p>
Since the integer number data type includes all of the semantics of
the mathematical integer number concept, the basic operations plus
(addition) and times (multiplication) are defined. These operations
are defined here as characterizing operations in the sense of ISO
11404, and because these operations are needed in other parts of this
specification, namely the semantics of the literal form.
    </p>
<p>
The traditional recursive definitions of addition and multiplication
are due to Grassmann, and use the notion of &lt;object name=&apos;propertyRef&apos;&gt;&lt;param name=&apos;propertyName&apos; value=&apos;successor&apos;/&gt;
                        &lt;param name=&apos;datatypeName&apos; value=&apos;INT&apos;/&gt;&lt;/object&gt;.&lt;object name=&apos;footnote&apos;&gt;H. Grassman. Lehrbuch der Arithmetik. 1861. We prefer
Grassman&apos;s original axioms to the Peano axioms, because Grassman&apos;s
axioms work for all integers, not just for natural numbers. Also, &quot;it
is rather well-known, through Peano&apos;s own acknowledgment, that Peano
borrowed his axioms from Dedekind and made extensive use of
Grassmann&apos;s work in his development of the axioms.&quot; (Hao Wang. The
Axiomatization of Arithmetic. J. Symb. Logic; 1957:22(2); p. 145.)&lt;/object&gt;
				              </p>
]]></text>
            </annotation>
         </documentation>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="TEL">
      <datatype isAbstract="false" name="TEL" businessName="TelecommunicationAddress" visibility="public" superType="URL" isMerged="false">
         <documentation>
            <businessName>TelecommunicationAddress</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[
A telephone number (voice or fax), e-mail address, or other locator
for a resource mediated by telecommunication equipment. The address is
specified as a Universal Resource Locator (URL) qualified by time
specification and use codes that help in deciding which address to use
for a given time and purpose.
    ]]></text>
            </annotation>
            <annotation annotationType="DESIGN_COMMENTS">
               <text><![CDATA[
<p>
The semantics of a telecommunication address is that a communicating
entity (the responder) listens and responds to that address, and
therefore can be contacted by an other communicating entity (the
initiator.)
    </p>
<p>
The responder of a telecommunication address may be an automatic
service that can respond with information (e.g., FTP or HTTP
services.)  In such case a telecommunication address is a reference to
that information accessible through that address. A telecommunication
address value can thus be resolved to some information (in the form of
encapsulated data, &lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;ED&apos;/&gt;&lt;/object&gt;.)
    </p>
<p>
The telecommunication address is an extension of the Universal
Resource Locator (&lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;URL&apos;/&gt;&lt;/object&gt;) specified according to Internet
standard RFC 2396 [&lt;a href=&apos;http://www.ietf.org/rfc/rfc2396.txt&apos;/&gt;].
The &lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;URL&apos;/&gt;&lt;/object&gt; specifies the protocol and the contact point
defined by that protocol for the resource. Notable use cases for the
telecommunication address data type are for telephone and fax numbers,
e-mail addresses, Hypertext references, FTP references, etc.
    </p>
]]></text>
            </annotation>
         </documentation>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="PQ.BASIC">
      <datatype isAbstract="false" name="PQ.BASIC" businessName="Basic Physical Quantity" visibility="public" superType="PQ" isMerged="false">
         <documentation>
            <businessName>Basic Physical Quantity</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[Used to communicate measurements using common measurement units encountered in healthcare and corresponding value]]></text>
            </annotation>
         </documentation>
         <staticExampleEntry annotationType="STATIC_EXAMPLE" businessName="22.35 millmoles per litre">
            <text><![CDATA[&lt;value unit=&apos;mmol/l&apos; flavorId=&apos;PQ.BASIC&apos; value=&apos;22.35&apos; type=&apos;PQ&apos;&gt;
	
&lt;/value&gt;
]]></text>
         </staticExampleEntry>
         <parentDatatype isAbstract="false" name="PQ" businessName="PhysicalQuantity" visibility="public" superType="QTY" isMerged="false">
            <documentation>
               <businessName>PhysicalQuantity</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
A dimensioned quantity expressing the result of measuring.
    ]]></text>
               </annotation>
            </documentation>
         </parentDatatype>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="TEL.PHONEMAIL">
      <datatype isAbstract="true" name="TEL.PHONEMAIL" businessName="Phone or E-mail" visibility="public" superType="TEL" isMerged="false">
         <documentation>
            <businessName>Phone or E-mail</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[Allows phone and fax numbers as well as e-mail addresses to be communicated.]]></text>
            </annotation>
            <annotation annotationType="USAGE_NOTES">
               <text><![CDATA[This data type may be referenced in Canadian specifications.  If this data type is used in a message instance, it must be declared as TEL.PHONE or TEL.EMAIL for each repetition.]]></text>
            </annotation>
         </documentation>
         <parentDatatype isAbstract="false" name="TEL" businessName="TelecommunicationAddress" visibility="public" superType="URL" isMerged="false">
            <documentation>
               <businessName>TelecommunicationAddress</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
A telephone number (voice or fax), e-mail address, or other locator
for a resource mediated by telecommunication equipment. The address is
specified as a Universal Resource Locator (URL) qualified by time
specification and use codes that help in deciding which address to use
for a given time and purpose.
    ]]></text>
               </annotation>
               <annotation annotationType="DESIGN_COMMENTS">
                  <text><![CDATA[
<p>
The semantics of a telecommunication address is that a communicating
entity (the responder) listens and responds to that address, and
therefore can be contacted by an other communicating entity (the
initiator.)
    </p>
<p>
The responder of a telecommunication address may be an automatic
service that can respond with information (e.g., FTP or HTTP
services.)  In such case a telecommunication address is a reference to
that information accessible through that address. A telecommunication
address value can thus be resolved to some information (in the form of
encapsulated data, &lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;ED&apos;/&gt;&lt;/object&gt;.)
    </p>
<p>
The telecommunication address is an extension of the Universal
Resource Locator (&lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;URL&apos;/&gt;&lt;/object&gt;) specified according to Internet
standard RFC 2396 [&lt;a href=&apos;http://www.ietf.org/rfc/rfc2396.txt&apos;/&gt;].
The &lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;URL&apos;/&gt;&lt;/object&gt; specifies the protocol and the contact point
defined by that protocol for the resource. Notable use cases for the
telecommunication address data type are for telephone and fax numbers,
e-mail addresses, Hypertext references, FTP references, etc.
    </p>
]]></text>
               </annotation>
            </documentation>
         </parentDatatype>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="QTY">
      <datatype isAbstract="true" name="QTY" businessName="Quantity" visibility="public" superType="ANY" isMerged="false">
         <documentation>
            <businessName>Quantity</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[
The quantity data type is an abstract generalization for all data
types (1) whose value set has an order relation (less-or-equal) and
(2) where difference is defined in all of the data type's totally
ordered value subsets.  The quantity type abstraction is needed in
defining certain other types, such as the interval and the probability
distribution.
    ]]></text>
            </annotation>
         </documentation>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="URG">
      <datatype isAbstract="false" name="URG" businessName="UncertainRange" visibility="public" superType="T" isMerged="false">
         <documentation>
            <businessName>UncertainRange</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[
					Indicates that the value comes from a range of possible values from an ordered base data type value.
				]]></text>
            </annotation>
            <annotation annotationType="DESIGN_COMMENTS">
               <text><![CDATA[
<p>
							&lt;object name=&apos;itemName&apos;&gt;&lt;param name=&apos;item&apos; value=&apos;datatype&apos;/&gt;&lt;/object&gt; is used where the actual value is unknown, but it is known that the 
					value comes from a known range of possible values. 
				</p>
<p>
							&lt;object name=&apos;itemName&apos;&gt;&lt;param name=&apos;item&apos; value=&apos;datatype&apos;/&gt;&lt;/object&gt; differs from &lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;PPD&apos;/&gt;&lt;/object&gt; in that &lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;PPD&apos;/&gt;&lt;/object&gt; is used to report a 
					particular value along with an associated distribution of uncertainty for the 
					value, or to report the summary distribution of a set of data, whereas &lt;object name=&apos;itemName&apos;&gt;&lt;param name=&apos;item&apos; value=&apos;datatype&apos;/&gt;&lt;/object&gt; indicates
					that there is a single value that, although unknown, must come from a particular range
					of values. No inference regarding distribution of values can be taken. &lt;object name=&apos;itemName&apos;&gt;&lt;param name=&apos;item&apos; value=&apos;datatype&apos;/&gt;&lt;/object&gt; 
					is often associated with an instruction to perform a particular operation at 
					some point within a given time interval.  
				</p>
<p>
					Any ordered type can be the basis of an &lt;object name=&apos;itemName&apos;&gt;&lt;param name=&apos;item&apos; value=&apos;datatype&apos;/&gt;&lt;/object&gt;; it does not matter
					whether the base type is discrete or continuous. If the base data type
					is only partially ordered, all possible values for the &lt;object name=&apos;itemName&apos;&gt;&lt;param name=&apos;item&apos; value=&apos;datatype&apos;/&gt;&lt;/object&gt; are
					elements of a totally ordered subset of the partially ordered data
					type.
				</p>
<p>
					For example, &lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;PQ&apos;/&gt;&lt;/object&gt; is considered ordered. However the
					ordering of &lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;PQ&apos;/&gt;&lt;/object&gt;s is only partial; a total order is only
					defined among comparable quantities (quantities of the same physical
					dimension).  While &lt;object name=&apos;itemName&apos;&gt;&lt;param name=&apos;item&apos; value=&apos;datatype&apos;/&gt;&lt;/object&gt;s between 2 and 4 meter exists, there is no
					&lt;object name=&apos;itemName&apos;&gt;&lt;param name=&apos;item&apos; value=&apos;datatype&apos;/&gt;&lt;/object&gt; between 2 meters and 4 seconds.
				</p>
]]></text>
            </annotation>
            <annotation annotationType="CONSTRAINT">
               <text><![CDATA[
<p>
							&lt;param name=&apos;item&apos; value=&apos;datatype&apos;/&gt;
						</p>
]]></text>
            </annotation>
         </documentation>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="LIST">
      <datatype isAbstract="false" name="LIST" businessName="List" visibility="public" superType="ANY" isMerged="true">
         <documentation>
            <businessName>List</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[Used when multiple repetitions are allowed and order matters.]]></text>
            </annotation>
            <annotation annotationType="USAGE_NOTES">
               <text><![CDATA[
<p>Each repetition must follow the specification defined for type of list item.</p>
<p>Applications are expected to retain information about the sequence of the repetitions.  The semantics of the sequence can be found in the description of the attribute or property.  Duplicate repetitions are technically allowed, but should occur only if they make sense in the context of use.</p>
]]></text>
            </annotation>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[
A value that contains other discrete (but not necessarily distinct) values in a defined sequence. 
    ]]></text>
            </annotation>
            <annotation annotationType="DESIGN_COMMENTS">
               <text><![CDATA[
<p>
A sequence may contain NULL values as items.
    </p>
]]></text>
            </annotation>
         </documentation>
         <parentDatatype isAbstract="false" name="LIST" businessName="Sequence" visibility="public" superType="ANY" isMerged="false">
            <documentation>
               <businessName>Sequence</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
A value that contains other discrete (but not necessarily distinct) values in a defined sequence. 
    ]]></text>
               </annotation>
               <annotation annotationType="DESIGN_COMMENTS">
                  <text><![CDATA[
<p>
A sequence may contain NULL values as items.
    </p>
]]></text>
               </annotation>
            </documentation>
         </parentDatatype>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="URL">
      <datatype isAbstract="false" name="URL" businessName="UniversalResourceLocator" visibility="protected" superType="ANY" isMerged="false">
         <documentation>
            <businessName>UniversalResourceLocator</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[
<p></p>
]]></text>
            </annotation>
            <annotation annotationType="DESIGN_COMMENTS">
               <text><![CDATA[
<p>
The Internet standard RFC 2396 [&lt;a href=&apos;http://www.ietf.org/rfc/rfc2396.txt&apos;/&gt;] defines a URI as
follows:
    </p>
<p>
                     &lt;p&gt;&lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;URL&apos;/&gt;&lt;/object&gt;s provides a framework for
new schemes to be established using protocols other than those defined
in this document.&lt;/p&gt;
                     &lt;p&gt;&lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;URL&apos;/&gt;&lt;/object&gt; scheme.&lt;/p&gt;
                     &lt;p/&gt;
                  </p>
]]></text>
            </annotation>
         </documentation>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="IVL">
      <datatype isAbstract="false" name="IVL" businessName="Interval" visibility="public" superType="SET" isMerged="false">
         <documentation>
            <businessName>Interval</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[
A set of consecutive values of an ordered base data type.
    ]]></text>
            </annotation>
            <annotation annotationType="DESIGN_COMMENTS">
               <text><![CDATA[
<p>
Any ordered type can be the basis of an interval; it does not matter
whether the base type is discrete or continuous. If the base data type
is only partially ordered, all elements of the interval must be
elements of a totally ordered subset of the partially ordered data
type.
    </p>
<p>
For example, physical quantities are considered ordered. However the
ordering of physical quantities is only partial; a total order is only
defined among comparable quantities (quantities of the same physical
dimension.)  While intervals between 2 and 4 meter exists, there is no
interval between 2 meters and 4 seconds.
    </p>
<p>
Intervals are sets and have all the properties of sets. However, union
and differences of intervals may not be intervals any more, since the
elements of these union and difference sets might not be
contiguous. Intersections of intervals are always intervals.
    </p>
]]></text>
            </annotation>
         </documentation>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="PPD">
      <datatype isAbstract="false" name="PPD" businessName="ParametricProbabilityDistribution" visibility="public" superType="T" isMerged="false">
         <documentation>
            <businessName>ParametricProbabilityDistribution</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[
A generic data type extension specifying uncertainty of quantitative
data using a distribution function and its parameters. Aside from the 
specific parameters of the distribution, a mean (expected value) and 
standard deviation is always given to help maintain a minimum layer
of interoperability if receiving applications cannot deal with a
certain probability distribution.
    ]]></text>
            </annotation>
            <annotation annotationType="DESIGN_COMMENTS">
               <text><![CDATA[
<p>
For example, the most common college entrance exam in the United
States is the SAT, which is comprised of two parts: verbal and
math. Each part has a minimum score of 400 (no questions answered
correctly) and a perfect score of 800. In 1998, according to the
College Board, 1,172,779 college-bound seniors took the test. The mean
score for the math portion of the test was 512, and the standard
deviation 112. These parameter values (512, 112), tagged as the normal
distribution parameters, paint a pretty good picture of test score
distribution. In most cases, there is no need to specify all
1-million+ points of data when just 2 parameters will do!
    </p>
<p></p>
<p>
Note that the normal distribution is only one of several distributions
defined for HL7.
    </p>
<p>Since a &lt;object name=&apos;itemName&apos;&gt;&lt;param name=&apos;item&apos; value=&apos;datatype&apos;/&gt;&lt;/object&gt; specializes its parameter type T, a simple T value is
the mean (expected value or first moment) of the probability
distribution. Applications that cannot deal with distributions will
take the simple T value neglecting the uncertainty. That simple value
of type T is also used to standardize the data for computing the
distribution.
    </p>
<p>
Probability distributions are defined over integer or real numbers and
normalized to a certain reference point (typically zero) and reference
unit (e.g., standard deviation = 1). When other quantities defined in
this specification are used as base types, the mean and the standard
deviation are used to scale the probability distribution. For example,
if a &lt;object name=&apos;itemName&apos;&gt;&lt;param name=&apos;item&apos; value=&apos;datatype&apos;/&gt;&lt;/object&gt; of PQ for a length is given with mean 20 ft
and a standard deviation of 2 in, the normalized distribution function
&lt;var&gt;f&lt;/var&gt;(&lt;var&gt;x&lt;/var&gt;) that maps a real number &lt;var&gt;x&lt;/var&gt;
to a probability density would be translated to
&lt;var&gt;f&lt;/var&gt;&#8242;(&lt;var&gt;x&lt;/var&gt;&#8242;) that maps a length
&lt;var&gt;x&lt;/var&gt;&#8242; to a probability density as
&lt;var&gt;f&lt;/var&gt;&#8242;(&lt;var&gt;x&lt;/var&gt;&#8242;) =
&lt;var&gt;f&lt;/var&gt;((&lt;var&gt;x&lt;/var&gt;&#8242; - &#956; ) / &#963;).
    </p>
<p>
Where applicable, the &lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;PPD&apos;/&gt;&lt;/object&gt; specification conforms to
the ISO &lt;b&gt;Guide to the Expression of Uncertainty in
Measurement&lt;/b&gt; (GUM) as reflected by NIST publication 1297
&lt;b&gt;Guidelines for Evaluating and Expressing the Uncertainty of NIST
Measurement Results&lt;/b&gt;. The &lt;object name=&apos;itemName&apos;&gt;&lt;param name=&apos;item&apos; value=&apos;datatype&apos;/&gt;&lt;/object&gt; specification does not
describe how uncertainty is to be evaluated but only how it is
expressed. The concept of &quot;standard uncertainty&quot; as set forth by the
ISO GUM corresponds to the &quot;standard deviation&quot; property of the &lt;object name=&apos;itemName&apos;&gt;&lt;param name=&apos;item&apos; value=&apos;datatype&apos;/&gt;&lt;/object&gt;.
    </p>
]]></text>
            </annotation>
         </documentation>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="REAL">
      <datatype isAbstract="false" name="REAL" businessName="RealNumber" visibility="public" superType="QTY" isMerged="false">
         <documentation>
            <businessName>RealNumber</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[
Fractional numbers. Typically used whenever quantities are measured,
estimated, or computed from other real numbers.  The typical
representation is decimal, where the number of significant decimal
digits is known as the precision.
    ]]></text>
            </annotation>
            <annotation annotationType="DESIGN_COMMENTS">
               <text><![CDATA[
<p>
The term &quot;Real number&quot; in this specification is used to mean that
fractional values are covered without necessarily implying the full
set of the mathematical real numbers that would include irrational
numbers such as &#961;, Euler&apos;s number, etc.&lt;object name=&apos;footnote&apos;&gt;The term &quot;Real&quot; for a fractional number data type originates and is
well established in the Algol, Pascal tradition of programming
languages.&lt;/object&gt;
				              </p>
<p>
This specification offers two choices for a number data type. The
choice is made as follows: Any number attribute is a real if it is not
known for sure that it is an integer. A number is an integer if it is
&lt;b&gt;always&lt;/b&gt; counted, typically representing an ordinal
number. If there are conceivable use cases where such a number would
be estimated or averaged, it is not always an integer and thus should
use the Real data type.
    </p>
<p>
The algebraic operations are specified here as characterizing
operations in the sense of ISO 11404, and because these operations are
needed in other parts of this specification.
    </p>
<p>
Unlike the integer numbers, the real numbers semantics are not
inductively constructed but only intuitively described by their axioms
of their algebraic properties. The completeness axioms are
intentionally left out so as to make no statement about irrational
numbers.
    </p>
]]></text>
            </annotation>
         </documentation>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="PQ.DRUG">
      <datatype isAbstract="false" name="PQ.DRUG" businessName="Drug Physical Quantity" visibility="public" superType="PQ" isMerged="false">
         <documentation>
            <businessName>Drug Physical Quantity</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[Used to convey quantities of drug products.]]></text>
            </annotation>
            <annotation annotationType="REQUIREMENTS">
               <text><![CDATA[Ballot comment #25]]></text>
            </annotation>
         </documentation>
         <staticExampleEntry annotationType="STATIC_EXAMPLE" businessName="10 tablets">
            <text><![CDATA[&lt;doseQuantity flavorId=&apos;PQ.DRUG&apos; value=&apos;10&apos; type=&apos;PQ&apos;&gt;
	
&lt;/doseQuantity&gt;
]]></text>
         </staticExampleEntry>
         <parentDatatype isAbstract="false" name="PQ" businessName="PhysicalQuantity" visibility="public" superType="QTY" isMerged="false">
            <documentation>
               <businessName>PhysicalQuantity</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
A dimensioned quantity expressing the result of measuring.
    ]]></text>
               </annotation>
            </documentation>
         </parentDatatype>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="ENXP.OPTIONAL">
      <datatype isAbstract="false" name="ENXP.OPTIONAL" businessName="Optional Entity Name Part" visibility="protected" superType="ENXP" isMerged="false">
         <documentation>
            <businessName>Optional Entity Name Part</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[Used to express person names for general identification and communication purposes.]]></text>
            </annotation>
            <annotation annotationType="CONSTRAINT">
               <text><![CDATA[Each name part is constrained to a 50 character string (ST)]]></text>
            </annotation>
         </documentation>
         <parentDatatype isAbstract="false" name="ENXP" businessName="EntityNamePart" visibility="protected" superType="SC" isMerged="false">
            <documentation>
               <businessName>EntityNamePart</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
A character string token representing a part of a name. May have a
type code signifying the role of the part in the whole entity name,
and a qualifier code for more detail about the name part type.
Typical name parts for person names are given names, and family names,
titles, etc.
    ]]></text>
               </annotation>
            </documentation>
         </parentDatatype>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="TS.FULLDATETIME">
      <datatype isAbstract="false" name="TS.FULLDATETIME" businessName="Timestamp (Date+Time)" visibility="public" superType="TS" isMerged="false">
         <documentation>
            <businessName>Timestamp (Date+Time)</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[Requires both the "date" and "time" portion of the timestamp to be fully specified, including timezone.]]></text>
            </annotation>
            <annotation annotationType="REQUIREMENTS">
               <text><![CDATA[Ballot comment #18]]></text>
            </annotation>
            <annotation annotationType="USAGE_NOTES">
               <text><![CDATA[The grammar for the date/time is: YYYYMMDDHHMMSS[.S[S[S[S]]]]+/-ZZZZ (19 or 24 characters).]]></text>
            </annotation>
            <annotation annotationType="CONSTRAINT">
               <text><![CDATA[If the value is not null, there SHALL be 14 or more digits in the literal form. There SHALL be a timezone. This flavor is specific to the gregorian calendar.]]></text>
            </annotation>
         </documentation>
         <staticExampleEntry annotationType="STATIC_EXAMPLE" businessName="">
            <text><![CDATA[&lt;effectiveTime flavorId=&apos;TS.FULLDATETIME&apos; value=&apos;20050802173000-0800&apos; type=&apos;TS&apos;&gt;
	
&lt;/effectiveTime&gt;
]]></text>
         </staticExampleEntry>
         <parentDatatype isAbstract="false" name="TS" businessName="PointInTime" visibility="public" superType="QTY" isMerged="false">
            <documentation>
               <businessName>PointInTime</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
A quantity specifying a point on the axis of natural time. A point
in time is most often represented as a calendar expression.
    ]]></text>
               </annotation>
               <annotation annotationType="DESIGN_COMMENTS">
                  <text><![CDATA[
<p>
Semantically, however, time is independent from calendars and best
described by its relationship to elapsed time (measured as a physical
quantity in the dimension of time.)  A point in time plus an elapsed
time yields another point in time.  Inversely, a point in time minus
another point in time yields an elapsed time.
    </p>
<p>
As nobody knows when time began, a point in time is conceptualized as
the amount of time that has elapsed from some arbitrary zero-point,
called an epoch.  Because there is no absolute zero-point on the time
axis natural time is a difference-scale quantity, where only
differences are defined but no ratios. (For example, no point in time
is &#8212; absolutely speaking &#8212; &quot;twice as late&quot; as another
point in time.)
    </p>
<p>
Given some arbitrary zero-point, one can express any point in time as
an elapsed time measured from that offset. Such an arbitrary
zero-point is called an epoch. This epoch-offset form is used as a
semantic representation here, without implying that any system would
have to implement the TS data type in that way. Systems that do not
need to compute distances between points in time will not need any
other representation than a calendar expression literal.
    </p>
]]></text>
               </annotation>
            </documentation>
         </parentDatatype>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="II.TOKEN">
      <datatype isAbstract="false" name="II.TOKEN" businessName="Instance Identifier (Token)" visibility="public" superType="II" isMerged="false">
         <documentation>
            <businessName>Instance Identifier (Token)</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[This is used to convey "internal" computer-generated on-the-fly identifiers, such as security tokens. These identifiers are not intended for human display.]]></text>
            </annotation>
         </documentation>
         <staticExampleEntry annotationType="STATIC_EXAMPLE" businessName="A temporary resolved-patient identifier">
            <text><![CDATA[&lt;id root=&apos;64AC5370-D851-2D2F-2A18-78FBB73BFED9&apos;&gt;
	
&lt;/id&gt;
]]></text>
         </staticExampleEntry>
         <parentDatatype isAbstract="false" name="II" businessName="InstanceIdentifier" visibility="public" superType="ANY" isMerged="false">
            <documentation>
               <businessName>InstanceIdentifier</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
An identifier that uniquely identifies a thing or object. Examples
are object identifier for HL7 RIM objects, medical record number,
order id, service catalog item id, Vehicle Identification Number
(VIN), etc. Instance identifiers are defined based on ISO object
identifiers.
    ]]></text>
               </annotation>
            </documentation>
         </parentDatatype>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="PQR">
      <datatype isAbstract="false" name="PQR" businessName="PhysicalQuantityRepresentation" visibility="protected" superType="CV" isMerged="false">
         <documentation>
            <businessName>PhysicalQuantityRepresentation</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[
An extension of the coded value data type representating a physical
quantity using a unit from any code system. Used to show alternative
representation for a physical quantity.
    ]]></text>
            </annotation>
         </documentation>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="AD.FULL">
      <datatype isAbstract="false" name="AD.FULL" businessName="Full Address" visibility="public" superType="AD" isMerged="false">
         <documentation>
            <businessName>Full Address</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[Used to communicate fully validatable addresses.  Usually appropriate only for registry-type situations.]]></text>
            </annotation>
            <annotation annotationType="CONSTRAINT">
               <text><![CDATA[There may be up to 4 lines of delimiter-separated information in addition to the specified address parts.]]></text>
            </annotation>
            <annotation annotationType="CONSTRAINT">
               <text><![CDATA[Address parts are rescricted to basic address parts]]></text>
            </annotation>
            <annotation annotationType="CONSTRAINT">
               <text><![CDATA[The "city", "state", "postalCode" and "country" properties are required.]]></text>
            </annotation>
         </documentation>
         <staticExampleEntry annotationType="STATIC_EXAMPLE" businessName="">
            <text><![CDATA[&lt;addr flavorId=&apos;AD.FULL&apos; use=&apos;H PST&apos; type=&apos;AD&apos;&gt;
	&lt;unitId&gt;Apt A5&lt;/unitId&gt;
	&lt;houseNumber&gt;123&lt;/houseNumber&gt;
	&lt;streetNameBase&gt;Some&lt;/streetNameBase&gt;
	&lt;streetNameType&gt;Street&lt;/streetNameType&gt;
	&lt;direction&gt;N.W.&lt;/direction&gt;
	&lt;delimiter/&gt;
	&lt;city&gt;Edmonton&lt;/city&gt;
	&lt;state code=&apos;AB&apos;&gt;Alberta&lt;/state&gt;
	&lt;postalCode&gt;A1B 2C3&lt;/postalCode&gt;
	&lt;delimiter/&gt;
	&lt;country code=&apos;CA&apos;&gt;Canada&lt;/country&gt;
&lt;/addr&gt;
]]></text>
         </staticExampleEntry>
         <parentDatatype isAbstract="false" name="AD" businessName="PostalAddress" visibility="public" superType="LIST" isMerged="false">
            <documentation>
               <businessName>PostalAddress</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
Mailing and home or office addresses. A sequence of address parts,
such as street or post office Box, city, postal code, country, etc.
    ]]></text>
               </annotation>
               <annotation annotationType="DESIGN_COMMENTS">
                  <text><![CDATA[
<p>
The &lt;object name=&apos;itemName&apos;&gt;&lt;param name=&apos;item&apos; value=&apos;datatype&apos;/&gt;&lt;/object&gt; is primarily used to communicate data that will allow
printing mail labels, that will allow a person to physically visit
that address. The postal address data type is not supposed to be a
container for additional information that might be useful for finding
geographic locations (e.g., GPS coordinates) or for performing
epidemiological studies. Such additional information is captured by
other, more appropriate HL7 elements.
    </p>
<p>
Addresses are conceptualized as text with added logical mark-up. The
mark-up may break the address into lines and may describe in detail
the role of each address part if it is known. Address parts occur in
the address in the order in which they would be printed on a mailing
label. The approach is similar to HTML or XML markup of text (but it
is not technically limited to XML representations.)
    </p>
<p>
Addresses are essentially sequences of address parts, but add a &quot;use&quot;
code and a valid time range for information about if and when the
address can be used for a given purpose.
    </p>
]]></text>
               </annotation>
            </documentation>
         </parentDatatype>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="IVL_TS.FULLDATETIME">
      <datatype isAbstract="false" name="IVL_TS.FULLDATETIME" businessName="Precise Date-Time Range" visibility="public" isMerged="false">
         <documentation>
            <businessName>Precise Date-Time Range</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[Used when a time range needs to be conveyed with precise start and/or end times.]]></text>
            </annotation>
            <annotation annotationType="CONSTRAINT">
               <text><![CDATA[Low and high cannot have null flavors PINF or NINF]]></text>
            </annotation>
         </documentation>
         <staticExampleEntry annotationType="STATIC_EXAMPLE" businessName="from March 01, 2000 @ 3:30:00 PM to July 15, 2000 @ 4:30:00 AM, Ontario time">
            <text><![CDATA[&lt;effectiveTime type=&apos;IVL_TS&apos;&gt;
	&lt;low flavorId=&apos;TS.FULLDATETIME&apos; value=&apos;20000301153000-0500&apos; type=&apos;TS&apos;/&gt;
	&lt;high flavorId=&apos;TS.FULLDATETIME&apos; value=&apos;20000715043000-0500&apos; type=&apos;TS&apos;/&gt;
&lt;/effectiveTime&gt;
]]></text>
         </staticExampleEntry>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="GTS">
      <datatype isAbstract="false" name="GTS" businessName="GeneralTimingSpecification" visibility="public" superType="SET" isMerged="false">
         <documentation>
            <businessName>GeneralTimingSpecification</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[
A set of points in time, specifying the timing of events and actions
and the cyclical validity-patterns that may exist for certain kinds of
information, such as phone numbers (evening, daytime), addresses (so
called "snowbirds," residing closer to the equator during winter and
farther from the equator during summer) and office hours.
    ]]></text>
            </annotation>
            <annotation annotationType="DESIGN_COMMENTS">
               <text><![CDATA[
<p>
The GTS data type has the following aspects:
    </p>
<p>
                     &lt;li&gt;&lt;p&gt;&lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;SET&apos;/&gt;&lt;/object&gt;
&lt;&lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;TS&apos;/&gt;&lt;/object&gt;&gt;). From this aspect GTS answers
whether any given point in time falls in the schedule described by the
GTS value.&lt;/p&gt;&lt;/li&gt;
                     &lt;li&gt;&lt;p&gt;GTS as the combination of multiple periodic intervals of time. This
aspect describes how both simple and complex repeat-patterns are
specified with the GTS.&lt;/p&gt;&lt;/li&gt;
                     &lt;li&gt;&lt;p&gt;&lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;LIST&apos;/&gt;&lt;/object&gt;&lt;&lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;IVL&apos;/&gt;&lt;/object&gt;
&lt;&lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;TS&apos;/&gt;&lt;/object&gt;&gt;&gt;).
From this aspect, GTS can generate all occurrence intervals of an event or
action, or all validity periods for a fact.&lt;/p&gt;&lt;/li&gt;
                     &lt;li&gt;&lt;p&gt;GTS as an expression-syntax defined for a calendar. This aspect is the
GTS literal form.&lt;/p&gt;&lt;/li&gt;
                  </p>
<p>
In all cases the GTS is defined as a set of point in time (&lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;SET&apos;/&gt;&lt;/object&gt;
&lt;&lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;TS&apos;/&gt;&lt;/object&gt;&gt;). Using the set operations,
union, intersection and difference, more complex sets of time can be
constructed from simpler ones. Ultimately the building blocks from
which all GTS values are constructed are interval, periodic interval,
and event-related periodic interval. The construction of the GTS can
be specified in the literal form. No special data type structure is
defined that would generate a combination of simpler time-sets from a
given GTS value. While any implementation would have to contain such a
structured representation, it is not needed in order to exchange GTS
values given the literal form.&lt;object name=&apos;footnote&apos;&gt;The GTS is an example of a data type that is only defined
algebraically without giving any definition of a data structure that
might implement the behavior of such a data type. The algebraic
definition looks extremely simple, so that one might assume it is
incomplete. Since at this point we are relying entirely on the literal
form to represent GTS values, all the definition of data structur&lt;/object&gt;
				              </p>
<p>
The GTS data type is defined as using intervals, periodic intervals,
and event-related periodic intervals. Intervals of time have been
defined above
    </p>
<p>
A convex hull is the least interval that is a superset of all
occurrence intervals. As noted in , all
totally ordered sets have a convex hull. Because a GTS is a 
&lt;&gt; and because a 
&lt;&gt; is a totally ordered set, all
GTS values have a convex hull.
      
The convex hull of a GTS can less formally be called &quot;outer bound
interval&quot;. Thus, the convex hull of a GTS describes the absolute
beginning and end of the repeating schedule. For infinite repetitions
(e.g., a simple periodic interval) the convex hull has infinite
bounds.
      
						
						Convex Hull of a Schedule
					</p>
<p>
A  value is a generator of a sequence of time
intervals during which an event or activity occurs, or during which a
state is effective.
      
The nextTo-property maps to every point in
time t the greatest continuous subset (an &quot;occurrence
interval&quot;) v of the  value
S, where v is the interval closest to
t that begins later than t or that contains
t.
      
invariant(GTS S, TS t, IVL&lt;TS&gt; v) {
  v.equal(S.nextTo(t)).equal(
         S.contains(o)
    .and(forall(IVL&lt;TS&gt; u) where x.contains(u) {
           u.contains(v).implies(u.equal(v)); })
    .and(    v.contains(t)
         .or(forall(TS i) where t.lessOrEqual(i)
                           .and(i.lessThan(v.low)) {
               S.conatins(i).not; })));
};
      
The nextAfter-property maps to every point
in time t the greatest continuous subset (an &quot;occurrence
interval&quot;) v of the  value
S, where v is the interval closest to
t that begins later than t.
      
invariant(GTS S, TS t) where {
  S.contains(t).not
     .implies(S.nextAfter(t).equal(S.nextTo(t)));
  S.contains(t)
     .implies(S.nextAfter(t).equal(
            S.except(nextTo(t)).nextTo(t)));
};
      
A  value can be converted into a generic Sequence
of time intervals (&lt;&gt;)
of occurrence intervals.
      
invariant(GTS x) where x.isEmpty { ((LIST&lt;IVL&lt;TS&gt;&gt;)x).isEmpty; };

invariant(GTS x, IVL&lt;TS&gt; first)
    where x.notEmpty
     .and(x.hull.low.nonNull)
     .and(first.equal(x.nextTo(x.hull.low))
{
  ((LIST&lt;IVL&lt;TS&gt;&gt;)x).head.equal(first);
  ((LIST&lt;IVL&lt;TS&gt;&gt;)x).tail.equal(
             (LIST&lt;IVL&lt;TS&gt;&gt;)x.except(first));
};
      </p>
<p>
						
						Interleaving Schedules and Periodic Hull
					
For two  values A and B we
say that A interleaves B if their occurrence
intervals interleave on the time line. This concept is visualized in
Figure 15.
      
For the  values A and B
to interleave the occurrence intervals of both groups can be arranged
in pairs of corresponding occurrence intervals. It must further hold
that for all corresponding occurrence intervals a
&#8838; A and b &#8838; B,
a starts before b starts (or at the same
time) and b ends after a ends (or at the
same time).
      
The interleaves-relation holds when two schedules have the same
average frequency, and when the second schedule never &quot;outpaces&quot; the
first schedule. That is, no occurrence interval in the second schedule
may start before its corresponding occurrence interval in the first
schedule.
      
With two interleaving  values one can derive a
periodic hull such that the occurrence intervals of the periodic hull
is the convex hull of the corresponding occurrence intervals.
      
The periodic hull is important to construct two schedules by combining
 expressions. For example, to construct the periodic
interval from Memorial Day to Labor Day every year, one first needs to
set up the schedules M for Memorial Day (the last Monday
in May) and L for Labor Day (the first Monday in
September) and then combine these two schedules using the periodic
hull of M and L.
      
invariant(GTS A, B) where x.nonNull.and(y.nonNull) {
  A.interleaves(B).equal(
    forall(IVL&lt;TS&gt; a, b, c; TS t)
        where a.equal(A.nextTo(t))
         .and(b.equal(B.nextTo(a.low)))
         .and(c.equal(A.nextTo(b.high))) {
      b.equal(B.nextTo(a.high));
      a.low.lessOrEqual(b.low);
      c.equal(A.nextTo(b.high));
      c.equal(a).or(c.equal(A.nextAfter(a.high)));
    });
};
      
For two  values A and B
where A interleaves B, a periodic hull is
defined as the pair wise convex hull of the corresponding occurrence
intervals of A and B.
      
invariant(GTS A, B, C) where A.interleaves(B) {
  A.periodicHull(B).equal(C).equal(
    forall(IVL&lt;TS&gt; a, b; TS t)
        where a.equal(A.nextTo(t))
         .and(b.equal(B.nextTo(a.low))) {
      C.contains(c).equal(c.equal(a.hull(b)));
    });
};
      
The interleaves-relation is reflexive, asymmetric, and
intransitive. The periodic hull operation is non-commutative and
non-associative.
The interleaves property may appear overly constrained. However, these
constraints are reasonable for the use case for which the interleaves
and periodic hull properties are defined. To safely and predictably
combine two schedules one would want to know which of the operands
sets the start points and which sets the endpoints of the periodic
hull&apos;s occurrence intervals.
          
					</p>
]]></text>
            </annotation>
         </documentation>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="ADXP.SEARCH">
      <datatype isAbstract="false" name="ADXP.SEARCH" businessName="Address Part Search" visibility="protected" superType="ADXP" isMerged="false">
         <documentation>
            <businessName>Address Part Search</businessName>
            <annotation annotationType="USAGE_NOTES">
               <text><![CDATA[
<p>Use of ISO-3166-1 (alpha-3) is not permitted with this specification (alpha-2 is the only coding system suggested).  Using multiple methods (aplha-2, alpha-3 or numeric) would require implementors to support all methods.  The alpha-2 approach was used to be consistent with Canada Post.</p>
<p>
							&lt;li&gt;For example, Canada would be &quot;CA&quot; and British Columbia would be &quot;BC&quot;.  These are the same codes used by Canada Post.&lt;/li&gt;
							&lt;li&gt;&lt;a href=&apos;http://en.wikipedia.org/wiki/ISO_3166-1&apos;/&gt;.&lt;/li&gt;
						</p>
]]></text>
            </annotation>
            <annotation annotationType="CONSTRAINT">
               <text><![CDATA[Both address parts and delimiter-separated text are constrained to a length of 80 characters.]]></text>
            </annotation>
            <annotation annotationType="CONSTRAINT">
               <text><![CDATA[For country and state address parts, coded values are optional (taking advantages of the SC data type)]]></text>
            </annotation>
            <annotation annotationType="CONSTRAINT">
               <text><![CDATA[For country, code is restricted to ISO 3166-1 2-character alpha codes]]></text>
            </annotation>
            <annotation annotationType="CONSTRAINT">
               <text><![CDATA[For state, code is restricted to ISO 3166-2 code suffixes]]></text>
            </annotation>
         </documentation>
         <parentDatatype isAbstract="false" name="ADXP" businessName="AddressPart" visibility="protected" superType="SC" isMerged="false">
            <documentation>
               <businessName>AddressPart</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
A character string that may have a type-tag signifying its role in the
address. Typical parts that exist in about every address are street,
house number, or post box, postal code, city, country but other roles
may be defined regionally, nationally, or on an enterprise level
(e.g. in military addresses). Addresses are usually broken up into
lines, which are indicated by special line-breaking delimiter elements
(e.g., DEL).
    ]]></text>
               </annotation>
            </documentation>
         </parentDatatype>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="PQ.LAB">
      <datatype isAbstract="false" name="PQ.LAB" businessName="Laboratory Quantity" visibility="public" superType="PQ" isMerged="false">
         <documentation>
            <businessName>Laboratory Quantity</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[Used to express lab results which are "measured".]]></text>
            </annotation>
            <annotation annotationType="REQUIREMENTS">
               <text><![CDATA[Ballot comment #8]]></text>
            </annotation>
         </documentation>
         <staticExampleEntry annotationType="STATIC_EXAMPLE" businessName="25.6 ug per mg">
            <text><![CDATA[&lt;value unit=&apos;ug/mg&apos; flavorId=&apos;PQ.LAB&apos; value=&apos;25.6&apos; type=&apos;PQ&apos;&gt;
	
&lt;/value&gt;
]]></text>
         </staticExampleEntry>
         <parentDatatype isAbstract="false" name="PQ" businessName="PhysicalQuantity" visibility="public" superType="QTY" isMerged="false">
            <documentation>
               <businessName>PhysicalQuantity</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
A dimensioned quantity expressing the result of measuring.
    ]]></text>
               </annotation>
            </documentation>
         </parentDatatype>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="PQ.DISTANCE">
      <datatype isAbstract="false" name="PQ.DISTANCE" businessName="Distance Quantity" visibility="public" superType="PQ" isMerged="false">
         <documentation>
            <businessName>Distance Quantity</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[Used to express measurements of distance, specifically for geographic distances]]></text>
            </annotation>
         </documentation>
         <staticExampleEntry annotationType="STATIC_EXAMPLE" businessName="22 kilometers">
            <text><![CDATA[&lt;value unit=&apos;km&apos; flavorId=&apos;PQ.DISTANCE&apos; value=&apos;22&apos; type=&apos;PQ&apos;&gt;
	
&lt;/value&gt;
]]></text>
         </staticExampleEntry>
         <parentDatatype isAbstract="false" name="PQ" businessName="PhysicalQuantity" visibility="public" superType="QTY" isMerged="false">
            <documentation>
               <businessName>PhysicalQuantity</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
A dimensioned quantity expressing the result of measuring.
    ]]></text>
               </annotation>
            </documentation>
         </parentDatatype>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="TEL.ALL">
      <datatype isAbstract="true" name="TEL.ALL" businessName="Phone, E-mail or URI" visibility="public" superType="TEL" isMerged="false">
         <documentation>
            <businessName>Phone, E-mail or URI</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[Allows phone and fax numbers as well as e-mail addresses and web addresses to be communicated.]]></text>
            </annotation>
            <annotation annotationType="USAGE_NOTES">
               <text><![CDATA[This data type may be referenced in Canadian specifications. If this data type is used in a message instance, it must be declared as TEL.PHONE, TEL.EMAIL or TEL.URI for each repetition.]]></text>
            </annotation>
         </documentation>
         <parentDatatype isAbstract="false" name="TEL" businessName="TelecommunicationAddress" visibility="public" superType="URL" isMerged="false">
            <documentation>
               <businessName>TelecommunicationAddress</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
A telephone number (voice or fax), e-mail address, or other locator
for a resource mediated by telecommunication equipment. The address is
specified as a Universal Resource Locator (URL) qualified by time
specification and use codes that help in deciding which address to use
for a given time and purpose.
    ]]></text>
               </annotation>
               <annotation annotationType="DESIGN_COMMENTS">
                  <text><![CDATA[
<p>
The semantics of a telecommunication address is that a communicating
entity (the responder) listens and responds to that address, and
therefore can be contacted by an other communicating entity (the
initiator.)
    </p>
<p>
The responder of a telecommunication address may be an automatic
service that can respond with information (e.g., FTP or HTTP
services.)  In such case a telecommunication address is a reference to
that information accessible through that address. A telecommunication
address value can thus be resolved to some information (in the form of
encapsulated data, &lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;ED&apos;/&gt;&lt;/object&gt;.)
    </p>
<p>
The telecommunication address is an extension of the Universal
Resource Locator (&lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;URL&apos;/&gt;&lt;/object&gt;) specified according to Internet
standard RFC 2396 [&lt;a href=&apos;http://www.ietf.org/rfc/rfc2396.txt&apos;/&gt;].
The &lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;URL&apos;/&gt;&lt;/object&gt; specifies the protocol and the contact point
defined by that protocol for the resource. Notable use cases for the
telecommunication address data type are for telephone and fax numbers,
e-mail addresses, Hypertext references, FTP references, etc.
    </p>
]]></text>
               </annotation>
            </documentation>
         </parentDatatype>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="ANY.PATH">
      <datatype isAbstract="true" name="ANY.PATH" businessName="Pathology result types" visibility="public" superType="ANY" isMerged="false">
         <documentation>
            <businessName>Pathology result types</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[Used in a specification where the specific types to be communicated may vary.]]></text>
            </annotation>
            <annotation annotationType="USAGE_NOTES">
               <text><![CDATA[
<p>This data type may be referenced in Canadian specifications.  If this data type is used in a message instance, it must be declared as one of the constrained version of ANY (e.g. ST) for each repetition.</p>
<p>Each value sent over the wire must correspond to one of the non-abstract data type flavor specifications defined in this document.</p>
<p>The specific data type must be declared using xsi:type.</p>
<p>The use of this type is discouraged in specifications unless additional constraints are included indicating what specific data type flavors may be substituted.</p>
]]></text>
            </annotation>
         </documentation>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="CAL">
      <datatype isAbstract="false" name="CAL" businessName="Calendar" visibility="private" superType="SET" isMerged="false">
         <documentation>
            <businessName>Calendar</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[
A calendar is a concept of measuring time in various cycles. Such
cycles are years, months, days, hours, minutes, seconds, and
weeks. Some of these cycles are synchronized and some are not (e.g.,
weeks and months are not synchronized.)
      ]]></text>
            </annotation>
            <annotation annotationType="DESIGN_COMMENTS">
               <text><![CDATA[
<p>
After &quot;rolling the time axis&quot; into these cycles (See the figure)
a calendar expresses a point in time as a sequence
of integer counts of cycles, e.g., for year, month, day, hour,
etc. The calendar is rooted in some conventional start point, called
the &quot;epoch.&quot;
      </p>
<p></p>
<p>
A calendar &quot;rolls&quot; the time axis into a complex convolute according to
the calendar periods year (blue), month (yellow), day (green), hour
(red), etc. The cycles need not be aligned, for example, the week (not
shown) is not aligned to the month.&lt;object name=&apos;footnote&apos;&gt;Imagine a special clock that measures those cycles, where the pointers
are not all stacked on a common axis but each pointer is attached to
the end of the pointer measuring the next larger cycle.&lt;/object&gt;
                  </p>
<p>
Calendar is defined as a set of calendar cycles, and has a name and a
code. The head of the Calendar is the largest CalendarCycle appearing
right most in the calendar expression. The epoch is the beginning of
that calendar, i.e., the point in time where all calendar cycles are
zero.
      </p>
<p>
The calendar definition can be shown as in &lt;object name=&apos;conceptDomainRef&apos;&gt;&lt;param name=&apos;domain&apos; value=&apos;CalendarCycle&apos;/&gt;&lt;/object&gt;
for the modern Gregorian calendar. The calendar definition table lists a
calendar cycle in each row. The calendar units are dependent on each other and
defined in the value column. The sequence column shows the relationship through
the next property. The other columns are as in the formal calendar cycle
definition.&lt;object name=&apos;footnote&apos;&gt;At present, the CalendarCycle properties sum and value are not
formally defined. The computation of calendar digits involves some
complex computation which to specify here would be hard to understand
and evaluate for correctness. Unfortunately, no standard exists that
would formally define the relationship between calendar expressions
and elapsed time since an epoch. ASN.1, the XML Schema Data Type
specification and SQL92 all refer to ISO 8601, however, ISO 8601 does
only specify the syntax of Gregorian calendar expressions, but not
their semantics. In this standard, we define the syntax and semantics
formally, however, we presume the semantics of the sum-, and
value-properties to be defined elsewhere.&lt;/object&gt;
				              </p>
]]></text>
            </annotation>
         </documentation>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="IVL_TS.DATETIME">
      <datatype isAbstract="false" name="IVL_TS.DATETIME" businessName="Partial Date + Time Range" visibility="public" isMerged="false">
         <documentation>
            <businessName>Partial Date + Time Range</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[Used when a time range needs to be conveyed where the boundaries of the range can be imprecise.]]></text>
            </annotation>
            <annotation annotationType="USAGE_CONSTRAINT">
               <text><![CDATA[When sending over the wire, a maximum of two of low, high and width should be sent.]]></text>
            </annotation>
            <annotation annotationType="CONSTRAINT">
               <text><![CDATA[Low, high and width cannot have null flavors PINF or NINF]]></text>
            </annotation>
            <annotation annotationType="CONSTRAINT">
               <text><![CDATA[At least two of high, low and width must be *present* (though they can be null flavors) for the URG to satisfy a 'mandatory' constraint.]]></text>
            </annotation>
         </documentation>
         <staticExampleEntry annotationType="STATIC_EXAMPLE" businessName="from March 01, 2000 @ 3:00 PM to July 15, 2000 @ 4:00 AM (Alberta time)">
            <text><![CDATA[&lt;effectiveTime type=&apos;IVL_TS&apos;&gt;
	&lt;low flavorId=&apos;TS.DATETIME&apos; value=&apos;200003011500-0700&apos; type=&apos;TS&apos;/&gt;
	&lt;high flavorId=&apos;TS.DATETIME&apos; value=&apos;200007150400-0700&apos; type=&apos;TS&apos;/&gt;
&lt;/effectiveTime&gt;
]]></text>
         </staticExampleEntry>
         <staticExampleEntry annotationType="STATIC_EXAMPLE" businessName="beginning March 2000, not yet ended">
            <text><![CDATA[&lt;effectiveTime type=&apos;IVL_TS&apos;&gt;
	&lt;low flavorId=&apos;TS.DATE&apos; value=&apos;200003&apos; type=&apos;TS&apos;/&gt;
	&lt;high nullFlavor=&apos;NA&apos; flavorId=&apos;TS.DATE&apos; type=&apos;TS&apos;/&gt;
&lt;/effectiveTime&gt;
]]></text>
         </staticExampleEntry>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="ENXP">
      <datatype isAbstract="false" name="ENXP" businessName="EntityNamePart" visibility="protected" superType="SC" isMerged="false">
         <documentation>
            <businessName>EntityNamePart</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[
A character string token representing a part of a name. May have a
type code signifying the role of the part in the whole entity name,
and a qualifier code for more detail about the name part type.
Typical name parts for person names are given names, and family names,
titles, etc.
    ]]></text>
            </annotation>
         </documentation>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="UUID">
      <datatype isAbstract="false" name="UUID" businessName="UniversalUniqueIdentifier" visibility="protected" superType="UID" isMerged="false">
         <documentation>
            <businessName>UniversalUniqueIdentifier</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[
A globally unique string representing a DCE Universal Unique
Identifier (UUID) in the common UUID format that consists of 5
hyphen-separated groups of hexadecimal digits having 8, 4, 4, 4,
and 12 places respectively.
    ]]></text>
            </annotation>
            <annotation annotationType="DESIGN_COMMENTS">
               <text><![CDATA[
<p>
Both the UUID and its string representation are defined by the Open
Group, CDE 1.1 Remote Procedure Call specification, Appendix A.
    </p>
<p>
UUIDs are assigned based on Ethernet MAC addresses, the point in time
of creation and some random component. This mix is believed to
generate sufficiently unique identifiers without any organizational
policy for identifier assignment (in fact this piggy-backs on the
organization of MAC address assignment.)
    </p>
<p>
UUIDs are &lt;b&gt;not&lt;/b&gt; the preferred identifier
scheme for use as HL7 UIDs. UUIDs may be used when identifiers are
issued to objects representing individuals (e.g., entity instance
identifiers, act event identifiers, etc.) For objects describing
classes of things or events (e.g., catalog items), OIDs are the
preferred identifier scheme.
    </p>
]]></text>
            </annotation>
         </documentation>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="TEL.URI">
      <datatype isAbstract="false" name="TEL.URI" businessName="Uniform Resource Identifier" visibility="public" superType="TEL" isMerged="false">
         <documentation>
            <businessName>Uniform Resource Identifier</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[Used to communicate web addresses and other internet communication schemes.]]></text>
            </annotation>
            <annotation annotationType="CONSTRAINT">
               <text><![CDATA[Length of value must be less than or equal to 255]]></text>
            </annotation>
         </documentation>
         <staticExampleEntry annotationType="STATIC_EXAMPLE" businessName="">
            <text><![CDATA[&lt;telecom flavorId=&apos;TEL.URI&apos; value=&apos;https://www.someserver.ca/somelocation&apos; type=&apos;TEL&apos;&gt;
	
&lt;/telecom&gt;
]]></text>
         </staticExampleEntry>
         <parentDatatype isAbstract="false" name="TEL" businessName="TelecommunicationAddress" visibility="public" superType="URL" isMerged="false">
            <documentation>
               <businessName>TelecommunicationAddress</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
A telephone number (voice or fax), e-mail address, or other locator
for a resource mediated by telecommunication equipment. The address is
specified as a Universal Resource Locator (URL) qualified by time
specification and use codes that help in deciding which address to use
for a given time and purpose.
    ]]></text>
               </annotation>
               <annotation annotationType="DESIGN_COMMENTS">
                  <text><![CDATA[
<p>
The semantics of a telecommunication address is that a communicating
entity (the responder) listens and responds to that address, and
therefore can be contacted by an other communicating entity (the
initiator.)
    </p>
<p>
The responder of a telecommunication address may be an automatic
service that can respond with information (e.g., FTP or HTTP
services.)  In such case a telecommunication address is a reference to
that information accessible through that address. A telecommunication
address value can thus be resolved to some information (in the form of
encapsulated data, &lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;ED&apos;/&gt;&lt;/object&gt;.)
    </p>
<p>
The telecommunication address is an extension of the Universal
Resource Locator (&lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;URL&apos;/&gt;&lt;/object&gt;) specified according to Internet
standard RFC 2396 [&lt;a href=&apos;http://www.ietf.org/rfc/rfc2396.txt&apos;/&gt;].
The &lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;URL&apos;/&gt;&lt;/object&gt; specifies the protocol and the contact point
defined by that protocol for the resource. Notable use cases for the
telecommunication address data type are for telephone and fax numbers,
e-mail addresses, Hypertext references, FTP references, etc.
    </p>
]]></text>
               </annotation>
            </documentation>
         </parentDatatype>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="ST.LANG">
      <datatype isAbstract="false" name="ST.LANG" businessName="String with language" visibility="public" superType="ST.UV" isMerged="false">
         <documentation>
            <businessName>String with language</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[A string where there is a requirement to expose the language of the string. Effectively this means that attributes intended to convey the language of text must be explicitly declared as such]]></text>
            </annotation>
            <annotation annotationType="USAGE_NOTES">
               <text><![CDATA[Maximum length is determined by the referencing specification.]]></text>
            </annotation>
         </documentation>
         <staticExampleEntry annotationType="STATIC_EXAMPLE" businessName="">
            <text><![CDATA[&lt;name&gt;
	Royal Alexandra Hospital
&lt;/name&gt;
]]></text>
         </staticExampleEntry>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="II.BUSVER">
      <datatype isAbstract="false" name="II.BUSVER" businessName="Instance Identifier (Business with Version)" visibility="public" superType="II.BUS" isMerged="false">
         <documentation>
            <businessName>Instance Identifier (Business with Version)</businessName>
         </documentation>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="II.PUBLIC">
      <datatype isAbstract="false" name="II.PUBLIC" businessName="Instance Identifier (Public)" visibility="public" superType="II" isMerged="false">
         <documentation>
            <businessName>Instance Identifier (Public)</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[This is used to convey common public identifiers such as provider license numbers, jurisdictional PHNs, etc.]]></text>
            </annotation>
         </documentation>
         <staticExampleEntry annotationType="STATIC_EXAMPLE" businessName="Alberta PHN (ULI) 12356-7890">
            <text><![CDATA[&lt;id extension=&apos;123567890&apos; root=&apos;2.16.840.1.113883.4.20&apos; displayable=&apos;true&apos;&gt;
	
&lt;/id&gt;
]]></text>
         </staticExampleEntry>
         <parentDatatype isAbstract="false" name="II" businessName="InstanceIdentifier" visibility="public" superType="ANY" isMerged="false">
            <documentation>
               <businessName>InstanceIdentifier</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
An identifier that uniquely identifies a thing or object. Examples
are object identifier for HL7 RIM objects, medical record number,
order id, service catalog item id, Vehicle Identification Number
(VIN), etc. Instance identifiers are defined based on ISO object
identifiers.
    ]]></text>
               </annotation>
            </documentation>
         </parentDatatype>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="RTO_PQ.DRUG_PQ.TIME">
      <datatype isAbstract="false" name="RTO_PQ.DRUG_PQ.TIME" businessName="Drug Quantity per Time Duration" visibility="public" isMerged="false">
         <documentation>
            <businessName>Drug Quantity per Time Duration</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[Used to express a quantity of drug over a particular time-period.]]></text>
            </annotation>
         </documentation>
         <staticExampleEntry annotationType="STATIC_EXAMPLE" businessName="10 per day">
            <text><![CDATA[&lt;maxDoseQuantity type=&apos;RTO_PQ&apos;&gt;
	&lt;numerator flavorId=&apos;PQ.DRUG&apos; value=&apos;10&apos; type=&apos;PQ&apos;/&gt;
	&lt;denominator unit=&apos;d&apos; flavorId=&apos;PQ.TIME&apos; value=&apos;1&apos; type=&apos;PQ&apos;/&gt;
&lt;/maxDoseQuantity&gt;
]]></text>
         </staticExampleEntry>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="II">
      <datatype isAbstract="true" name="II" businessName="Instance Identifier" visibility="protected" superType="ANY" isMerged="true">
         <documentation>
            <businessName>Instance Identifier</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[
<p>The instance identifier data type is used to communicate all &quot;identifiers&quot;, including identifiers for people, records, versions, messages, etc.</p>
<p>This data type may be referenced in Canadian specifications. If this data type is used in a message instance, it must be declared as one of the constrained version of II (e.g. II.OID) for each repetition.</p>
]]></text>
            </annotation>
            <annotation annotationType="USAGE_NOTES">
               <text><![CDATA[
<p>all</p>
]]></text>
            </annotation>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[
An identifier that uniquely identifies a thing or object. Examples
are object identifier for HL7 RIM objects, medical record number,
order id, service catalog item id, Vehicle Identification Number
(VIN), etc. Instance identifiers are defined based on ISO object
identifiers.
    ]]></text>
            </annotation>
         </documentation>
         <parentDatatype isAbstract="false" name="II" businessName="InstanceIdentifier" visibility="public" superType="ANY" isMerged="false">
            <documentation>
               <businessName>InstanceIdentifier</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
An identifier that uniquely identifies a thing or object. Examples
are object identifier for HL7 RIM objects, medical record number,
order id, service catalog item id, Vehicle Identification Number
(VIN), etc. Instance identifiers are defined based on ISO object
identifiers.
    ]]></text>
               </annotation>
            </documentation>
         </parentDatatype>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="PN.FULL">
      <datatype isAbstract="false" name="PN.FULL" businessName="Full Person Name" visibility="public" superType="PN" isMerged="false">
         <documentation>
            <businessName>Full Person Name</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[Used to express person names within a registry where full qualification is needed.]]></text>
            </annotation>
            <annotation annotationType="USAGE_NOTES">
               <text><![CDATA[There is no constraint on the allowed values of either the "prefix" or "suffix" components.  The requirement for middle name is met through additional repetitions of "given names".  Designation is met through use of the "suffix".]]></text>
            </annotation>
            <annotation annotationType="CONSTRAINT">
               <text><![CDATA[No more than seven name parts must be present.]]></text>
            </annotation>
            <annotation annotationType="CONSTRAINT">
               <text><![CDATA[Declaration of part types is mandatory.  I.e. All name parts must be typed.  Plain strings and mixed content is prohibited]]></text>
            </annotation>
         </documentation>
         <staticExampleEntry annotationType="STATIC_EXAMPLE" businessName="">
            <text><![CDATA[&lt;name flavorId=&apos;PN.FULL&apos; use=&apos;L&apos; type=&apos;PN&apos;&gt;
	&lt;prefix&gt;Mr&lt;/prefix&gt;
	&lt;given&gt;John&lt;/given&gt;
	&lt;given qualifier=&apos;IN&apos;&gt;W&lt;/given&gt;
	&lt;family&gt;Smith&lt;/family&gt;
&lt;/name&gt;
]]></text>
         </staticExampleEntry>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="ADXP.FULL">
      <datatype isAbstract="false" name="ADXP.FULL" businessName="Address Part Full" visibility="protected" superType="ADXP" isMerged="false">
         <documentation>
            <businessName>Address Part Full</businessName>
            <annotation annotationType="USAGE_NOTES">
               <text><![CDATA[
<p>Use of ISO-3166-1 (alpha-3) is not permitted with this specification (alpha-2 is the only coding system suggested).  Using multiple methods (aplha-2, alpha-3 or numeric) would require implementors to support all methods.  The alpha-2 approach was used to be consistent with Canada Post.</p>
<p>
							&lt;li&gt;For example, Canada would be &quot;CA&quot; and British Columbia would be &quot;BC&quot;.  These are the same codes used by Canada Post.&lt;/li&gt;
							&lt;li&gt;&lt;a href=&apos;http://en.wikipedia.org/wiki/ISO_3166-1&apos;/&gt;.&lt;/li&gt;
						</p>
]]></text>
            </annotation>
            <annotation annotationType="CONSTRAINT">
               <text><![CDATA[Both address parts and delimiter-separated text are constrained to a length of 80 characters.]]></text>
            </annotation>
            <annotation annotationType="CONSTRAINT">
               <text><![CDATA[For country and state address parts, coded values are optional (taking advantages of the SC data type)]]></text>
            </annotation>
            <annotation annotationType="CONSTRAINT">
               <text><![CDATA[For country, code is restricted to ISO 3166-1 2-character alpha codes]]></text>
            </annotation>
            <annotation annotationType="CONSTRAINT">
               <text><![CDATA[For state, code is restricted to ISO 3166-2 code suffixes]]></text>
            </annotation>
         </documentation>
         <parentDatatype isAbstract="false" name="ADXP" businessName="AddressPart" visibility="protected" superType="SC" isMerged="false">
            <documentation>
               <businessName>AddressPart</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
A character string that may have a type-tag signifying its role in the
address. Typical parts that exist in about every address are street,
house number, or post box, postal code, city, country but other roles
may be defined regionally, nationally, or on an enterprise level
(e.g. in military addresses). Addresses are usually broken up into
lines, which are indicated by special line-breaking delimiter elements
(e.g., DEL).
    ]]></text>
               </annotation>
            </documentation>
         </parentDatatype>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="IVL_TS.DATE">
      <datatype isAbstract="false" name="IVL_TS.DATE" businessName="Partial Date Range" visibility="public" isMerged="false">
         <documentation>
            <businessName>Partial Date Range</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[This data type is used when a date range needs to be conveyed where neither the start nor end date will always be known to the complete date]]></text>
            </annotation>
            <annotation annotationType="USAGE_CONSTRAINT">
               <text><![CDATA[When sending over the wire, a maximum of two of low, high and width should be sent.]]></text>
            </annotation>
            <annotation annotationType="CONSTRAINT">
               <text><![CDATA[Low, high and width cannot have null flavors PINF or NINF]]></text>
            </annotation>
            <annotation annotationType="CONSTRAINT">
               <text><![CDATA[At least two of high, low and width must be *present* (though they can be null flavors) for the URG to satisfy a 'mandatory' constraint.]]></text>
            </annotation>
         </documentation>
         <staticExampleEntry annotationType="STATIC_EXAMPLE" businessName="from March 01, 2000 to July 2000">
            <text><![CDATA[&lt;effectiveTime type=&apos;IVL_TS&apos;&gt;
	&lt;low flavorId=&apos;TS.DATE&apos; value=&apos;20000301&apos; type=&apos;TS&apos;/&gt;
	&lt;high flavorId=&apos;TS.DATE&apos; value=&apos;200007&apos; type=&apos;TS&apos;/&gt;
&lt;/effectiveTime&gt;
]]></text>
         </staticExampleEntry>
         <staticExampleEntry annotationType="STATIC_EXAMPLE" businessName="beginning March 2000, not yet ended">
            <text><![CDATA[&lt;effectiveTime type=&apos;IVL_TS&apos;&gt;
	&lt;low flavorId=&apos;TS.DATE&apos; value=&apos;200003&apos; type=&apos;TS&apos;/&gt;
	&lt;high nullFlavor=&apos;NA&apos; flavorId=&apos;TS.DATE&apos; type=&apos;TS&apos;/&gt;
&lt;/effectiveTime&gt;
]]></text>
         </staticExampleEntry>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="II.PUBLICVER">
      <datatype isAbstract="false" name="II.PUBLICVER" businessName="Instance Identifier (Public with Version)" visibility="public" superType="II.PUBLIC" isMerged="false">
         <documentation>
            <businessName>Instance Identifier (Public with Version)</businessName>
         </documentation>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="SLIST">
      <datatype isAbstract="false" name="SLIST" businessName="SampledSequence" visibility="public" superType="LIST" isMerged="false">
         <documentation>
            <businessName>SampledSequence</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[
A sequence of sampled values scaled and translated from a list of
integer values.  Used to specify sampled biosignals.
    ]]></text>
            </annotation>
            <annotation annotationType="DESIGN_COMMENTS">
               <text><![CDATA[
<p>
The item at a certain index (&lt;var&gt;i&lt;/var&gt;) in the list is calculated
by multiplying the item at the same index in the
&lt;object name=&apos;propertyRef&apos;&gt;&lt;param name=&apos;propertyName&apos; value=&apos;digits&apos;/&gt;
                        &lt;param name=&apos;datatypeName&apos; value=&apos;SLIST&apos;/&gt;&lt;/object&gt; sequence
(&lt;var&gt;d&lt;/var&gt;
					                &lt;sub&gt;&lt;var&gt;i&lt;/var&gt;&lt;/sub&gt;) with the &lt;object name=&apos;propertyRef&apos;&gt;&lt;param name=&apos;propertyName&apos; value=&apos;scale&apos;/&gt;
                        &lt;param name=&apos;datatypeName&apos; value=&apos;SLIST&apos;/&gt;&lt;/object&gt; (&lt;var&gt;s&lt;/var&gt;)
          and then add that value to the &lt;object name=&apos;propertyRef&apos;&gt;&lt;param name=&apos;propertyName&apos; value=&apos;origin&apos;/&gt;
                        &lt;param name=&apos;datatypeName&apos; value=&apos;SLIST&apos;/&gt;&lt;/object&gt;
(&lt;var&gt;x&lt;/var&gt;
					                &lt;sub&gt;&lt;var&gt;o&lt;/var&gt;&lt;/sub&gt; ).
    </p>
<p>
                     &lt;p&gt;&lt;var&gt;x&lt;/var&gt;
						                  &lt;sub&gt;&lt;var&gt;i&lt;/var&gt;&lt;/sub&gt;
=
&lt;var&gt;x&lt;/var&gt;
						                  &lt;sub&gt;&lt;var&gt;o&lt;/var&gt;&lt;/sub&gt;
+
&lt;var&gt;s&lt;/var&gt;
&#215;
&lt;var&gt;d&lt;/var&gt;
						                  &lt;sub&gt;&lt;var&gt;i&lt;/var&gt;&lt;/sub&gt;&lt;/p&gt;
                  </p>
]]></text>
            </annotation>
         </documentation>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="IVL.WIDTH">
      <datatype isAbstract="false" name="IVL.WIDTH" businessName="Duration" visibility="protected" superType="IVL" isMerged="false">
         <documentation>
            <businessName>Duration</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[This data type is used to convey the width of an interval where low and high are not needed.]]></text>
            </annotation>
            <annotation annotationType="CONSTRAINT">
               <text><![CDATA[High and low are Unknown]]></text>
            </annotation>
         </documentation>
         <parentDatatype isAbstract="false" name="IVL" businessName="Interval" visibility="public" superType="SET" isMerged="false">
            <documentation>
               <businessName>Interval</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
A set of consecutive values of an ordered base data type.
    ]]></text>
               </annotation>
               <annotation annotationType="DESIGN_COMMENTS">
                  <text><![CDATA[
<p>
Any ordered type can be the basis of an interval; it does not matter
whether the base type is discrete or continuous. If the base data type
is only partially ordered, all elements of the interval must be
elements of a totally ordered subset of the partially ordered data
type.
    </p>
<p>
For example, physical quantities are considered ordered. However the
ordering of physical quantities is only partial; a total order is only
defined among comparable quantities (quantities of the same physical
dimension.)  While intervals between 2 and 4 meter exists, there is no
interval between 2 meters and 4 seconds.
    </p>
<p>
Intervals are sets and have all the properties of sets. However, union
and differences of intervals may not be intervals any more, since the
elements of these union and difference sets might not be
contiguous. Intersections of intervals are always intervals.
    </p>
]]></text>
               </annotation>
            </documentation>
         </parentDatatype>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="AD">
      <datatype isAbstract="false" name="AD" businessName="PostalAddress" visibility="public" superType="LIST" isMerged="false">
         <documentation>
            <businessName>PostalAddress</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[
Mailing and home or office addresses. A sequence of address parts,
such as street or post office Box, city, postal code, country, etc.
    ]]></text>
            </annotation>
            <annotation annotationType="DESIGN_COMMENTS">
               <text><![CDATA[
<p>
The &lt;object name=&apos;itemName&apos;&gt;&lt;param name=&apos;item&apos; value=&apos;datatype&apos;/&gt;&lt;/object&gt; is primarily used to communicate data that will allow
printing mail labels, that will allow a person to physically visit
that address. The postal address data type is not supposed to be a
container for additional information that might be useful for finding
geographic locations (e.g., GPS coordinates) or for performing
epidemiological studies. Such additional information is captured by
other, more appropriate HL7 elements.
    </p>
<p>
Addresses are conceptualized as text with added logical mark-up. The
mark-up may break the address into lines and may describe in detail
the role of each address part if it is known. Address parts occur in
the address in the order in which they would be printed on a mailing
label. The approach is similar to HTML or XML markup of text (but it
is not technically limited to XML representations.)
    </p>
<p>
Addresses are essentially sequences of address parts, but add a &quot;use&quot;
code and a valid time range for information about if and when the
address can be used for a given purpose.
    </p>
]]></text>
            </annotation>
         </documentation>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="II.BUS_AND_VER">
      <datatype isAbstract="true" name="II.BUS_AND_VER" businessName="Instance Identifier (Business and Version)" visibility="public" superType="II" isMerged="false">
         <documentation>
            <businessName>Instance Identifier (Business and Version)</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[
<p>This type is used when an attribute is intended to be used to convey two types of identifiers - a business identifier and a version identifier.</p>
<p>This data type may be referenced in Canadian specifications. If this data type is used in a message instance, it must be declared as one of the constrained version of II.BUS_AND_VER (e.g. II.VER) for each repetition</p>
]]></text>
            </annotation>
            <annotation annotationType="USAGE_NOTES">
               <text><![CDATA[Each value sent over the wire for the two repetitions must correspond to each of the non-abstract data type flavor specifications defined in this document (i.e. II.BUS, II.VER).]]></text>
            </annotation>
         </documentation>
         <parentDatatype isAbstract="false" name="II" businessName="InstanceIdentifier" visibility="public" superType="ANY" isMerged="false">
            <documentation>
               <businessName>InstanceIdentifier</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
An identifier that uniquely identifies a thing or object. Examples
are object identifier for HL7 RIM objects, medical record number,
order id, service catalog item id, Vehicle Identification Number
(VIN), etc. Instance identifiers are defined based on ISO object
identifiers.
    ]]></text>
               </annotation>
            </documentation>
         </parentDatatype>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="RTO_MO.CAD_PQ.BASIC">
      <datatype isAbstract="false" name="RTO_MO.CAD_PQ.BASIC" businessName="Money per Unit Quantity" visibility="public" isMerged="false">
         <documentation>
            <businessName>Money per Unit Quantity</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[Used to express a monetary value over quantity.]]></text>
            </annotation>
         </documentation>
         <staticExampleEntry annotationType="STATIC_EXAMPLE" businessName="$20 per gram">
            <text><![CDATA[&lt;unitPriceAmt type=&apos;RTO_PQ&apos;&gt;
	&lt;numerator flavorId=&apos;MO.CAD&apos; value=&apos;20.00&apos; type=&apos;MO&apos;/&gt;
	&lt;denominator unit=&apos;gram&apos; flavorId=&apos;PQ.BASIC&apos; value=&apos;1&apos; type=&apos;PQ&apos;/&gt;
&lt;/unitPriceAmt&gt;
]]></text>
         </staticExampleEntry>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="PQ">
      <datatype isAbstract="false" name="PQ" businessName="PhysicalQuantity" visibility="public" superType="QTY" isMerged="false">
         <documentation>
            <businessName>PhysicalQuantity</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[
A dimensioned quantity expressing the result of measuring.
    ]]></text>
            </annotation>
         </documentation>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="TS.FULLDATE">
      <datatype isAbstract="false" name="TS.FULLDATE" businessName="Timestamp (Date)" visibility="public" superType="TS" isMerged="false">
         <documentation>
            <businessName>Timestamp (Date)</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[Only permits the "date" portion of the timestamp to be specified. Does not allow for partial dates.]]></text>
            </annotation>
            <annotation annotationType="USAGE_NOTES">
               <text><![CDATA[
<p>The string literal representation of this form is YYYYMMDD (8 characters).</p>
<p>Dates specified must be valid dates.</p>
]]></text>
            </annotation>
            <annotation annotationType="CONSTRAINT">
               <text><![CDATA[If the value is not null, there SHALL be 8 digits in the literal form, with no timezone. This flavor is specific to the gregorian calendar.]]></text>
            </annotation>
         </documentation>
         <staticExampleEntry annotationType="STATIC_EXAMPLE" businessName="">
            <text><![CDATA[&lt;effectiveTime flavorId=&apos;TS.FULLDATE&apos; value=&apos;20050802&apos; type=&apos;TS&apos;&gt;
	
&lt;/effectiveTime&gt;
]]></text>
         </staticExampleEntry>
         <parentDatatype isAbstract="false" name="TS" businessName="PointInTime" visibility="public" superType="QTY" isMerged="false">
            <documentation>
               <businessName>PointInTime</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
A quantity specifying a point on the axis of natural time. A point
in time is most often represented as a calendar expression.
    ]]></text>
               </annotation>
               <annotation annotationType="DESIGN_COMMENTS">
                  <text><![CDATA[
<p>
Semantically, however, time is independent from calendars and best
described by its relationship to elapsed time (measured as a physical
quantity in the dimension of time.)  A point in time plus an elapsed
time yields another point in time.  Inversely, a point in time minus
another point in time yields an elapsed time.
    </p>
<p>
As nobody knows when time began, a point in time is conceptualized as
the amount of time that has elapsed from some arbitrary zero-point,
called an epoch.  Because there is no absolute zero-point on the time
axis natural time is a difference-scale quantity, where only
differences are defined but no ratios. (For example, no point in time
is &#8212; absolutely speaking &#8212; &quot;twice as late&quot; as another
point in time.)
    </p>
<p>
Given some arbitrary zero-point, one can express any point in time as
an elapsed time measured from that offset. Such an arbitrary
zero-point is called an epoch. This epoch-offset form is used as a
semantic representation here, without implying that any system would
have to implement the TS data type in that way. Systems that do not
need to compute distances between points in time will not need any
other representation than a calendar expression literal.
    </p>
]]></text>
               </annotation>
            </documentation>
         </parentDatatype>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="TS.FULLDATEWITHTIME">
      <datatype isAbstract="false" name="TS.FULLDATEWITHTIME" businessName="Timestamp (Date or DateTime)" visibility="public" superType="TS" isMerged="false">
         <documentation>
            <businessName>Timestamp (Date or DateTime)</businessName>
         </documentation>
         <parentDatatype isAbstract="false" name="TS" businessName="PointInTime" visibility="public" superType="QTY" isMerged="false">
            <documentation>
               <businessName>PointInTime</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
A quantity specifying a point on the axis of natural time. A point
in time is most often represented as a calendar expression.
    ]]></text>
               </annotation>
               <annotation annotationType="DESIGN_COMMENTS">
                  <text><![CDATA[
<p>
Semantically, however, time is independent from calendars and best
described by its relationship to elapsed time (measured as a physical
quantity in the dimension of time.)  A point in time plus an elapsed
time yields another point in time.  Inversely, a point in time minus
another point in time yields an elapsed time.
    </p>
<p>
As nobody knows when time began, a point in time is conceptualized as
the amount of time that has elapsed from some arbitrary zero-point,
called an epoch.  Because there is no absolute zero-point on the time
axis natural time is a difference-scale quantity, where only
differences are defined but no ratios. (For example, no point in time
is &#8212; absolutely speaking &#8212; &quot;twice as late&quot; as another
point in time.)
    </p>
<p>
Given some arbitrary zero-point, one can express any point in time as
an elapsed time measured from that offset. Such an arbitrary
zero-point is called an epoch. This epoch-offset form is used as a
semantic representation here, without implying that any system would
have to implement the TS data type in that way. Systems that do not
need to compute distances between points in time will not need any
other representation than a calendar expression literal.
    </p>
]]></text>
               </annotation>
            </documentation>
         </parentDatatype>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="NPPD">
      <datatype isAbstract="false" name="NPPD" businessName="NonParametricProbabilityDistribution" visibility="public" superType="SET" isMerged="false">
         <documentation>
            <businessName>NonParametricProbabilityDistribution</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[
A set of uncertain values with probabilities (also known as
histogram.) All the elements in the set are considered alternatives
and are rated each with its probability expressing the belief (or
frequency) that each given value holds.
    ]]></text>
            </annotation>
            <annotation annotationType="DESIGN_COMMENTS">
               <text><![CDATA[
<p>
The purpose of the non-parametric probability distribution is chiefly
to support statistical data reporting as it occurs in measurements
taken from many subjects and consolidated in a histogram. This occurs
in epidemiology, veterinary medicine, laboratory medicine, but also in
cost controlling and business process engineering.
    </p>
<p>
Semantically, the information of a stated value exists in contrast to
the complement set of unstated possible values. Thus, semantically, a
non-parametric probability distribution contains &lt;b&gt;all&lt;/b&gt;
possible values and assigns probabilities to each of them.
    </p>
<p>
The easiest way to visualize this is a bar chart as shown in
    </p>
<p></p>
<p>
This example illustrates the probability of selected major league
baseball teams winning the World Series (prior to the season
start). Each team is mutually exclusive, and were we to include all of
the teams, the sum of the probabilities would equal 1 (i.e., it is
certain that one of the teams will win).
    </p>
<p>
Just as with &lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;UVP&apos;/&gt;&lt;/object&gt;, the type T is not formally
constrained, even though there are reasonable and unreasonable
uses. Typically one would use the &lt;object name=&apos;itemName&apos;&gt;&lt;param name=&apos;item&apos; value=&apos;datatype&apos;/&gt;&lt;/object&gt; for unordered types, if
only a &quot;small&quot; set of possible values is assigned explicit
probabilities, or if the probability distribution cannot (or should
not) be approximated with parametric methods. For other cases, one may
prefer &lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;PPD&apos;/&gt;&lt;/object&gt;.
    </p>
]]></text>
            </annotation>
         </documentation>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="HXIT">
      <datatype isAbstract="false" name="HXIT" businessName="HistoryItem" visibility="protected" superType="T" isMerged="false">
         <documentation>
            <businessName>HistoryItem</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[
A generic data type extension that tags a time range to any data value
of any data type.  The time range is the time in which the information
represented by the value is (was) valid.
    ]]></text>
            </annotation>
            <annotation annotationType="DESIGN_COMMENTS">
               <text><![CDATA[
<p>
If the base type T does not possess a validTime property, the
&lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;HXIT&apos;/&gt;&lt;/object&gt; adds that property to the base type. If, however,
the base type T does have a valid time property (currently only EN),
that property is mapped to the valid time property of the
&lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;HXIT&apos;/&gt;&lt;/object&gt;.&lt;object name=&apos;footnote&apos;&gt;Note that data types are specifications of abstract properties of
values. This specification does not mandate how these values are
represented in an ITS or implemented in an application. Specifically,
it does not mandate how the represented components are named or
positioned. In addition, the semantic generalization hierarchy may be
different from a class hierarchy chosen for implementation (if the
implementation technology has inheritance.)  Keep the distinction
between a type (interface) and an implementation (concrete data
structure, class) in mind. The ITS must contain a mapping of ITS
defined features of any data type to the semantic properties defined
here.&lt;/object&gt;
				              </p>
]]></text>
            </annotation>
         </documentation>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="OID">
      <datatype isAbstract="false" name="OID" businessName="ObjectIdentifier" visibility="protected" superType="UID, LIST" isMerged="false">
         <documentation>
            <businessName>ObjectIdentifier</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[
A globally unique string representing an ISO Object Identifier
(OID) in a form that consists only of numbers and dots (e.g.,
"2.16.840.1.113883.3.1"). According to ISO, OIDs are paths in a tree
structure, with the left-most number representing the root and the
right-most number representing a leaf.
    ]]></text>
            </annotation>
            <annotation annotationType="DESIGN_COMMENTS">
               <text><![CDATA[
<p>
Each branch under the root corresponds to an assigning authority. Each
of these assigning authorities may, in turn, designate its own set of
assigning authorities that work under its auspices, and so on down the
line. Eventually, one of these authorities assigns a unique (to it as
an assigning authority) number that corresponds to a leaf node on the
tree. The leaf may represent an assigning authority (in which case the
root OID identifies the authority), or an instance of an object. An
assigning authority owns a namespace, consisting of its sub-tree.
    </p>
<p>
OIDs are the preferred scheme for unique identifiers. OIDs should
always be used except if one of the inclusion criteria for other
schemes apply.
    </p>
<p>
ISO/IEC 8824:1990(E) clause 28 defines the Object Identifier as
    </p>
<p>
                     &lt;p&gt;&lt;b&gt;28.9&lt;/b&gt; The semantics of an
object identifier value are defined by reference to an &lt;b&gt;object identifier tree&lt;/b&gt;. An object identifier tree is a tree whose root
corresponds to [the ISO/IEC 8824 standard] and whose vertices [i.e. nodes]
correspond to administrative authorities responsible for allocating arcs [i.e.
branches] from that vertex. Each arc from that tree is labeled by an object
identifier component, which is [an integer number]. Each information object to
be identified is allocated precisely one vertex (normally a leaf) and no other
information object (of the same or a different type) is allocated to
that same vertex. Thus an information object is uniquely and
unambiguously identified by the sequence of [integer numbers] (object
identifier components) labeling the arcs in a path from the root to
the vertex allocated to the information object.&lt;/p&gt;
                     &lt;p&gt;&lt;b&gt;28.10&lt;/b&gt; An object identifier value is
semantically an ordered list of object identifier component
values. Starting with the root of the object identifier tree, each
object identifier component value identifies an arc in the object
identifier tree. The last object identifier component value identifies
an arc leading to a vertex to which an information object has been
assigned. It is this information object, which is identified by the
object identifier value. [...]&lt;/p&gt;
                  </p>
<p>
According to ISO/IEC 8824 an object identifier is a sequence of object
identifier component values, which are integer numbers. These
component values are ordered such that the root of the object
identifier tree is the head of the list followed by all the arcs down
to the leaf representing the information object identified by the
OID. The fact that OID specializes &lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;LIST&apos;/&gt;&lt;/object&gt;&lt;
&lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;INT&apos;/&gt;&lt;/object&gt;&gt; represents this path of object identifier component
values from the root to the leaf.
    </p>
<p>
The &lt;b&gt;leaf&lt;/b&gt; and &quot;&lt;b&gt;butLeaf&lt;/b&gt;&quot;
properties take the opposite view. The
leaf is the last object identifier component value in the list, and
the &quot;butLeaf&quot; property is all of the OID &lt;b&gt;but&lt;/b&gt; the
&lt;b&gt;leaf&lt;/b&gt;. In a sense, the leaf is the identifier value and
all of the OID but the leaf refers to the namespace in which the leaf
is unique and meaningful.
    </p>
<p>
However, what part of the OID is considered &lt;b&gt;value&lt;/b&gt;
and what is &lt;b&gt;namespace&lt;/b&gt; may be viewed differently. In
general, any OID component sequence to the left can be considered the namespace
in which the rest of the sequence to the right is defined as a
meaningful and unique identifier value. The value-property with a
namespace OID as its argument represents this point of view.&lt;object name=&apos;footnote&apos;&gt;The value/namespace view on ISO object identifiers has important
semantic relevance. It represents the notion of identifier value
versus identifier assigning authority (= namespace), which is common
in healthcare information systems in general, and HL7 v2.x in
particular.&lt;/object&gt;
				              </p>
<p>section-OID.procedures
HL7 shall establish an OID registry and assign OIDs in its branch for
HL7 users and vendors upon their request. HL7 shall also assign OIDs
to public identifier-assigning authorities both U.S. nationally (e.g.,
the U.S. State driver license bureaus, U.S. Social Security
Administration, HIPAA Provider ID registry, etc.) and internationally
(e.g., other countries Social Security Administrations, Citizen ID
registries, etc.) The HL7 registered OIDs must be used for these
organizations, regardless whether these organizations have other OIDs
assigned from other sources.
      
When assigning OIDs to third parties or entities, HL7 shall
investigate whether an OID is already assigned for such entities
through other sources. It this is the case, HL7 shall record such OID
in a catalog, but HL7 shall not assign a duplicate OID in the HL7
branch. If possible, HL7 shall notify a third party when an OID is
being assigned for that party in the HL7 branch.
      
Though HL7 shall exercise diligence before assigning an OID in the HL7
branch to third parties, given the lack of a global OID registry
mechanism, one cannot make absolutely certain that there is no
preexisting OID assignment for such third-party entity. Also, a
duplicate assignment can happen in the future through another
source. If such cases of supplicate assignment become known to HL7,
HL7 shall make efforts to resolve this situation. For continued
interoperability in the meantime, the HL7 assigned OID shall be the
preferred OID used.
      
While most owners of an OID will &quot;design&quot; their namespace sub-tree in
some meaningful way, there is no way to generally infer any meaning on
the parts of an OID. HL7 does not standardize or require any namespace
sub-structure. An OID owner, or anyone having knowledge about the
logical structure of part of an OID, may still use that knowledge to
infer information about the associated object; however, the techniques
cannot be generalized.
      
						Example for a tree of ISO object identifiers. HL7&apos;s OID
        is 2.16.840.1.113883.
						
					
						An HL7 interface must not rely on any
knowledge about the substructure of an OID for which it cannot control the
assignment policies.
					</p>
]]></text>
            </annotation>
         </documentation>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="HIST">
      <datatype isAbstract="false" name="HIST" businessName="History" visibility="public" superType="SET" isMerged="false">
         <documentation>
            <businessName>History</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[
A set of data values that have a a valid-time property and thus
conform to the history item (HXIT) type. The history information is
not limited to the past; expected future values can also appear.
      ]]></text>
            </annotation>
            <annotation annotationType="DESIGN_COMMENTS">
               <text><![CDATA[
<p>
The intent of the HIST data type is to capture the true historical
(and future) values of an item, rather than the audit trail of
values any given system has held for the item
      </p>
]]></text>
            </annotation>
         </documentation>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="RTO">
      <datatype isAbstract="false" name="RTO" businessName="Ratio" visibility="public" superType="QTY" isMerged="false">
         <documentation>
            <businessName>Ratio</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[
<p>
                     &lt;param name=&apos;item&apos; value=&apos;datatype&apos;/&gt;
                  </p>
<p>
                     &lt;param name=&apos;datatypeName&apos; value=&apos;REAL&apos;/&gt;
                  </p>
<p>
                     &lt;param name=&apos;item&apos; value=&apos;datatype&apos;/&gt;
                  </p>
]]></text>
            </annotation>
            <annotation annotationType="DESIGN_COMMENTS">
               <text><![CDATA[
<p>
Ratios are different from rational numbers, i.e., in ratios common
factors in the numerator and denominator never cancel out.  A ratio of
two real or integer numbers is not automatically reduced to a real
number.
    </p>
<p>
The default value for both numerator and denominator is the integer
number 1 (one.) The denominator may not be zero.
    </p>
]]></text>
            </annotation>
         </documentation>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="TN">
      <datatype isAbstract="false" name="TN" businessName="TrivialName" visibility="public" superType="EN" isMerged="false">
         <documentation>
            <businessName>TrivialName</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[
A restriction of entity name that is effectively a simple string used
for a simple name for things and places.
    ]]></text>
            </annotation>
            <annotation annotationType="DESIGN_COMMENTS">
               <text><![CDATA[
<p>
The &lt;object name=&apos;itemName&apos;&gt;&lt;param name=&apos;item&apos; value=&apos;datatype&apos;/&gt;&lt;/object&gt; is a &lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;EN&apos;/&gt;&lt;/object&gt; that consists of only one name
part without any name part type or qualifier. The &lt;object name=&apos;itemName&apos;&gt;&lt;param name=&apos;item&apos; value=&apos;datatype&apos;/&gt;&lt;/object&gt;, and its
single name part are therefore equivalent to a simple character
string. This equivalence is expressed by a defined demotion to
&lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;ST&apos;/&gt;&lt;/object&gt; and promotion from &lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;ST&apos;/&gt;&lt;/object&gt;.
    </p>
<p>
Trivial names are typically used for places and things, such as
&lt;b&gt;Lake Erie&lt;/b&gt; or &lt;b&gt;Reagan National Airport&lt;/b&gt;:
    </p>
]]></text>
            </annotation>
         </documentation>
         <staticExampleEntry annotationType="STATIC_EXAMPLE" businessName="">
            <text><![CDATA[&lt;example noxmlspace=&apos;preserve&apos;&gt;
	&lt;name&gt;Lake Erie&lt;/name&gt;
	&lt;name&gt;Washington National Airport&lt;/name&gt;
&lt;/example&gt;
]]></text>
         </staticExampleEntry>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="TS">
      <datatype isAbstract="false" name="TS" businessName="PointInTime" visibility="public" superType="QTY" isMerged="false">
         <documentation>
            <businessName>PointInTime</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[
A quantity specifying a point on the axis of natural time. A point
in time is most often represented as a calendar expression.
    ]]></text>
            </annotation>
            <annotation annotationType="DESIGN_COMMENTS">
               <text><![CDATA[
<p>
Semantically, however, time is independent from calendars and best
described by its relationship to elapsed time (measured as a physical
quantity in the dimension of time.)  A point in time plus an elapsed
time yields another point in time.  Inversely, a point in time minus
another point in time yields an elapsed time.
    </p>
<p>
As nobody knows when time began, a point in time is conceptualized as
the amount of time that has elapsed from some arbitrary zero-point,
called an epoch.  Because there is no absolute zero-point on the time
axis natural time is a difference-scale quantity, where only
differences are defined but no ratios. (For example, no point in time
is &#8212; absolutely speaking &#8212; &quot;twice as late&quot; as another
point in time.)
    </p>
<p>
Given some arbitrary zero-point, one can express any point in time as
an elapsed time measured from that offset. Such an arbitrary
zero-point is called an epoch. This epoch-offset form is used as a
semantic representation here, without implying that any system would
have to implement the TS data type in that way. Systems that do not
need to compute distances between points in time will not need any
other representation than a calendar expression literal.
    </p>
]]></text>
            </annotation>
         </documentation>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="INT.NONNEG">
      <datatype isAbstract="false" name="INT.NONNEG" businessName="Non-Negative Integer" visibility="public" superType="INT" isMerged="false">
         <documentation>
            <businessName>Non-Negative Integer</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[This is used to convey an integer number that is greater than or equal to "0".]]></text>
            </annotation>
            <annotation annotationType="CONSTRAINT">
               <text><![CDATA[Maximum length is restricted to 10 digits]]></text>
            </annotation>
            <annotation annotationType="CONSTRAINT">
               <text><![CDATA[Value must be >= 1]]></text>
            </annotation>
         </documentation>
         <staticExampleEntry annotationType="STATIC_EXAMPLE" businessName="">
            <text><![CDATA[&lt;sequenceNumber flavorId=&apos;INT.NONNEG&apos; value=&apos;27&apos; type=&apos;INT&apos;&gt;
	
&lt;/sequenceNumber&gt;
]]></text>
         </staticExampleEntry>
         <parentDatatype isAbstract="false" name="INT" businessName="IntegerNumber" visibility="public" superType="QTY" isMerged="false">
            <documentation>
               <businessName>IntegerNumber</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
Integer numbers (-1,0,1,2, 100, 3398129, etc.) are precise numbers
that are results of counting and enumerating. Integer numbers are
discrete, the set of integers is infinite but countable.  No arbitrary
limit is imposed on the range of integer numbers. Two NULL flavors are
defined for the positive and negative infinity.
    ]]></text>
               </annotation>
               <annotation annotationType="DESIGN_COMMENTS">
                  <text><![CDATA[
<p>
Since the integer number data type includes all of the semantics of
the mathematical integer number concept, the basic operations plus
(addition) and times (multiplication) are defined. These operations
are defined here as characterizing operations in the sense of ISO
11404, and because these operations are needed in other parts of this
specification, namely the semantics of the literal form.
    </p>
<p>
The traditional recursive definitions of addition and multiplication
are due to Grassmann, and use the notion of &lt;object name=&apos;propertyRef&apos;&gt;&lt;param name=&apos;propertyName&apos; value=&apos;successor&apos;/&gt;
                        &lt;param name=&apos;datatypeName&apos; value=&apos;INT&apos;/&gt;&lt;/object&gt;.&lt;object name=&apos;footnote&apos;&gt;H. Grassman. Lehrbuch der Arithmetik. 1861. We prefer
Grassman&apos;s original axioms to the Peano axioms, because Grassman&apos;s
axioms work for all integers, not just for natural numbers. Also, &quot;it
is rather well-known, through Peano&apos;s own acknowledgment, that Peano
borrowed his axioms from Dedekind and made extensive use of
Grassmann&apos;s work in his development of the axioms.&quot; (Hao Wang. The
Axiomatization of Arithmetic. J. Symb. Logic; 1957:22(2); p. 145.)&lt;/object&gt;
				              </p>
]]></text>
               </annotation>
            </documentation>
         </parentDatatype>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="ST">
      <datatype isAbstract="false" name="ST" businessName="String" visibility="public" superType="ST.UV" isMerged="false">
         <documentation>
            <businessName>String</businessName>
            <annotation annotationType="USAGE_NOTES">
               <text><![CDATA[Maximum length of the string is determined by the message, document or other (e.g. data type) specification that includes this data type for a specified attribute or property.]]></text>
            </annotation>
         </documentation>
         <staticExampleEntry annotationType="STATIC_EXAMPLE" businessName="">
            <text><![CDATA[&lt;name&gt;
	Royal Alexandra Hospital
&lt;/name&gt;
]]></text>
         </staticExampleEntry>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="SET">
      <datatype isAbstract="false" name="SET" businessName="Set" visibility="public" superType="ANY" isMerged="true">
         <documentation>
            <businessName>Set</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[Used when multiple repetitions are allowed, order is irrelevant and duplicates are prohibited.]]></text>
            </annotation>
            <annotation annotationType="USAGE_NOTES">
               <text><![CDATA[
<p>Each repetition must follow the specification defined for type of list item.</p>
<p>Duplicate repetitions are not allowed.</p>
]]></text>
            </annotation>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[
A value that contains other distinct values in no particular order.
    ]]></text>
            </annotation>
         </documentation>
         <parentDatatype isAbstract="false" name="SET" businessName="Set" visibility="public" superType="ANY" isMerged="false">
            <documentation>
               <businessName>Set</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
A value that contains other distinct values in no particular order.
    ]]></text>
               </annotation>
            </documentation>
         </parentDatatype>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="INT.POS">
      <datatype isAbstract="false" name="INT.POS" businessName="Positive Integer" visibility="public" superType="INT" isMerged="false">
         <documentation>
            <businessName>Positive Integer</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[This is used to convey an integer number that is greater than or equal to "1".]]></text>
            </annotation>
            <annotation annotationType="CONSTRAINT">
               <text><![CDATA[Maximum length is restricted to 10 digits]]></text>
            </annotation>
            <annotation annotationType="CONSTRAINT">
               <text><![CDATA[Value must be >= 1]]></text>
            </annotation>
         </documentation>
         <staticExampleEntry annotationType="STATIC_EXAMPLE" businessName="">
            <text><![CDATA[&lt;sequenceNumber flavorId=&apos;INT.POS&apos; value=&apos;27&apos; type=&apos;INT&apos;&gt;
	
&lt;/sequenceNumber&gt;
]]></text>
         </staticExampleEntry>
         <parentDatatype isAbstract="false" name="INT" businessName="IntegerNumber" visibility="public" superType="QTY" isMerged="false">
            <documentation>
               <businessName>IntegerNumber</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
Integer numbers (-1,0,1,2, 100, 3398129, etc.) are precise numbers
that are results of counting and enumerating. Integer numbers are
discrete, the set of integers is infinite but countable.  No arbitrary
limit is imposed on the range of integer numbers. Two NULL flavors are
defined for the positive and negative infinity.
    ]]></text>
               </annotation>
               <annotation annotationType="DESIGN_COMMENTS">
                  <text><![CDATA[
<p>
Since the integer number data type includes all of the semantics of
the mathematical integer number concept, the basic operations plus
(addition) and times (multiplication) are defined. These operations
are defined here as characterizing operations in the sense of ISO
11404, and because these operations are needed in other parts of this
specification, namely the semantics of the literal form.
    </p>
<p>
The traditional recursive definitions of addition and multiplication
are due to Grassmann, and use the notion of &lt;object name=&apos;propertyRef&apos;&gt;&lt;param name=&apos;propertyName&apos; value=&apos;successor&apos;/&gt;
                        &lt;param name=&apos;datatypeName&apos; value=&apos;INT&apos;/&gt;&lt;/object&gt;.&lt;object name=&apos;footnote&apos;&gt;H. Grassman. Lehrbuch der Arithmetik. 1861. We prefer
Grassman&apos;s original axioms to the Peano axioms, because Grassman&apos;s
axioms work for all integers, not just for natural numbers. Also, &quot;it
is rather well-known, through Peano&apos;s own acknowledgment, that Peano
borrowed his axioms from Dedekind and made extensive use of
Grassmann&apos;s work in his development of the axioms.&quot; (Hao Wang. The
Axiomatization of Arithmetic. J. Symb. Logic; 1957:22(2); p. 145.)&lt;/object&gt;
				              </p>
]]></text>
               </annotation>
            </documentation>
         </parentDatatype>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="UVP">
      <datatype isAbstract="false" name="UVP" businessName="UncertainValueProbabilistic" visibility="public" superType="T" isMerged="false">
         <documentation>
            <businessName>UncertainValueProbabilistic</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[
A generic data type extension used to specify a probability expressing
the information producer's belief that the given value holds.
    ]]></text>
            </annotation>
            <annotation annotationType="DESIGN_COMMENTS">
               <text><![CDATA[
<p>
How the probability number was arrived at is outside the scope of this
specification.
    </p>
<p>
Probabilities are subjective and (as any data value) must be
interpreted in their individual context, for example, when new
information is found the probability might change. Thus, for any
message (document, or other information representation) the
information &#8212; and particularly the probabilities &#8212; reflect
what the information producer believed was appropriate for the purpose
and at the time the message (document) was created.
    </p>
<p>
For example, at the beginning of the 2000 baseball season (May), the
Las Vegas odds makers may have given the New York Yankees a
probability of 1 in 10 (0.100) of winning the World Series. At the
time of this writing, the Yankees and Mets have won their respective
pennants, but the World Series has yet to begin. The probability of
the Yankees winning the World Series is obviously significantly
greater at this point in time, perhaps 6 in 10 (0.600). The context,
and in particular the time of year, made all the difference in the
world.
    </p>
<p>
Since probabilities are subjective measures of belief, they can be
stated without being &quot;correct&quot; or &quot;incorrect&quot; per se, let alone
&quot;precise&quot; or &quot;imprecise&quot;. Notably, one does not have to conduct
experiments to measure a frequency of some outcome in order to specify
a probability. In fact, whenever statements about individual people or
events are made, it is not possible to confirm such probabilities with
&quot;frequentists&quot; experiments.
    </p>
<p>
Returning to our example, the Las Vegas odds makers can not insist on
the Yankees and Mets playing 1000 trial games prior to the Series;
even if they could, they would not have the fervor of the real Series
and therefore not be accurate. Instead, the odds makers must derive
the probability from past history, player statistics, injuries, etc.
    </p>
<p>
The type T is not formally constrained. In theory, discrete
probabilities can only be stated for discrete data values. Thus,
generally &lt;object name=&apos;itemName&apos;&gt;&lt;param name=&apos;item&apos; value=&apos;datatype&apos;/&gt;&lt;/object&gt; should not be used with &lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;REAL&apos;/&gt;&lt;/object&gt;,
&lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;PQ&apos;/&gt;&lt;/object&gt;, or &lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;MO&apos;/&gt;&lt;/object&gt; values. 
    </p>
]]></text>
            </annotation>
         </documentation>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="PN.BASIC">
      <datatype isAbstract="false" name="PN.BASIC" businessName="Basic Person Name" visibility="public" superType="PN" isMerged="false">
         <documentation>
            <businessName>Basic Person Name</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[Used to express person names for general identification and communication purposes.]]></text>
            </annotation>
            <annotation annotationType="REQUIREMENTS">
               <text><![CDATA[Ballot comment #13]]></text>
            </annotation>
            <annotation annotationType="USAGE_NOTES">
               <text><![CDATA[There is no constraint on the allowed values of either the "prefix" or "suffix" components.  The requirement for middle name is met through additional repetitions of "given names".  Designation is met through use of the "suffix".]]></text>
            </annotation>
            <annotation annotationType="CONSTRAINT">
               <text><![CDATA[No more than seven name parts must be present.]]></text>
            </annotation>
            <annotation annotationType="CONSTRAINT">
               <text><![CDATA[Declaration of part types is optional.  I.e. Name may be expressed as a plain string or mixed content]]></text>
            </annotation>
         </documentation>
         <staticExampleEntry annotationType="STATIC_EXAMPLE" businessName="">
            <text><![CDATA[&lt;name flavorId=&apos;PN.BASIC&apos; use=&apos;L&apos; type=&apos;PN&apos;&gt;
	&lt;prefix&gt;Mr&lt;/prefix&gt;
	&lt;given&gt;John&lt;/given&gt;
	&lt;given qualifier=&apos;IN&apos;&gt;W&lt;/given&gt;
	&lt;family&gt;Smith&lt;/family&gt;
&lt;/name&gt;
]]></text>
         </staticExampleEntry>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="PIVL_TS.DATETIME">
      <datatype isAbstract="false" name="PIVL_TS.DATETIME" businessName="Periodic Interval of Time" visibility="public" isMerged="false">
         <documentation>
            <businessName>Periodic Interval of Time</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[Allows communication of a frequency.]]></text>
            </annotation>
            <annotation annotationType="CONSTRAINT">
               <text><![CDATA[Frequency numerator and denominator cannot be null when PIVL is not null]]></text>
            </annotation>
         </documentation>
         <staticExampleEntry annotationType="STATIC_EXAMPLE" businessName="3 times per day">
            <text><![CDATA[&lt;effectiveTime type=&apos;PIVL_TS&apos;&gt;
	&lt;frequency&gt;
		&lt;numerator flavorId=&apos;INT.NONNEG&apos; value=&apos;3&apos; type=&apos;INT&apos;/&gt;
		&lt;denominator unit=&apos;d&apos; flavorId=&apos;PQ.TIME&apos; value=&apos;1&apos; type=&apos;PQ&apos;/&gt;
	&lt;/frequency&gt;
&lt;/effectiveTime&gt;
]]></text>
         </staticExampleEntry>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="BN">
      <datatype isAbstract="false" name="BN" businessName="BooleanNonNull" visibility="private" superType="BL" isMerged="false">
         <documentation>
            <businessName>BooleanNonNull</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[
The BooleanNonNull constrains the boolean type so that the value may not be NULL.
This type is created for use within the data types specification where it is not
appropriate for a null value to be used
    ]]></text>
            </annotation>
         </documentation>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="II.VER">
      <datatype isAbstract="false" name="II.VER" businessName="Instance Identifier (Version)" visibility="public" superType="II" isMerged="false">
         <documentation>
            <businessName>Instance Identifier (Version)</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[This is used when referencing specific versions of a particular record.]]></text>
            </annotation>
         </documentation>
         <staticExampleEntry annotationType="STATIC_EXAMPLE" businessName="The id of a particular allergy record version">
            <text><![CDATA[&lt;id scope=&apos;VER&apos; root=&apos;64AC5370-D851-2D2F-2A18-78FBB73BFED9&apos;&gt;
	
&lt;/id&gt;
]]></text>
         </staticExampleEntry>
         <parentDatatype isAbstract="false" name="II" businessName="InstanceIdentifier" visibility="public" superType="ANY" isMerged="false">
            <documentation>
               <businessName>InstanceIdentifier</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
An identifier that uniquely identifies a thing or object. Examples
are object identifier for HL7 RIM objects, medical record number,
order id, service catalog item id, Vehicle Identification Number
(VIN), etc. Instance identifiers are defined based on ISO object
identifiers.
    ]]></text>
               </annotation>
            </documentation>
         </parentDatatype>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="ENXP.NO">
      <datatype isAbstract="false" name="ENXP.NO" businessName="Un-typed Entity Name Part" visibility="protected" superType="ENXP" isMerged="false">
         <documentation>
            <businessName>Un-typed Entity Name Part</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[Used to express person names for general identification and communication purposes.]]></text>
            </annotation>
            <annotation annotationType="CONSTRAINT">
               <text><![CDATA[Each name part is constrained to a 50 character string (ST)]]></text>
            </annotation>
         </documentation>
         <parentDatatype isAbstract="false" name="ENXP" businessName="EntityNamePart" visibility="protected" superType="SC" isMerged="false">
            <documentation>
               <businessName>EntityNamePart</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
A character string token representing a part of a name. May have a
type code signifying the role of the part in the whole entity name,
and a qualifier code for more detail about the name part type.
Typical name parts for person names are given names, and family names,
titles, etc.
    ]]></text>
               </annotation>
            </documentation>
         </parentDatatype>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="BL">
      <datatype isAbstract="false" name="BL" businessName="Boolean" visibility="public" superType="ANY" isMerged="true">
         <documentation>
            <businessName>Boolean</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[Allows conveying true-false information.]]></text>
            </annotation>
            <annotation annotationType="USAGE_NOTES">
               <text><![CDATA[The "value" property is mandatory and case-sensitive.  It must be either "true" or "false".  Note that unless the attribute declaring this type is marked as mandatory, the value is allowed to be null.  This must be taken into account when performing boolean logic.  Consult the HL7 international abstract data types specification for further details.]]></text>
            </annotation>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[
<p>true</p>
<p>false</p>
]]></text>
            </annotation>
            <annotation annotationType="DESIGN_COMMENTS">
               <text><![CDATA[
<p>
With any data value potentially being NULL, the two-valued logic is
effectively extended to a three-valued logic as shown in the following
truth tables:
    </p>
<p>
                     &lt;caption&gt;Truth Table: NOT&lt;/caption&gt;
                     &lt;col width=&apos;10&apos; span=&apos;1&apos;/&gt;
                     &lt;col width=&apos;10&apos; span=&apos;1&apos;/&gt;
                     &lt;thead&gt;&lt;tr&gt;&lt;th&gt;NOT&lt;/th&gt;
                           &lt;th&gt;&#160;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;
                     &lt;tbody&gt;&lt;tr&gt;&lt;th&gt;true&lt;/th&gt;
                           &lt;td&gt;false&lt;/td&gt;&lt;/tr&gt;
                        &lt;tr&gt;&lt;th&gt;false&lt;/th&gt;
                           &lt;td&gt;true&lt;/td&gt;&lt;/tr&gt;
                        &lt;tr&gt;&lt;th&gt;NULL&lt;/th&gt;
                           &lt;td&gt;NULL&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;
                  </p>
<p>
                     &lt;caption&gt;Truth Table: AND&lt;/caption&gt;
                     &lt;thead&gt;&lt;tr&gt;&lt;th&gt;AND&lt;/th&gt;
                           &lt;th&gt;true&lt;/th&gt;
                           &lt;th&gt;false&lt;/th&gt;
                           &lt;th&gt;NULL&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;
                     &lt;tbody&gt;&lt;tr&gt;&lt;th&gt;true&lt;/th&gt;
                           &lt;td&gt;true&lt;/td&gt;
                           &lt;td&gt;false&lt;/td&gt;
                           &lt;td&gt;NULL&lt;/td&gt;&lt;/tr&gt;
                        &lt;tr&gt;&lt;th&gt;false&lt;/th&gt;
                           &lt;td&gt;false&lt;/td&gt;
                           &lt;td&gt;false&lt;/td&gt;
                           &lt;td&gt;false&lt;/td&gt;&lt;/tr&gt;
                        &lt;tr&gt;&lt;th&gt;NULL&lt;/th&gt;
                           &lt;td&gt;NULL&lt;/td&gt;
                           &lt;td&gt;false&lt;/td&gt;
                           &lt;td&gt;NULL&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;
                  </p>
<p>
                     &lt;caption&gt;Truth Table: OR&lt;/caption&gt;
                     &lt;thead&gt;&lt;tr&gt;&lt;th&gt;OR&lt;/th&gt;
                           &lt;th&gt;true&lt;/th&gt;
                           &lt;th&gt;false&lt;/th&gt;
                           &lt;th&gt;NULL&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;
                     &lt;tbody&gt;&lt;tr&gt;&lt;th&gt;true&lt;/th&gt;
                           &lt;td&gt;true&lt;/td&gt;
                           &lt;td&gt;true&lt;/td&gt;
                           &lt;td&gt;true&lt;/td&gt;&lt;/tr&gt;
                        &lt;tr&gt;&lt;th&gt;false&lt;/th&gt;
                           &lt;td&gt;true&lt;/td&gt;
                           &lt;td&gt;false&lt;/td&gt;
                           &lt;td&gt;NULL&lt;/td&gt;&lt;/tr&gt;
                        &lt;tr&gt;&lt;th&gt;NULL&lt;/th&gt;
                           &lt;td&gt;true&lt;/td&gt;
                           &lt;td&gt;NULL&lt;/td&gt;
                           &lt;td&gt;NULL&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;
                  </p>
<p>
Where a boolean operation is performed upon 2 data types with different
nullFlavors, the nullFlavor of the result is the first common ancestor
of the 2 different nullFlavors, though conformant applications may also
create a result that is any common ancestor
    </p>
]]></text>
            </annotation>
         </documentation>
         <staticExampleEntry annotationType="STATIC_EXAMPLE" businessName="">
            <text><![CDATA[&lt;negationInd value=&apos;true&apos;&gt;
	
&lt;/negationInd&gt;
]]></text>
         </staticExampleEntry>
         <parentDatatype isAbstract="false" name="BL" businessName="Boolean" visibility="public" superType="ANY" isMerged="false">
            <documentation>
               <businessName>Boolean</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
<p>true</p>
<p>false</p>
]]></text>
               </annotation>
               <annotation annotationType="DESIGN_COMMENTS">
                  <text><![CDATA[
<p>
With any data value potentially being NULL, the two-valued logic is
effectively extended to a three-valued logic as shown in the following
truth tables:
    </p>
<p>
                     &lt;caption&gt;Truth Table: NOT&lt;/caption&gt;
                     &lt;col width=&apos;10&apos; span=&apos;1&apos;/&gt;
                     &lt;col width=&apos;10&apos; span=&apos;1&apos;/&gt;
                     &lt;thead&gt;&lt;tr&gt;&lt;th&gt;NOT&lt;/th&gt;
                           &lt;th&gt;&#160;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;
                     &lt;tbody&gt;&lt;tr&gt;&lt;th&gt;true&lt;/th&gt;
                           &lt;td&gt;false&lt;/td&gt;&lt;/tr&gt;
                        &lt;tr&gt;&lt;th&gt;false&lt;/th&gt;
                           &lt;td&gt;true&lt;/td&gt;&lt;/tr&gt;
                        &lt;tr&gt;&lt;th&gt;NULL&lt;/th&gt;
                           &lt;td&gt;NULL&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;
                  </p>
<p>
                     &lt;caption&gt;Truth Table: AND&lt;/caption&gt;
                     &lt;thead&gt;&lt;tr&gt;&lt;th&gt;AND&lt;/th&gt;
                           &lt;th&gt;true&lt;/th&gt;
                           &lt;th&gt;false&lt;/th&gt;
                           &lt;th&gt;NULL&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;
                     &lt;tbody&gt;&lt;tr&gt;&lt;th&gt;true&lt;/th&gt;
                           &lt;td&gt;true&lt;/td&gt;
                           &lt;td&gt;false&lt;/td&gt;
                           &lt;td&gt;NULL&lt;/td&gt;&lt;/tr&gt;
                        &lt;tr&gt;&lt;th&gt;false&lt;/th&gt;
                           &lt;td&gt;false&lt;/td&gt;
                           &lt;td&gt;false&lt;/td&gt;
                           &lt;td&gt;false&lt;/td&gt;&lt;/tr&gt;
                        &lt;tr&gt;&lt;th&gt;NULL&lt;/th&gt;
                           &lt;td&gt;NULL&lt;/td&gt;
                           &lt;td&gt;false&lt;/td&gt;
                           &lt;td&gt;NULL&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;
                  </p>
<p>
                     &lt;caption&gt;Truth Table: OR&lt;/caption&gt;
                     &lt;thead&gt;&lt;tr&gt;&lt;th&gt;OR&lt;/th&gt;
                           &lt;th&gt;true&lt;/th&gt;
                           &lt;th&gt;false&lt;/th&gt;
                           &lt;th&gt;NULL&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;
                     &lt;tbody&gt;&lt;tr&gt;&lt;th&gt;true&lt;/th&gt;
                           &lt;td&gt;true&lt;/td&gt;
                           &lt;td&gt;true&lt;/td&gt;
                           &lt;td&gt;true&lt;/td&gt;&lt;/tr&gt;
                        &lt;tr&gt;&lt;th&gt;false&lt;/th&gt;
                           &lt;td&gt;true&lt;/td&gt;
                           &lt;td&gt;false&lt;/td&gt;
                           &lt;td&gt;NULL&lt;/td&gt;&lt;/tr&gt;
                        &lt;tr&gt;&lt;th&gt;NULL&lt;/th&gt;
                           &lt;td&gt;true&lt;/td&gt;
                           &lt;td&gt;NULL&lt;/td&gt;
                           &lt;td&gt;NULL&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;
                  </p>
<p>
Where a boolean operation is performed upon 2 data types with different
nullFlavors, the nullFlavor of the result is the first common ancestor
of the 2 different nullFlavors, though conformant applications may also
create a result that is any common ancestor
    </p>
]]></text>
               </annotation>
            </documentation>
         </parentDatatype>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="TS.FULLDATEPARTTIME">
      <datatype isAbstract="false" name="TS.FULLDATEPARTTIME" businessName="Timestamp (Date+Time)" visibility="public" superType="TS" isMerged="false">
         <documentation>
            <businessName>Timestamp (Date+Time)</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[Requires the date. Time may be omitted, and partial times may be specified.]]></text>
            </annotation>
            <annotation annotationType="REQUIREMENTS">
               <text><![CDATA[RFC #625]]></text>
            </annotation>
            <annotation annotationType="USAGE_NOTES">
               <text><![CDATA[The grammar for the date/time is: YYYYMMDD[HH[MM[SS[.S[S[S[S]]]]]]] [+/- ZZZZ] (19 or 24 characters).]]></text>
            </annotation>
            <annotation annotationType="CONSTRAINT">
               <text><![CDATA[If the value is not null, there SHALL be 8 or more digits in the literal form. If a time is specified, the timezone portion of the timestamp must be specified. This flavor is specific to the gregorian calendar.]]></text>
            </annotation>
         </documentation>
         <staticExampleEntry annotationType="STATIC_EXAMPLE" businessName="">
            <text><![CDATA[&lt;effectiveTime flavorId=&apos;TS.FULLDATEPARTTIME&apos; value=&apos;20050802173000-0800&apos; type=&apos;TS&apos;&gt;
	
&lt;/effectiveTime&gt;
]]></text>
         </staticExampleEntry>
         <parentDatatype isAbstract="false" name="TS" businessName="PointInTime" visibility="public" superType="QTY" isMerged="false">
            <documentation>
               <businessName>PointInTime</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
A quantity specifying a point on the axis of natural time. A point
in time is most often represented as a calendar expression.
    ]]></text>
               </annotation>
               <annotation annotationType="DESIGN_COMMENTS">
                  <text><![CDATA[
<p>
Semantically, however, time is independent from calendars and best
described by its relationship to elapsed time (measured as a physical
quantity in the dimension of time.)  A point in time plus an elapsed
time yields another point in time.  Inversely, a point in time minus
another point in time yields an elapsed time.
    </p>
<p>
As nobody knows when time began, a point in time is conceptualized as
the amount of time that has elapsed from some arbitrary zero-point,
called an epoch.  Because there is no absolute zero-point on the time
axis natural time is a difference-scale quantity, where only
differences are defined but no ratios. (For example, no point in time
is &#8212; absolutely speaking &#8212; &quot;twice as late&quot; as another
point in time.)
    </p>
<p>
Given some arbitrary zero-point, one can express any point in time as
an elapsed time measured from that offset. Such an arbitrary
zero-point is called an epoch. This epoch-offset form is used as a
semantic representation here, without implying that any system would
have to implement the TS data type in that way. Systems that do not
need to compute distances between points in time will not need any
other representation than a calendar expression literal.
    </p>
]]></text>
               </annotation>
            </documentation>
         </parentDatatype>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="SC">
      <datatype isAbstract="false" name="SC" businessName="CharacterStringWithCode" visibility="public" superType="ST" isMerged="false">
         <documentation>
            <businessName>CharacterStringWithCode</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[
A character string that optionally may have a code attached. The text
must always be present if a code is present.  The code is often a
local code.
    ]]></text>
            </annotation>
            <annotation annotationType="DESIGN_COMMENTS">
               <text><![CDATA[
<p>
This data type is used in cases where coding is exceptional (e.g.,
user text messages are essentially text messages, and a printable
message is the important content. Yet, sometimes messages come from a
catalog of canned messages, which the SC allows to reference.  
    </p>
]]></text>
            </annotation>
            <annotation annotationType="CONSTRAINT">
               <text><![CDATA[
Any non-null SC value MAY have a code, however, a code MUST NOT be
given without the text.
      ]]></text>
            </annotation>
         </documentation>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="ED.DOCREF">
      <datatype isAbstract="false" name="ED.DOCREF" businessName="Encapsulated Data (Document Reference)" visibility="public" superType="ED" isMerged="false">
         <documentation>
            <businessName>Encapsulated Data (Document Reference)</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[This allows embedding a reference to a document that can be retrieved elsewhere]]></text>
            </annotation>
            <annotation annotationType="REQUIREMENTS">
               <text><![CDATA[Ballot comment #30]]></text>
            </annotation>
            <annotation annotationType="CONSTRAINT">
               <text><![CDATA[
<p>not permitted</p>
]]></text>
            </annotation>
         </documentation>
         <staticExampleEntry annotationType="STATIC_EXAMPLE" businessName="A monograph reference">
            <text><![CDATA[&lt;text mediaType=&apos;application/pdf&apos;&gt;
	&lt;reference flavorId=&apos;TEL.URI&apos; value=&apos;ftp://monographs.somewhere.gov.ca/12345.pdf&apos;/&gt;
&lt;/text&gt;
]]></text>
         </staticExampleEntry>
         <parentDatatype isAbstract="false" name="ED" businessName="EncapsulatedData" visibility="public" superType="BIN" isMerged="false">
            <documentation>
               <businessName>EncapsulatedData</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
<p>
                     &lt;param name=&apos;datatypeName&apos; value=&apos;ED&apos;/&gt;
                  </p>
<p>
                     &lt;param name=&apos;datatypeName&apos; value=&apos;TEL&apos;/&gt;
                  </p>
<p>
                     &lt;param name=&apos;datatypeName&apos; value=&apos;ST&apos;/&gt;
                  </p>
<p>
                     &lt;param name=&apos;datatypeName&apos; value=&apos;ED&apos;/&gt;
                  </p>
<p>
                     &lt;param name=&apos;datatypeName&apos; value=&apos;ED&apos;/&gt;
                  </p>
]]></text>
               </annotation>
               <annotation annotationType="DESIGN_COMMENTS">
                  <text><![CDATA[
<p>
Encapsulated data can be present in two forms, inline or by
reference. Inline data is communicated or moved as part of the
encapsulated data value, whereas by-reference data may reside at a
different (remote) location. The data is the same whether it is
located inline or remote.
    </p>
]]></text>
               </annotation>
            </documentation>
         </parentDatatype>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="ANY.LAB">
      <datatype isAbstract="true" name="ANY.LAB" businessName="Lab result types" visibility="public" superType="ANY" isMerged="false">
         <documentation>
            <businessName>Lab result types</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[Used in a specification where the specific types to be communicated may vary.]]></text>
            </annotation>
            <annotation annotationType="USAGE_NOTES">
               <text><![CDATA[
<p>This data type may be referenced in Canadian specifications.  If this data type is used in a message instance, it must be declared as one of the constrained version of ANY (e.g. ST) for each repetition.</p>
<p>The specific data type must be declared using xsi:type.</p>
<p>The use of this type is restricted to messages in the LAB domain</p>
]]></text>
            </annotation>
         </documentation>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="ENXP.REQUIRED">
      <datatype isAbstract="false" name="ENXP.REQUIRED" businessName="Typed Entity Name Part" visibility="protected" superType="ENXP" isMerged="false">
         <documentation>
            <businessName>Typed Entity Name Part</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[Used to express person names for general identification and communication purposes.]]></text>
            </annotation>
            <annotation annotationType="CONSTRAINT">
               <text><![CDATA[Each name part is constrained to a 50 character string (ST)]]></text>
            </annotation>
         </documentation>
         <parentDatatype isAbstract="false" name="ENXP" businessName="EntityNamePart" visibility="protected" superType="SC" isMerged="false">
            <documentation>
               <businessName>EntityNamePart</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
A character string token representing a part of a name. May have a
type code signifying the role of the part in the whole entity name,
and a qualifier code for more detail about the name part type.
Typical name parts for person names are given names, and family names,
titles, etc.
    ]]></text>
               </annotation>
            </documentation>
         </parentDatatype>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="GLIST">
      <datatype isAbstract="false" name="GLIST" businessName="GeneratedSequence" visibility="public" superType="LIST" isMerged="false">
         <documentation>
            <businessName>GeneratedSequence</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[
A periodic or monotone sequence of values generated from a few
parameters, rather than being enumerated. Used to specify regular
sampling points for biosignals.
    ]]></text>
            </annotation>
            <annotation annotationType="DESIGN_COMMENTS">
               <text><![CDATA[
<p>
The item at a certain index in the list is calculated by performing an
integer division on the index (&lt;var&gt;i&lt;/var&gt;) with the
&lt;object name=&apos;propertyRef&apos;&gt;&lt;param name=&apos;propertyName&apos; value=&apos;denominator&apos;/&gt;
                        &lt;param name=&apos;datatypeName&apos; value=&apos;GLIST&apos;/&gt;&lt;/object&gt; (&lt;var&gt;d&lt;/var&gt;) and then take that
value&apos;s remainder with the &lt;object name=&apos;propertyRef&apos;&gt;&lt;param name=&apos;propertyName&apos; value=&apos;period&apos;/&gt;
                        &lt;param name=&apos;datatypeName&apos; value=&apos;GLIST&apos;/&gt;&lt;/object&gt;
(&lt;var&gt;p&lt;/var&gt;). Multiply this value with the
&lt;object name=&apos;propertyRef&apos;&gt;&lt;param name=&apos;propertyName&apos; value=&apos;increment&apos;/&gt;
                        &lt;param name=&apos;datatypeName&apos; value=&apos;GLIST&apos;/&gt;&lt;/object&gt; (&lt;var&gt;&#916;x&lt;/var&gt;) and add to the
&lt;object name=&apos;propertyRef&apos;&gt;&lt;param name=&apos;propertyName&apos; value=&apos;head&apos;/&gt;
                        &lt;param name=&apos;datatypeName&apos; value=&apos;GLIST&apos;/&gt;&lt;/object&gt; (&lt;var&gt;x&lt;/var&gt;
					                &lt;sub&gt;0&lt;/sub&gt;.)
    </p>
<p>
                     &lt;p&gt;&lt;var&gt;x&lt;/var&gt;
						                  &lt;sub&gt;&lt;var&gt;i&lt;/var&gt;&lt;/sub&gt;
=
&lt;var&gt;x&lt;/var&gt;
						                  &lt;sub&gt;0&lt;/sub&gt;
+
&lt;var&gt;&#916;x&lt;/var&gt;
&#215;
(&lt;var&gt;i&lt;/var&gt;/&lt;var&gt;d&lt;/var&gt;)
mod &lt;var&gt;p&lt;/var&gt;&lt;/p&gt;
                  </p>
<p>
                     &lt;caption&gt;Examples for Generated Sequences&lt;/caption&gt;
                     &lt;thead&gt;&lt;tr&gt;&lt;th&gt;head&lt;/th&gt;
                           &lt;th&gt;increment&lt;/th&gt;
                           &lt;th&gt;denominator&lt;/th&gt;
                           &lt;th&gt;period&lt;/th&gt;
                           &lt;th&gt;meaning&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;
                     &lt;tbody&gt;&lt;tr&gt;&lt;td&gt;0&lt;/td&gt;
                           &lt;td&gt;1&lt;/td&gt;
                           &lt;td&gt;1&lt;/td&gt;
                           &lt;td&gt;&#8734;&lt;/td&gt;
                           &lt;td&gt;The identity-sequence where each item is equal to its index.&lt;/td&gt;&lt;/tr&gt;
                        &lt;tr&gt;&lt;td&gt;198706052000&lt;/td&gt;
                           &lt;td&gt;2 hour&lt;/td&gt;
                           &lt;td&gt;1&lt;/td&gt;
                           &lt;td&gt;&#8734;&lt;/td&gt;
                           &lt;td&gt;Sequence starting on June 5, 1987 at 7 PM and
          incrementing every two hours: 9 PM, 11 PM, 1 AM (June 6), 3
          AM, 5 AM, and so on.&lt;/td&gt;&lt;/tr&gt;
                        &lt;tr&gt;&lt;td&gt;0 V&lt;/td&gt;
                           &lt;td&gt;1 mV&lt;/td&gt;
                           &lt;td&gt;1&lt;/td&gt;
                           &lt;td&gt;100&lt;/td&gt;
                           &lt;td&gt;The x-wave of a digital oscillograph scanning between
          0 and 100 mV in 100 steps of 1 mV. The frequency is unknown
          from these data as we do not know how much time elapses
          between each step of the index.&lt;/td&gt;&lt;/tr&gt;
                        &lt;tr&gt;&lt;td&gt;2002072920300&lt;/td&gt;
                           &lt;td&gt;100
          us&lt;/td&gt;
                           &lt;td&gt;1&lt;/td&gt;
                           &lt;td&gt;&#8734;&lt;/td&gt;
                           &lt;td&gt;A timebase from June 29,
          2002 at 8:30 PM with 100 us between each steps of the
          index. If combined with the previous generator as a second
          sampling dimension this would now describe our digital
          oscilloscope&apos;s x-timebase as 1 mV per 100 us. At 100 steps
          per period, the period is 10 ms, which is equal to a
          frequency of 100 Hz.&lt;/td&gt;&lt;/tr&gt;
                        &lt;tr&gt;&lt;td&gt;0 V&lt;/td&gt;
                           &lt;td&gt;1 mV&lt;/td&gt;
                           &lt;td&gt;100&lt;/td&gt;
                           &lt;td&gt;100&lt;/td&gt;
                           &lt;td&gt;Combining this generator to the previous two generators
          could describe a three-dimensional sampling space with two
          voltages and time. This generator also steps at 1 mV and has
          100 steps per period, however, it only steps every 100 index
          increments, so, the first voltage generator makes one full
          cycle before this generator is incremented. One can think of
          the two voltages as &quot;rows&quot; and &quot;columns&quot; of a &quot;sampling
          frame&quot;. With the previous generator as the timebase, this
          results in a scan of sampling frames of 100 mV &#215; 100
          mV with a framerate of 1 Hz.&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;
                  </p>
]]></text>
            </annotation>
         </documentation>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="PQ.HEIGHTWEIGHT">
      <datatype isAbstract="false" name="PQ.HEIGHTWEIGHT" businessName="Height or Weight Quantity" visibility="public" superType="PQ" isMerged="false">
         <documentation>
            <businessName>Height or Weight Quantity</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[
<p>Used to express measurements of human height and weight</p>
<p>The data type units are constrained to the specific use-case of human height and weight resulting in a fairly narrow number of options to be supported. Future use-cases resulting in the need to communicate other types of units of measure may require the creation of a new data type flavor. The purpose of creating multiple flavors is to make it clear what units must be supported for a given attribute and to ensure that systems are not obligated to use units of measure that are inappropriate.</p>
]]></text>
            </annotation>
         </documentation>
         <staticExampleEntry annotationType="STATIC_EXAMPLE" businessName="30 kilograms">
            <text><![CDATA[&lt;value unit=&apos;kg&apos; flavorId=&apos;PQ.HEIGHTWEIGHT&apos; value=&apos;30&apos; type=&apos;PQ&apos;&gt;
	
&lt;/value&gt;
]]></text>
         </staticExampleEntry>
         <parentDatatype isAbstract="false" name="PQ" businessName="PhysicalQuantity" visibility="public" superType="QTY" isMerged="false">
            <documentation>
               <businessName>PhysicalQuantity</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
A dimensioned quantity expressing the result of measuring.
    ]]></text>
               </annotation>
            </documentation>
         </parentDatatype>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="ANY">
      <datatype isAbstract="true" name="ANY" businessName="Unrestricted" visibility="public" superType="ANY" isMerged="false">
         <documentation>
            <businessName>Unrestricted</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[Used in a specification where the specific types to be communicated may vary.]]></text>
            </annotation>
            <annotation annotationType="USAGE_NOTES">
               <text><![CDATA[
<p>This data type may be referenced in Canadian specifications.  If this data type is used in a message instance, it must be declared as one of the constrained version of ANY (e.g. ST) for each repetition.</p>
<p>Each value sent over the wire must correspond to one of the non-abstract data type flavor specifications defined in this document.</p>
<p>The specific data type must be declared using xsi:type.</p>
<p>The use of this type is discouraged in specifications unless additional constraints are included indicating what specific data type flavors may be substituted.</p>
]]></text>
            </annotation>
         </documentation>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="CV">
      <datatype isAbstract="false" name="CV" businessName="Coded Value" visibility="public" superType="CE" isMerged="true">
         <documentation>
            <businessName>Coded Value</businessName>
            <annotation annotationType="USAGE_NOTES">
               <text><![CDATA[
<p>If the attribute or property is null, the codeSystem and originalTextproperties are still permitted but not &lt;i&gt;mandatory&lt;/i&gt;.</p>
<p>The rules for supporting the several properties vary depending on whether the element has a coding strength of CWE (Coded with extensibility) or CNE (Coded with no extensibility).</p>
<p>For CWE, &quot;code&quot;, &quot;codeSystem&quot; and &quot;originalText&quot; properties are required. A constraint exists that at least one of &quot;code&quot; and &quot;originalText&quot; must be present and non-null, and that if &quot;code&quot; is present, then &quot;codeSystem is mandatory.</p>
<p>For CNE, &quot;code&quot; and &quot;codeSystem&quot; are mandatory (meaning they must be non-null if the overall attribute or property is non-null). If the element is null with a flavor of OTH (Other), then the &quot;originalText&quot; property is mandatory (and no other properties may be specified).</p>
]]></text>
            </annotation>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[
Coded data, specifying only a code, code system, and optionally
display name and original text. Used only as the data type for other
data types' properties.
    ]]></text>
            </annotation>
            <annotation annotationType="DESIGN_COMMENTS">
               <text><![CDATA[
<p>
This type is used when any reasonable use case will require only a
single code value to be sent. Thus, it should not be used in
circumstances where multiple alternative codes for a given value are
desired. This type may be used with both the CNE (&lt;b&gt;coded,
non-extensible&lt;/b&gt;) and the CWE (&lt;b&gt;coded, with
extensibility&lt;/b&gt;) domain qualifiers.
    </p>
]]></text>
            </annotation>
         </documentation>
         <staticExampleEntry annotationType="STATIC_EXAMPLE" businessName="a gender of female">
            <text><![CDATA[&lt;administrativeGenderCode codeSystem=&apos;2.16.840.1.113883.5.1&apos; code=&apos;F&apos;&gt;
	
&lt;/administrativeGenderCode&gt;
]]></text>
         </staticExampleEntry>
         <parentDatatype isAbstract="false" name="CV" businessName="CodedValue" visibility="protected" superType="CE" isMerged="false">
            <documentation>
               <businessName>CodedValue</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
Coded data, specifying only a code, code system, and optionally
display name and original text. Used only as the data type for other
data types' properties.
    ]]></text>
               </annotation>
               <annotation annotationType="DESIGN_COMMENTS">
                  <text><![CDATA[
<p>
This type is used when any reasonable use case will require only a
single code value to be sent. Thus, it should not be used in
circumstances where multiple alternative codes for a given value are
desired. This type may be used with both the CNE (&lt;b&gt;coded,
non-extensible&lt;/b&gt;) and the CWE (&lt;b&gt;coded, with
extensibility&lt;/b&gt;) domain qualifiers.
    </p>
]]></text>
               </annotation>
            </documentation>
         </parentDatatype>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="PN.SEARCH">
      <datatype isAbstract="false" name="PN.SEARCH" businessName="Searchable Name" visibility="public" superType="PN" isMerged="false">
         <documentation>
            <businessName>Searchable Name</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[
<p>This type is used to convey name information for searching purposes.</p>
<p>All matches are considered to be &quot;starts with&quot; for each specified property.</p>
]]></text>
            </annotation>
            <annotation annotationType="USAGE_NOTES">
               <text><![CDATA[There is no constraint on the allowed values of either the "prefix" or "suffix" components.  The requirement for middle name is met through additional repetitions of "given names".  Designation is met through use of the "suffix".]]></text>
            </annotation>
            <annotation annotationType="CONSTRAINT">
               <text><![CDATA[No more than seven name parts must be present.]]></text>
            </annotation>
            <annotation annotationType="CONSTRAINT">
               <text><![CDATA[Declaration of part types is mandatory.  I.e. All name parts must be typed.  Plain strings and mixed content is prohibited]]></text>
            </annotation>
         </documentation>
         <staticExampleEntry annotationType="STATIC_EXAMPLE" businessName="">
            <text><![CDATA[&lt;name flavorId=&apos;PN.SEARCH&apos; type=&apos;PN&apos;&gt;
	&lt;family&gt;Smith&lt;/family&gt;
&lt;/name&gt;
]]></text>
         </staticExampleEntry>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="BAG">
      <datatype isAbstract="false" name="BAG" businessName="Bag" visibility="public" superType="ANY" isMerged="false">
         <documentation>
            <businessName>Bag</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[
An unordered collection of values, where each value can be contained
more than once in the collection.
    ]]></text>
            </annotation>
         </documentation>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="ADXP">
      <datatype isAbstract="false" name="ADXP" businessName="AddressPart" visibility="protected" superType="SC" isMerged="false">
         <documentation>
            <businessName>AddressPart</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[
A character string that may have a type-tag signifying its role in the
address. Typical parts that exist in about every address are street,
house number, or post box, postal code, city, country but other roles
may be defined regionally, nationally, or on an enterprise level
(e.g. in military addresses). Addresses are usually broken up into
lines, which are indicated by special line-breaking delimiter elements
(e.g., DEL).
    ]]></text>
            </annotation>
         </documentation>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="CS">
      <datatype isAbstract="false" name="CS" businessName="Coded Simple" visibility="public" superType="CV" isMerged="true">
         <documentation>
            <businessName>Coded Simple</businessName>
            <annotation annotationType="USAGE_NOTES">
               <text><![CDATA[This data type should only appear in specifications where the corresponding RIM attribute or Abstract Data type property also has a data type of CS. i.e. Other coded data types should never be constrained to CS.]]></text>
            </annotation>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[
XCoded data in its simplest form, where only the code is not predetermined.
The code system and code system version are fixed by the context in which
the CS value occurs. CS is used for coded attributes that have a single
HL7-defined value set.
    ]]></text>
            </annotation>
            <annotation annotationType="DESIGN_COMMENTS">
               <text><![CDATA[
<p>
					                &lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;CS&apos;/&gt;&lt;/object&gt; can only be used in either of the following
          cases:
    </p>
<p>
                     &lt;li&gt;&lt;p&gt;&lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;CS&apos;/&gt;&lt;/object&gt; restriction.&lt;/p&gt;&lt;/li&gt;
                     &lt;li&gt;&lt;p&gt;for a property in this specification that is assigned to a single code
system defined either in this specification or defined outside HL7 by a body
that has authority over the concept and the maintenance of that code system.&lt;/p&gt;&lt;/li&gt;
                  </p>
<p>
For example, since the &lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;ED&apos;/&gt;&lt;/object&gt; type subscribes to the MIME
design, it trusts IETF to manage the media type. This includes that this
specification subscribes to the extension mechanism built into the MIME media
type code (e.g., &quot;application/x-myapp&quot;).
    </p>
<p>
For &lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;CS&apos;/&gt;&lt;/object&gt; values, the designation of the domain qualifier
will always be CNE (&lt;b&gt;coded, non-extensible&lt;/b&gt;) and the
context will determine which HL7 values to use. &lt;object name=&apos;footnote&apos;&gt;This is not withstanding the fact that an external referenced domain,
such as the IETF MIME media type may include an extension
mechanism. These extended MIME type codes would not be considered
&quot;extensions&quot; in the sense of violating the CNE provision. The CNE
provision is only violated if an attempt is made in using a different
code system (by means of the CD.codeSystem property), which is not
possible with the  data type.&lt;/object&gt;
				              </p>
]]></text>
            </annotation>
         </documentation>
         <staticExampleEntry annotationType="STATIC_EXAMPLE" businessName="A mood code indicating an event">
            <text><![CDATA[... moodCode="EVN" ...]]></text>
         </staticExampleEntry>
         <parentDatatype isAbstract="false" name="CS" businessName="CodedSimpleValue" visibility="public" superType="CV" isMerged="false">
            <documentation>
               <businessName>CodedSimpleValue</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
XCoded data in its simplest form, where only the code is not predetermined.
The code system and code system version are fixed by the context in which
the CS value occurs. CS is used for coded attributes that have a single
HL7-defined value set.
    ]]></text>
               </annotation>
               <annotation annotationType="DESIGN_COMMENTS">
                  <text><![CDATA[
<p>
					                &lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;CS&apos;/&gt;&lt;/object&gt; can only be used in either of the following
          cases:
    </p>
<p>
                     &lt;li&gt;&lt;p&gt;&lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;CS&apos;/&gt;&lt;/object&gt; restriction.&lt;/p&gt;&lt;/li&gt;
                     &lt;li&gt;&lt;p&gt;for a property in this specification that is assigned to a single code
system defined either in this specification or defined outside HL7 by a body
that has authority over the concept and the maintenance of that code system.&lt;/p&gt;&lt;/li&gt;
                  </p>
<p>
For example, since the &lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;ED&apos;/&gt;&lt;/object&gt; type subscribes to the MIME
design, it trusts IETF to manage the media type. This includes that this
specification subscribes to the extension mechanism built into the MIME media
type code (e.g., &quot;application/x-myapp&quot;).
    </p>
<p>
For &lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;CS&apos;/&gt;&lt;/object&gt; values, the designation of the domain qualifier
will always be CNE (&lt;b&gt;coded, non-extensible&lt;/b&gt;) and the
context will determine which HL7 values to use. &lt;object name=&apos;footnote&apos;&gt;This is not withstanding the fact that an external referenced domain,
such as the IETF MIME media type may include an extension
mechanism. These extended MIME type codes would not be considered
&quot;extensions&quot; in the sense of violating the CNE provision. The CNE
provision is only violated if an attempt is made in using a different
code system (by means of the CD.codeSystem property), which is not
possible with the  data type.&lt;/object&gt;
				              </p>
]]></text>
               </annotation>
            </documentation>
         </parentDatatype>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="CLCY">
      <datatype isAbstract="false" name="CLCY" businessName="CalendarCycle" visibility="private" superType="ANY" isMerged="false">
         <documentation>
            <businessName>CalendarCycle</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[    
A calendar cycle defines one group of decimal digits in the calendar
expression. Examples for calendar cycles are year, month, day, hour,
minute, second, and week.
      ]]></text>
            </annotation>
            <annotation annotationType="DESIGN_COMMENTS">
               <text><![CDATA[
<p>
A calendar cycle has a name and two codes, a one-letter code and a
two-letter code. The property &lt;b&gt;ndigits&lt;/b&gt; is the number of
decimal digits occupied in the calendar expression. The property
&lt;b&gt;start&lt;/b&gt; specifies where counting starts (i.e., at 0 or 1.)
The &lt;b&gt;next&lt;/b&gt; property is the next lower cycle in the order of
the calendar expression. The max(&lt;b&gt;t&lt;/b&gt;) property is the
maximum number of cycles at time &lt;b&gt;t&lt;/b&gt; (max depends on the
time &lt;b&gt;t&lt;/b&gt; to account for leap years and leap seconds.)  The
property value(&lt;b&gt;t&lt;/b&gt;) is the integer number of cycles shown
in the calendar expression of time &lt;b&gt;t&lt;/b&gt;. The property
sum(&lt;b&gt;t&lt;/b&gt;, &lt;b&gt;n&lt;/b&gt;) is the sum of &lt;b&gt;n&lt;/b&gt;
calendar cycles added to the time &lt;b&gt;t&lt;/b&gt;.
      </p>
]]></text>
            </annotation>
         </documentation>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="AD.BASIC">
      <datatype isAbstract="false" name="AD.BASIC" businessName="Basic Address" visibility="public" superType="AD" isMerged="false">
         <documentation>
            <businessName>Basic Address</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[Used to communicate addresses for simple display, mailing and contact purposes.  The data type is not generally suitable for registries]]></text>
            </annotation>
            <annotation annotationType="REQUIREMENTS">
               <text><![CDATA[Ballot comment #31]]></text>
            </annotation>
            <annotation annotationType="CONSTRAINT">
               <text><![CDATA[There may be up to 4 lines of delimiter-separated information in addition to the specified address parts.]]></text>
            </annotation>
            <annotation annotationType="CONSTRAINT">
               <text><![CDATA[Address parts are rescricted to basic address parts]]></text>
            </annotation>
         </documentation>
         <staticExampleEntry annotationType="STATIC_EXAMPLE" businessName="">
            <text><![CDATA[&lt;addr flavorId=&apos;AD.BASIC&apos; use=&apos;H PST&apos; type=&apos;AD&apos;&gt;
	Apt A5 123 Some Street N.W.	&lt;delimiter/&gt;
	&lt;city&gt;Edmonton&lt;/city&gt;
	&lt;state code=&apos;AB&apos;&gt;Alberta&lt;/state&gt;
	&lt;postalCode&gt;A1B 2C3&lt;/postalCode&gt;
	&lt;delimiter/&gt;
	&lt;country code=&apos;CA&apos;&gt;Canada&lt;/country&gt;
&lt;/addr&gt;
]]></text>
         </staticExampleEntry>
         <parentDatatype isAbstract="false" name="AD" businessName="PostalAddress" visibility="public" superType="LIST" isMerged="false">
            <documentation>
               <businessName>PostalAddress</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
Mailing and home or office addresses. A sequence of address parts,
such as street or post office Box, city, postal code, country, etc.
    ]]></text>
               </annotation>
               <annotation annotationType="DESIGN_COMMENTS">
                  <text><![CDATA[
<p>
The &lt;object name=&apos;itemName&apos;&gt;&lt;param name=&apos;item&apos; value=&apos;datatype&apos;/&gt;&lt;/object&gt; is primarily used to communicate data that will allow
printing mail labels, that will allow a person to physically visit
that address. The postal address data type is not supposed to be a
container for additional information that might be useful for finding
geographic locations (e.g., GPS coordinates) or for performing
epidemiological studies. Such additional information is captured by
other, more appropriate HL7 elements.
    </p>
<p>
Addresses are conceptualized as text with added logical mark-up. The
mark-up may break the address into lines and may describe in detail
the role of each address part if it is known. Address parts occur in
the address in the order in which they would be printed on a mailing
label. The approach is similar to HTML or XML markup of text (but it
is not technically limited to XML representations.)
    </p>
<p>
Addresses are essentially sequences of address parts, but add a &quot;use&quot;
code and a valid time range for information about if and when the
address can be used for a given purpose.
    </p>
]]></text>
               </annotation>
            </documentation>
         </parentDatatype>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="CE">
      <datatype isAbstract="false" name="CE" businessName="Coded With Equivalents" visibility="public" superType="CD" isMerged="true">
         <documentation>
            <businessName>Coded With Equivalents</businessName>
            <annotation annotationType="USAGE_NOTES">
               <text><![CDATA[
<p>If the attribute or property is null, the codeSystem and originalTextproperties are still permitted but not &lt;i&gt;mandatory&lt;/i&gt;.</p>
<p>The rules for supporting the several properties vary depending on whether the element has a coding strength of CWE (Coded with extensibility) or CNE (Coded with no extensibility).</p>
<p>For CWE, &quot;code&quot;, &quot;codeSystem&quot; and &quot;originalText&quot; properties are required. A constraint exists that at least one of &quot;code&quot; and &quot;originalText&quot; must be present and non-null, and that if &quot;code&quot; is present, then &quot;codeSystem is mandatory.</p>
<p>For CNE, &quot;code&quot; and &quot;codeSystem&quot; are mandatory (meaning they must be non-null if the overall attribute or property is non-null). If the element is null with a flavor of OTH (Other), then the &quot;originalText&quot; property is mandatory (and no other properties may be specified).</p>
]]></text>
            </annotation>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[
Coded data that consists of a coded value (CV) and, optionally, coded
value(s) from other coding systems that identify the same
concept. Used when alternative codes may exist.
    ]]></text>
            </annotation>
            <annotation annotationType="DESIGN_COMMENTS">
               <text><![CDATA[
<p>
The &lt;object name=&apos;itemName&apos;&gt;&lt;param name=&apos;item&apos; value=&apos;datatype&apos;/&gt;&lt;/object&gt; type is used when the use case indicates that alternative
codes may exist and where it is useful to communicate these. The
&lt;object name=&apos;itemName&apos;&gt;&lt;param name=&apos;item&apos; value=&apos;datatype&apos;/&gt;&lt;/object&gt; type provides for a primary code value, plus a set of
alternative or equivalent representations.
    </p>
]]></text>
            </annotation>
         </documentation>
         <staticExampleEntry annotationType="STATIC_EXAMPLE" businessName="A diagnosis of SARs (prior to the issuing of an ICD10 code), using a local code">
            <text><![CDATA[&lt;value nullFlavor=&apos;OTH&apos;&gt;
	&lt;originalText&gt;SARs&lt;/originalText&gt;
	&lt;translation codeSystem=&apos;2.16.840.1.113883.19.881.57&apos; code=&apos;AB99123788&apos;/&gt;
&lt;/value&gt;
]]></text>
         </staticExampleEntry>
         <parentDatatype isAbstract="false" name="CE" businessName="CodedWithEquivalents" visibility="public" superType="CD" isMerged="false">
            <documentation>
               <businessName>CodedWithEquivalents</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
Coded data that consists of a coded value (CV) and, optionally, coded
value(s) from other coding systems that identify the same
concept. Used when alternative codes may exist.
    ]]></text>
               </annotation>
               <annotation annotationType="DESIGN_COMMENTS">
                  <text><![CDATA[
<p>
The &lt;object name=&apos;itemName&apos;&gt;&lt;param name=&apos;item&apos; value=&apos;datatype&apos;/&gt;&lt;/object&gt; type is used when the use case indicates that alternative
codes may exist and where it is useful to communicate these. The
&lt;object name=&apos;itemName&apos;&gt;&lt;param name=&apos;item&apos; value=&apos;datatype&apos;/&gt;&lt;/object&gt; type provides for a primary code value, plus a set of
alternative or equivalent representations.
    </p>
]]></text>
               </annotation>
            </documentation>
         </parentDatatype>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="CD">
      <datatype isAbstract="false" name="CD" businessName="Coded Value" visibility="public" superType="CD.UV" isMerged="false">
         <documentation>
            <businessName>Coded Value</businessName>
            <annotation annotationType="USAGE_NOTES">
               <text><![CDATA[
<p>If the attribute or property is null, the codeSystem and originalTextproperties are still permitted but not &lt;i&gt;mandatory&lt;/i&gt;.</p>
<p>The rules for supporting the several properties vary depending on whether the element has a coding strength of CWE (Coded with extensibility) or CNE (Coded with no extensibility).</p>
<p>For CWE, &quot;code&quot;, &quot;codeSystem&quot; and &quot;originalText&quot; properties are required. A constraint exists that at least one of &quot;code&quot; and &quot;originalText&quot; must be present and non-null, and that if &quot;code&quot; is present, then &quot;codeSystem is mandatory.</p>
<p>For CNE, &quot;code&quot; and &quot;codeSystem&quot; are mandatory (meaning they must be non-null if the overall attribute or property is non-null). If the element is null with a flavor of OTH (Other), then the &quot;originalText&quot; property is mandatory (and no other properties may be specified).</p>
]]></text>
            </annotation>
         </documentation>
         <staticExampleEntry annotationType="STATIC_EXAMPLE" businessName="a diagnosis of moderate to severe psoriasis of the face with sudden onset">
            <text><![CDATA[&lt;value codeSystem=&apos;2.16.840.1.113883.6.96&apos; code=&apos;402320002&apos;&gt;
	&lt;originalText&gt;Acute, moderate facial psoriasis&lt;/originalText&gt;
	&lt;qualifier&gt;
		&lt;name codeSystem=&apos;2.16.840.1.113883.6.96&apos; code=&apos;246100006&apos;/&gt;
		&lt;value codeSystem=&apos;2.16.840.1.113883.6.96&apos; code=&apos;385315009&apos;/&gt;
	&lt;/qualifier&gt;
	&lt;qualifier&gt;
		&lt;name codeSystem=&apos;2.16.840.1.113883.6.96&apos; code=&apos;246112005&apos;/&gt;
		&lt;value codeSystem=&apos;2.16.840.1.113883.6.96&apos; code=&apos;371924009&apos;/&gt;
	&lt;/qualifier&gt;
&lt;/value&gt;
]]></text>
         </staticExampleEntry>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="II.BUS">
      <datatype isAbstract="false" name="II.BUS" businessName="Instance Identifier (Business)" visibility="public" superType="II" isMerged="false">
         <documentation>
            <businessName>Instance Identifier (Business)</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[Communicates a "business" identifier. This is an identifier which remains consistent as an object evolves. i.e. The identifier does not change when the object undergoes state transitions. Examples include prescription numbers, encounter numbers, lab result numbers, etc.]]></text>
            </annotation>
            <annotation annotationType="CONSTRAINT">
               <text><![CDATA[If extension is present, root must be an OID]]></text>
            </annotation>
         </documentation>
         <staticExampleEntry annotationType="STATIC_EXAMPLE" businessName="Rx number R092377 issued by pharmacy with OID 2.16.840.1.113883.19.335.72">
            <text><![CDATA[&lt;id extension=&apos;R092377&apos; scope=&apos;OBJ&apos; root=&apos;2.16.840.1.113883.19.335.72.7&apos;&gt;
	
&lt;/id&gt;
]]></text>
         </staticExampleEntry>
         <parentDatatype isAbstract="false" name="II" businessName="InstanceIdentifier" visibility="public" superType="ANY" isMerged="false">
            <documentation>
               <businessName>InstanceIdentifier</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
An identifier that uniquely identifies a thing or object. Examples
are object identifier for HL7 RIM objects, medical record number,
order id, service catalog item id, Vehicle Identification Number
(VIN), etc. Instance identifiers are defined based on ISO object
identifiers.
    ]]></text>
               </annotation>
            </documentation>
         </parentDatatype>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="AD.SEARCH">
      <datatype isAbstract="false" name="AD.SEARCH" businessName="Searchable Address" visibility="public" superType="AD" isMerged="false">
         <documentation>
            <businessName>Searchable Address</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[
<p>This type is used to convey high level address information for searching purposes.</p>
<p>All matches are considered to be &quot;starts with&quot; for each specified property.</p>
]]></text>
            </annotation>
            <annotation annotationType="REQUIREMENTS">
               <text><![CDATA[Ballot comment #10]]></text>
            </annotation>
            <annotation annotationType="CONSTRAINT">
               <text><![CDATA[Address parts are rescricted to searchable address parts]]></text>
            </annotation>
            <annotation annotationType="CONSTRAINT">
               <text><![CDATA[at least one part type must be specified (e.g. city)]]></text>
            </annotation>
         </documentation>
         <staticExampleEntry annotationType="STATIC_EXAMPLE" businessName="">
            <text><![CDATA[&lt;addr flavorId=&apos;AD.SEARCH&apos; type=&apos;AD&apos;&gt;
	&lt;city&gt;Edmonton&lt;/city&gt;
	&lt;state code=&apos;AB&apos;&gt;Alberta&lt;/state&gt;
	&lt;country code=&apos;CA&apos;&gt;Canada&lt;/country&gt;
&lt;/addr&gt;
]]></text>
         </staticExampleEntry>
         <parentDatatype isAbstract="false" name="AD" businessName="PostalAddress" visibility="public" superType="LIST" isMerged="false">
            <documentation>
               <businessName>PostalAddress</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
Mailing and home or office addresses. A sequence of address parts,
such as street or post office Box, city, postal code, country, etc.
    ]]></text>
               </annotation>
               <annotation annotationType="DESIGN_COMMENTS">
                  <text><![CDATA[
<p>
The &lt;object name=&apos;itemName&apos;&gt;&lt;param name=&apos;item&apos; value=&apos;datatype&apos;/&gt;&lt;/object&gt; is primarily used to communicate data that will allow
printing mail labels, that will allow a person to physically visit
that address. The postal address data type is not supposed to be a
container for additional information that might be useful for finding
geographic locations (e.g., GPS coordinates) or for performing
epidemiological studies. Such additional information is captured by
other, more appropriate HL7 elements.
    </p>
<p>
Addresses are conceptualized as text with added logical mark-up. The
mark-up may break the address into lines and may describe in detail
the role of each address part if it is known. Address parts occur in
the address in the order in which they would be printed on a mailing
label. The approach is similar to HTML or XML markup of text (but it
is not technically limited to XML representations.)
    </p>
<p>
Addresses are essentially sequences of address parts, but add a &quot;use&quot;
code and a valid time range for information about if and when the
address can be used for a given purpose.
    </p>
]]></text>
               </annotation>
            </documentation>
         </parentDatatype>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="CR">
      <datatype isAbstract="false" name="CR" businessName="Concept Role" visibility="protected" superType="ANY" isMerged="true">
         <documentation>
            <businessName>Concept Role</businessName>
            <annotation annotationType="CONSTRAINT">
               <text><![CDATA[The level of nesting for qualifiers is limited to 3. I.e. A code may be qualified by a code which itself is qualified, but no deeper nesting is permitted.]]></text>
            </annotation>
            <annotation annotationType="CONSTRAINT">
               <text><![CDATA[Translations for "qualifier" is not permitted.]]></text>
            </annotation>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[
A concept qualifier code with optionally named role.  Both qualifier
role and value codes must be defined by the coding system of the CD containing
the concept qualifier.  For example, if SNOMED RT defines a concept "leg", a
role relation "has-laterality", and another concept "left", the concept role
relation allows to add the qualifier "has-laterality: left" to a
primary code "leg" to construct the meaning "left leg".
    ]]></text>
            </annotation>
            <annotation annotationType="DESIGN_COMMENTS">
               <text><![CDATA[
<p>
The use of qualifiers is strictly governed by the code system
used. The &lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;CD&apos;/&gt;&lt;/object&gt; data type does not permit using code
qualifiers with code systems that do not provide for qualifiers
(e.g. pre-coordinated systems, such as LOINC, ICD-10 PCS.)
    </p>
]]></text>
            </annotation>
         </documentation>
         <parentDatatype isAbstract="false" name="CR" businessName="ConceptRole" visibility="protected" superType="ANY" isMerged="false">
            <documentation>
               <businessName>ConceptRole</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
A concept qualifier code with optionally named role.  Both qualifier
role and value codes must be defined by the coding system of the CD containing
the concept qualifier.  For example, if SNOMED RT defines a concept "leg", a
role relation "has-laterality", and another concept "left", the concept role
relation allows to add the qualifier "has-laterality: left" to a
primary code "leg" to construct the meaning "left leg".
    ]]></text>
               </annotation>
               <annotation annotationType="DESIGN_COMMENTS">
                  <text><![CDATA[
<p>
The use of qualifiers is strictly governed by the code system
used. The &lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;CD&apos;/&gt;&lt;/object&gt; data type does not permit using code
qualifiers with code systems that do not provide for qualifiers
(e.g. pre-coordinated systems, such as LOINC, ICD-10 PCS.)
    </p>
]]></text>
               </annotation>
            </documentation>
         </parentDatatype>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="TEL.PHONE">
      <datatype isAbstract="false" name="TEL.PHONE" businessName="Phone Number" visibility="public" superType="TEL" isMerged="false">
         <documentation>
            <businessName>Phone Number</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[Allows phone and fax numbers to be communicated.]]></text>
            </annotation>
            <annotation annotationType="REQUIREMENTS">
               <text><![CDATA[Ballot comment #69]]></text>
            </annotation>
         </documentation>
         <staticExampleEntry annotationType="STATIC_EXAMPLE" businessName="">
            <text><![CDATA[&lt;telecom flavorId=&apos;TEL.PHONE&apos; value=&apos;tel:+1-780-123-4567&apos; use=&apos;EC MC&apos; type=&apos;TEL&apos;&gt;
	
&lt;/telecom&gt;
]]></text>
         </staticExampleEntry>
         <parentDatatype isAbstract="false" name="TEL" businessName="TelecommunicationAddress" visibility="public" superType="URL" isMerged="false">
            <documentation>
               <businessName>TelecommunicationAddress</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
A telephone number (voice or fax), e-mail address, or other locator
for a resource mediated by telecommunication equipment. The address is
specified as a Universal Resource Locator (URL) qualified by time
specification and use codes that help in deciding which address to use
for a given time and purpose.
    ]]></text>
               </annotation>
               <annotation annotationType="DESIGN_COMMENTS">
                  <text><![CDATA[
<p>
The semantics of a telecommunication address is that a communicating
entity (the responder) listens and responds to that address, and
therefore can be contacted by an other communicating entity (the
initiator.)
    </p>
<p>
The responder of a telecommunication address may be an automatic
service that can respond with information (e.g., FTP or HTTP
services.)  In such case a telecommunication address is a reference to
that information accessible through that address. A telecommunication
address value can thus be resolved to some information (in the form of
encapsulated data, &lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;ED&apos;/&gt;&lt;/object&gt;.)
    </p>
<p>
The telecommunication address is an extension of the Universal
Resource Locator (&lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;URL&apos;/&gt;&lt;/object&gt;) specified according to Internet
standard RFC 2396 [&lt;a href=&apos;http://www.ietf.org/rfc/rfc2396.txt&apos;/&gt;].
The &lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;URL&apos;/&gt;&lt;/object&gt; specifies the protocol and the contact point
defined by that protocol for the resource. Notable use cases for the
telecommunication address data type are for telephone and fax numbers,
e-mail addresses, Hypertext references, FTP references, etc.
    </p>
]]></text>
               </annotation>
            </documentation>
         </parentDatatype>
      </datatype>
   </datatypeEntry>
   <datatypeEntry name="CO">
      <datatype isAbstract="false" name="CO" businessName="CodedOrdinal" visibility="public" superType="CV" isMerged="false">
         <documentation>
            <businessName>CodedOrdinal</businessName>
            <annotation annotationType="DEFINITION">
               <text><![CDATA[
Coded data, where the domain from which the codeset comes is ordered. The
Coded Ordinal data type adds semantics related to ordering so that models
that make use of such domains may introduce model elements that involve
statements about the order of the terms in a domain.
    ]]></text>
            </annotation>
            <annotation annotationType="DESIGN_COMMENTS">
               <text><![CDATA[
<p>
The relative order of this type&apos;s values need not be independently
obvious in their literal representation. It is expected that an
application will look up the ordering of these values from some
table.
    </p>
]]></text>
            </annotation>
         </documentation>
      </datatype>
   </datatypeEntry>
   <parentDatatypeSet version="1.1" realmCode="UV" combinedId="DEFN=UV=DT=1.1">
      <datatypeEntry name="HXIT">
         <datatype isAbstract="false" name="HXIT" businessName="HistoryItem" visibility="protected" superType="T" isMerged="false">
            <documentation>
               <businessName>HistoryItem</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
A generic data type extension that tags a time range to any data value
of any data type.  The time range is the time in which the information
represented by the value is (was) valid.
    ]]></text>
               </annotation>
               <annotation annotationType="DESIGN_COMMENTS">
                  <text><![CDATA[
<p>
If the base type T does not possess a validTime property, the
&lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;HXIT&apos;/&gt;&lt;/object&gt; adds that property to the base type. If, however,
the base type T does have a valid time property (currently only EN),
that property is mapped to the valid time property of the
&lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;HXIT&apos;/&gt;&lt;/object&gt;.&lt;object name=&apos;footnote&apos;&gt;Note that data types are specifications of abstract properties of
values. This specification does not mandate how these values are
represented in an ITS or implemented in an application. Specifically,
it does not mandate how the represented components are named or
positioned. In addition, the semantic generalization hierarchy may be
different from a class hierarchy chosen for implementation (if the
implementation technology has inheritance.)  Keep the distinction
between a type (interface) and an implementation (concrete data
structure, class) in mind. The ITS must contain a mapping of ITS
defined features of any data type to the semantic properties defined
here.&lt;/object&gt;
				              </p>
]]></text>
               </annotation>
            </documentation>
         </datatype>
      </datatypeEntry>
      <datatypeEntry name="OID">
         <datatype isAbstract="false" name="OID" businessName="ObjectIdentifier" visibility="protected" superType="UID, LIST" isMerged="false">
            <documentation>
               <businessName>ObjectIdentifier</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
A globally unique string representing an ISO Object Identifier
(OID) in a form that consists only of numbers and dots (e.g.,
"2.16.840.1.113883.3.1"). According to ISO, OIDs are paths in a tree
structure, with the left-most number representing the root and the
right-most number representing a leaf.
    ]]></text>
               </annotation>
               <annotation annotationType="DESIGN_COMMENTS">
                  <text><![CDATA[
<p>
Each branch under the root corresponds to an assigning authority. Each
of these assigning authorities may, in turn, designate its own set of
assigning authorities that work under its auspices, and so on down the
line. Eventually, one of these authorities assigns a unique (to it as
an assigning authority) number that corresponds to a leaf node on the
tree. The leaf may represent an assigning authority (in which case the
root OID identifies the authority), or an instance of an object. An
assigning authority owns a namespace, consisting of its sub-tree.
    </p>
<p>
OIDs are the preferred scheme for unique identifiers. OIDs should
always be used except if one of the inclusion criteria for other
schemes apply.
    </p>
<p>
ISO/IEC 8824:1990(E) clause 28 defines the Object Identifier as
    </p>
<p>
                     &lt;p&gt;&lt;b&gt;28.9&lt;/b&gt; The semantics of an
object identifier value are defined by reference to an &lt;b&gt;object identifier tree&lt;/b&gt;. An object identifier tree is a tree whose root
corresponds to [the ISO/IEC 8824 standard] and whose vertices [i.e. nodes]
correspond to administrative authorities responsible for allocating arcs [i.e.
branches] from that vertex. Each arc from that tree is labeled by an object
identifier component, which is [an integer number]. Each information object to
be identified is allocated precisely one vertex (normally a leaf) and no other
information object (of the same or a different type) is allocated to
that same vertex. Thus an information object is uniquely and
unambiguously identified by the sequence of [integer numbers] (object
identifier components) labeling the arcs in a path from the root to
the vertex allocated to the information object.&lt;/p&gt;
                     &lt;p&gt;&lt;b&gt;28.10&lt;/b&gt; An object identifier value is
semantically an ordered list of object identifier component
values. Starting with the root of the object identifier tree, each
object identifier component value identifies an arc in the object
identifier tree. The last object identifier component value identifies
an arc leading to a vertex to which an information object has been
assigned. It is this information object, which is identified by the
object identifier value. [...]&lt;/p&gt;
                  </p>
<p>
According to ISO/IEC 8824 an object identifier is a sequence of object
identifier component values, which are integer numbers. These
component values are ordered such that the root of the object
identifier tree is the head of the list followed by all the arcs down
to the leaf representing the information object identified by the
OID. The fact that OID specializes &lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;LIST&apos;/&gt;&lt;/object&gt;&lt;
&lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;INT&apos;/&gt;&lt;/object&gt;&gt; represents this path of object identifier component
values from the root to the leaf.
    </p>
<p>
The &lt;b&gt;leaf&lt;/b&gt; and &quot;&lt;b&gt;butLeaf&lt;/b&gt;&quot;
properties take the opposite view. The
leaf is the last object identifier component value in the list, and
the &quot;butLeaf&quot; property is all of the OID &lt;b&gt;but&lt;/b&gt; the
&lt;b&gt;leaf&lt;/b&gt;. In a sense, the leaf is the identifier value and
all of the OID but the leaf refers to the namespace in which the leaf
is unique and meaningful.
    </p>
<p>
However, what part of the OID is considered &lt;b&gt;value&lt;/b&gt;
and what is &lt;b&gt;namespace&lt;/b&gt; may be viewed differently. In
general, any OID component sequence to the left can be considered the namespace
in which the rest of the sequence to the right is defined as a
meaningful and unique identifier value. The value-property with a
namespace OID as its argument represents this point of view.&lt;object name=&apos;footnote&apos;&gt;The value/namespace view on ISO object identifiers has important
semantic relevance. It represents the notion of identifier value
versus identifier assigning authority (= namespace), which is common
in healthcare information systems in general, and HL7 v2.x in
particular.&lt;/object&gt;
				              </p>
<p>section-OID.procedures
HL7 shall establish an OID registry and assign OIDs in its branch for
HL7 users and vendors upon their request. HL7 shall also assign OIDs
to public identifier-assigning authorities both U.S. nationally (e.g.,
the U.S. State driver license bureaus, U.S. Social Security
Administration, HIPAA Provider ID registry, etc.) and internationally
(e.g., other countries Social Security Administrations, Citizen ID
registries, etc.) The HL7 registered OIDs must be used for these
organizations, regardless whether these organizations have other OIDs
assigned from other sources.
      
When assigning OIDs to third parties or entities, HL7 shall
investigate whether an OID is already assigned for such entities
through other sources. It this is the case, HL7 shall record such OID
in a catalog, but HL7 shall not assign a duplicate OID in the HL7
branch. If possible, HL7 shall notify a third party when an OID is
being assigned for that party in the HL7 branch.
      
Though HL7 shall exercise diligence before assigning an OID in the HL7
branch to third parties, given the lack of a global OID registry
mechanism, one cannot make absolutely certain that there is no
preexisting OID assignment for such third-party entity. Also, a
duplicate assignment can happen in the future through another
source. If such cases of supplicate assignment become known to HL7,
HL7 shall make efforts to resolve this situation. For continued
interoperability in the meantime, the HL7 assigned OID shall be the
preferred OID used.
      
While most owners of an OID will &quot;design&quot; their namespace sub-tree in
some meaningful way, there is no way to generally infer any meaning on
the parts of an OID. HL7 does not standardize or require any namespace
sub-structure. An OID owner, or anyone having knowledge about the
logical structure of part of an OID, may still use that knowledge to
infer information about the associated object; however, the techniques
cannot be generalized.
      
						Example for a tree of ISO object identifiers. HL7&apos;s OID
        is 2.16.840.1.113883.
						
					
						An HL7 interface must not rely on any
knowledge about the substructure of an OID for which it cannot control the
assignment policies.
					</p>
]]></text>
               </annotation>
            </documentation>
         </datatype>
      </datatypeEntry>
      <datatypeEntry name="CAL">
         <datatype isAbstract="false" name="CAL" businessName="Calendar" visibility="private" superType="SET" isMerged="false">
            <documentation>
               <businessName>Calendar</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
A calendar is a concept of measuring time in various cycles. Such
cycles are years, months, days, hours, minutes, seconds, and
weeks. Some of these cycles are synchronized and some are not (e.g.,
weeks and months are not synchronized.)
      ]]></text>
               </annotation>
               <annotation annotationType="DESIGN_COMMENTS">
                  <text><![CDATA[
<p>
After &quot;rolling the time axis&quot; into these cycles (See the figure)
a calendar expresses a point in time as a sequence
of integer counts of cycles, e.g., for year, month, day, hour,
etc. The calendar is rooted in some conventional start point, called
the &quot;epoch.&quot;
      </p>
<p></p>
<p>
A calendar &quot;rolls&quot; the time axis into a complex convolute according to
the calendar periods year (blue), month (yellow), day (green), hour
(red), etc. The cycles need not be aligned, for example, the week (not
shown) is not aligned to the month.&lt;object name=&apos;footnote&apos;&gt;Imagine a special clock that measures those cycles, where the pointers
are not all stacked on a common axis but each pointer is attached to
the end of the pointer measuring the next larger cycle.&lt;/object&gt;
                  </p>
<p>
Calendar is defined as a set of calendar cycles, and has a name and a
code. The head of the Calendar is the largest CalendarCycle appearing
right most in the calendar expression. The epoch is the beginning of
that calendar, i.e., the point in time where all calendar cycles are
zero.
      </p>
<p>
The calendar definition can be shown as in &lt;object name=&apos;conceptDomainRef&apos;&gt;&lt;param name=&apos;domain&apos; value=&apos;CalendarCycle&apos;/&gt;&lt;/object&gt;
for the modern Gregorian calendar. The calendar definition table lists a
calendar cycle in each row. The calendar units are dependent on each other and
defined in the value column. The sequence column shows the relationship through
the next property. The other columns are as in the formal calendar cycle
definition.&lt;object name=&apos;footnote&apos;&gt;At present, the CalendarCycle properties sum and value are not
formally defined. The computation of calendar digits involves some
complex computation which to specify here would be hard to understand
and evaluate for correctness. Unfortunately, no standard exists that
would formally define the relationship between calendar expressions
and elapsed time since an epoch. ASN.1, the XML Schema Data Type
specification and SQL92 all refer to ISO 8601, however, ISO 8601 does
only specify the syntax of Gregorian calendar expressions, but not
their semantics. In this standard, we define the syntax and semantics
formally, however, we presume the semantics of the sum-, and
value-properties to be defined elsewhere.&lt;/object&gt;
				              </p>
]]></text>
               </annotation>
            </documentation>
         </datatype>
      </datatypeEntry>
      <datatypeEntry name="ENXP">
         <datatype isAbstract="false" name="ENXP" businessName="EntityNamePart" visibility="protected" superType="SC" isMerged="false">
            <documentation>
               <businessName>EntityNamePart</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
A character string token representing a part of a name. May have a
type code signifying the role of the part in the whole entity name,
and a qualifier code for more detail about the name part type.
Typical name parts for person names are given names, and family names,
titles, etc.
    ]]></text>
               </annotation>
            </documentation>
         </datatype>
      </datatypeEntry>
      <datatypeEntry name="HIST">
         <datatype isAbstract="false" name="HIST" businessName="History" visibility="public" superType="SET" isMerged="false">
            <documentation>
               <businessName>History</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
A set of data values that have a a valid-time property and thus
conform to the history item (HXIT) type. The history information is
not limited to the past; expected future values can also appear.
      ]]></text>
               </annotation>
               <annotation annotationType="DESIGN_COMMENTS">
                  <text><![CDATA[
<p>
The intent of the HIST data type is to capture the true historical
(and future) values of an item, rather than the audit trail of
values any given system has held for the item
      </p>
]]></text>
               </annotation>
            </documentation>
         </datatype>
      </datatypeEntry>
      <datatypeEntry name="RTO">
         <datatype isAbstract="false" name="RTO" businessName="Ratio" visibility="public" superType="QTY" isMerged="false">
            <documentation>
               <businessName>Ratio</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
<p>
                     &lt;param name=&apos;item&apos; value=&apos;datatype&apos;/&gt;
                  </p>
<p>
                     &lt;param name=&apos;datatypeName&apos; value=&apos;REAL&apos;/&gt;
                  </p>
<p>
                     &lt;param name=&apos;item&apos; value=&apos;datatype&apos;/&gt;
                  </p>
]]></text>
               </annotation>
               <annotation annotationType="DESIGN_COMMENTS">
                  <text><![CDATA[
<p>
Ratios are different from rational numbers, i.e., in ratios common
factors in the numerator and denominator never cancel out.  A ratio of
two real or integer numbers is not automatically reduced to a real
number.
    </p>
<p>
The default value for both numerator and denominator is the integer
number 1 (one.) The denominator may not be zero.
    </p>
]]></text>
               </annotation>
            </documentation>
         </datatype>
      </datatypeEntry>
      <datatypeEntry name="ED">
         <datatype isAbstract="false" name="ED" businessName="EncapsulatedData" visibility="public" superType="BIN" isMerged="false">
            <documentation>
               <businessName>EncapsulatedData</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
<p>
                     &lt;param name=&apos;datatypeName&apos; value=&apos;ED&apos;/&gt;
                  </p>
<p>
                     &lt;param name=&apos;datatypeName&apos; value=&apos;TEL&apos;/&gt;
                  </p>
<p>
                     &lt;param name=&apos;datatypeName&apos; value=&apos;ST&apos;/&gt;
                  </p>
<p>
                     &lt;param name=&apos;datatypeName&apos; value=&apos;ED&apos;/&gt;
                  </p>
<p>
                     &lt;param name=&apos;datatypeName&apos; value=&apos;ED&apos;/&gt;
                  </p>
]]></text>
               </annotation>
               <annotation annotationType="DESIGN_COMMENTS">
                  <text><![CDATA[
<p>
Encapsulated data can be present in two forms, inline or by
reference. Inline data is communicated or moved as part of the
encapsulated data value, whereas by-reference data may reside at a
different (remote) location. The data is the same whether it is
located inline or remote.
    </p>
]]></text>
               </annotation>
            </documentation>
         </datatype>
      </datatypeEntry>
      <datatypeEntry name="UUID">
         <datatype isAbstract="false" name="UUID" businessName="UniversalUniqueIdentifier" visibility="protected" superType="UID" isMerged="false">
            <documentation>
               <businessName>UniversalUniqueIdentifier</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
A globally unique string representing a DCE Universal Unique
Identifier (UUID) in the common UUID format that consists of 5
hyphen-separated groups of hexadecimal digits having 8, 4, 4, 4,
and 12 places respectively.
    ]]></text>
               </annotation>
               <annotation annotationType="DESIGN_COMMENTS">
                  <text><![CDATA[
<p>
Both the UUID and its string representation are defined by the Open
Group, CDE 1.1 Remote Procedure Call specification, Appendix A.
    </p>
<p>
UUIDs are assigned based on Ethernet MAC addresses, the point in time
of creation and some random component. This mix is believed to
generate sufficiently unique identifiers without any organizational
policy for identifier assignment (in fact this piggy-backs on the
organization of MAC address assignment.)
    </p>
<p>
UUIDs are &lt;b&gt;not&lt;/b&gt; the preferred identifier
scheme for use as HL7 UIDs. UUIDs may be used when identifiers are
issued to objects representing individuals (e.g., entity instance
identifiers, act event identifiers, etc.) For objects describing
classes of things or events (e.g., catalog items), OIDs are the
preferred identifier scheme.
    </p>
]]></text>
               </annotation>
            </documentation>
         </datatype>
      </datatypeEntry>
      <datatypeEntry name="PIVL">
         <datatype isAbstract="false" name="PIVL" businessName="PeriodicIntervalOfTime" visibility="public" superType="SET" isMerged="false">
            <documentation>
               <businessName>PeriodicIntervalOfTime</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
An interval of time that recurs periodically. Periodic intervals have
two properties, phase and period. The phase specifies the "interval
prototype" that is repeated every period.
    ]]></text>
               </annotation>
               <annotation annotationType="DESIGN_COMMENTS">
                  <text><![CDATA[
<p>
For example, &quot;every eight hours for two minutes&quot; is a periodic
interval where the interval&apos;s width equals 2 minutes and the period
at which the interval recurs equals 8 hours.
    </p>
<p>
The phase also marks the anchor point in time for the entire series of
periodically recurring intervals. The recurrence of a periodic interval has no
beginning or ending, but is infinite in both future and past.
    </p>
<p>
A periodic interval is fully specified when both the period and the
phase are fully specified. The interval may be only partially
specified where either only the width or only one boundary is
specified.
    </p>
<p>
For example: &quot;every eight hours for two minutes&quot; specifies only the
period and the phase&apos;s width but no boundary of the phase. Conversely,
&quot;every eight hours starting at 4 o&apos;clock&quot; specifies only the period
and the phase&apos;s low boundary but not the phase&apos;s high boundary. &quot;Every
eight hours for two minutes starting at 4 o&apos;clock&quot; is fully specified
since the period, and both the phase&apos;s low boundary and width are
specified (low boundary and width implies the high boundary.)
    </p>
<p>
The periodic interval of time is a generic type extension whose type
parameter T is restricted to the point in time (&lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;TS&apos;/&gt;&lt;/object&gt;)
data type and its extensions. The parametric probability distribution
of point in time (&lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;PPD&apos;/&gt;&lt;/object&gt;&lt;&lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;TS&apos;/&gt;&lt;/object&gt;&gt;) is
an extension of point in time and therefore can be used to form
periodic intervals of probability distributions of point in time
(&lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;PIVL&apos;/&gt;&lt;/object&gt;&lt;&lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;PPD&apos;/&gt;&lt;/object&gt;
&lt;&lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;TS&apos;/&gt;&lt;/object&gt;&gt;&gt;) values (uncertain periodic interval.)
    </p>
<p>
Oftentimes repeating schedules are only approximately specified. For
instance &quot;three times a day for ten minutes each&quot; does not usually
mean a period of precisely 8 hours and does often not mean exactly 10
minutes intervals. Rather the distance between each occurrence may
vary as much as between 3 and 12 hours and the width of the interval
may be less than 5 minutes or more than 15 minutes. An uncertain
periodic interval can be used to indicate how much leeway is allowed
or how &quot;timing-critical&quot; the specification is.
    </p>
<p>
The essential property of a set is that it contains elements. For
non-aligned periodic intervals, the contains-property is
defined as follows. A point in time t is contained in the
periodic interval of time if and only if there is an integer
i for which t plus the period times
i is an element of the phase interval.
      
invariant (PIVL&lt;TS&gt; x, TS t)
    where x.nonNull.and(x.alignment.isNull) {
  x.contains(t).equal(exists(INT i) {
       x.phase.contains(t.plus(x.period.times(i)));
     });
};
      
For calendar-aligned periodic intervals the contains
property is defined using the calendar-cycle&apos;s sum(t,
n) property that adds n such calendar cycles
to the time t.
      
invariant (PIVL&lt;TS&gt; x, TS t, CalendarCycle c)
    where x.nonNull.and(c.equal(x.alignment)) {
  x.contains(t).equal(exists(INT i) {
        x.phase.contains(c.sum(t, i));
     });
};
      </p>
]]></text>
               </annotation>
            </documentation>
         </datatype>
      </datatypeEntry>
      <datatypeEntry name="TN">
         <datatype isAbstract="false" name="TN" businessName="TrivialName" visibility="public" superType="EN" isMerged="false">
            <documentation>
               <businessName>TrivialName</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
A restriction of entity name that is effectively a simple string used
for a simple name for things and places.
    ]]></text>
               </annotation>
               <annotation annotationType="DESIGN_COMMENTS">
                  <text><![CDATA[
<p>
The &lt;object name=&apos;itemName&apos;&gt;&lt;param name=&apos;item&apos; value=&apos;datatype&apos;/&gt;&lt;/object&gt; is a &lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;EN&apos;/&gt;&lt;/object&gt; that consists of only one name
part without any name part type or qualifier. The &lt;object name=&apos;itemName&apos;&gt;&lt;param name=&apos;item&apos; value=&apos;datatype&apos;/&gt;&lt;/object&gt;, and its
single name part are therefore equivalent to a simple character
string. This equivalence is expressed by a defined demotion to
&lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;ST&apos;/&gt;&lt;/object&gt; and promotion from &lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;ST&apos;/&gt;&lt;/object&gt;.
    </p>
<p>
Trivial names are typically used for places and things, such as
&lt;b&gt;Lake Erie&lt;/b&gt; or &lt;b&gt;Reagan National Airport&lt;/b&gt;:
    </p>
]]></text>
               </annotation>
            </documentation>
            <staticExampleEntry annotationType="STATIC_EXAMPLE" businessName="">
               <text><![CDATA[&lt;example noxmlspace=&apos;preserve&apos;&gt;
	&lt;name&gt;Lake Erie&lt;/name&gt;
	&lt;name&gt;Washington National Airport&lt;/name&gt;
&lt;/example&gt;
]]></text>
            </staticExampleEntry>
         </datatype>
      </datatypeEntry>
      <datatypeEntry name="TS">
         <datatype isAbstract="false" name="TS" businessName="PointInTime" visibility="public" superType="QTY" isMerged="false">
            <documentation>
               <businessName>PointInTime</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
A quantity specifying a point on the axis of natural time. A point
in time is most often represented as a calendar expression.
    ]]></text>
               </annotation>
               <annotation annotationType="DESIGN_COMMENTS">
                  <text><![CDATA[
<p>
Semantically, however, time is independent from calendars and best
described by its relationship to elapsed time (measured as a physical
quantity in the dimension of time.)  A point in time plus an elapsed
time yields another point in time.  Inversely, a point in time minus
another point in time yields an elapsed time.
    </p>
<p>
As nobody knows when time began, a point in time is conceptualized as
the amount of time that has elapsed from some arbitrary zero-point,
called an epoch.  Because there is no absolute zero-point on the time
axis natural time is a difference-scale quantity, where only
differences are defined but no ratios. (For example, no point in time
is &#8212; absolutely speaking &#8212; &quot;twice as late&quot; as another
point in time.)
    </p>
<p>
Given some arbitrary zero-point, one can express any point in time as
an elapsed time measured from that offset. Such an arbitrary
zero-point is called an epoch. This epoch-offset form is used as a
semantic representation here, without implying that any system would
have to implement the TS data type in that way. Systems that do not
need to compute distances between points in time will not need any
other representation than a calendar expression literal.
    </p>
]]></text>
               </annotation>
            </documentation>
         </datatype>
      </datatypeEntry>
      <datatypeEntry name="SET">
         <datatype isAbstract="false" name="SET" businessName="Set" visibility="public" superType="ANY" isMerged="false">
            <documentation>
               <businessName>Set</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
A value that contains other distinct values in no particular order.
    ]]></text>
               </annotation>
            </documentation>
         </datatype>
      </datatypeEntry>
      <datatypeEntry name="ST">
         <datatype isAbstract="false" name="ST" businessName="CharacterString" visibility="public" superType="ED" isMerged="false">
            <documentation>
               <businessName>CharacterString</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
The character string data type stands for text data, primarily
intended for machine processing (e.g., sorting, querying, indexing,
etc.) Used for names, symbols, and formal expressions.
    ]]></text>
               </annotation>
               <annotation annotationType="REQUIREMENTS">
                  <text><![CDATA[
<p>
						               &lt;strong&gt;Requirement&lt;/strong&gt;:&lt;br/&gt;
ST is a specialization of ED so that any RIM attribute which has the type
ED can be constrained to a ST. The most important case is Act.text, which is
an ED to cater for the use of references and multimedia data, but is often
constrained to plain text.
</p>
]]></text>
               </annotation>
               <annotation annotationType="DESIGN_COMMENTS">
                  <text><![CDATA[
<p>
The character string is a restricted encapsulated data type (&lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;ED&apos;/&gt;&lt;/object&gt;),
whose type property is fixed to &lt;b&gt;text/plain&lt;/b&gt;, and whose data must be
inlined and not compressed. Thus, the properties compression, reference,
integrity check, algorithm, and thumbnail are not applicable. The character
string data type is used when the appearance of text does not bear meaning,
which is true for formalized text and all kinds of names.
    </p>
<p>
The character string (ST) data type interprets the encapsulated data
as character data (as opposed to bits), depending on the charset
property of the encapsulated data type.
    </p>
<p>
The headCharacter and tailString properties define ST as a sequence
of entities each of which uniquely identifies one character from the
joint set of all characters known by any language of the world. &lt;object name=&apos;footnote&apos;&gt;ISO/IEC 10646-1: 1993 defines a character as &quot;A member of a set of
elements used for the organization, control, or representation of
data.&quot;  ISO/IEC TR 15285 - An operational model for characters and
glyphs. Discusses the problems involved in defining
characters. Notably, characters are abstract entities of information,
independent of type font or language. The ISO 10646 (UNICODE
[http://www.unicode.org]) - or in Japan, JIS X0221 - is a globally
applicable character set that uniquely identifies all characters of
any language in the world.
        
In this specification, ISO 10646 serves as a semantic model for
character strings. The important point is that for semantic purposes,
there is no notion of separate character sets and switching between
character sets. Character set and character encoding are ITS layer
considerations. The formal definition gives indication to this effect
because each character is by itself an  value that
has a charset property. Thus, the binary encoding of each character is
always understood in the context of a certain character set. This does
not mean that the ITS should represent a character string as a
sequence of full blown  values. What it means is that
on the application layer the notion of character encoding is
irrelevant when we deal with character strings.&lt;/object&gt;
The length of a character string is the number of characters in the string.
    </p>
<p>
The head of a string is a string of only one character. A character
string must at least have one character or else it is NULL. A
zero-length string is an exceptional value (NULL), not a proper
character string value.
    </p>
<p>
The length of a string is the number of characters, not the number of
encoded bytes. Byte encoding is an ITS issue and is not relevant on
the application layer.
    </p>
<p>
The following rules apply to whitespace contained within character strings:
    </p>
<p>
                     &lt;li&gt;&lt;p&gt;TAB, space and end-of-line are all considered whitespace characters.&lt;/p&gt;&lt;/li&gt;
                     &lt;li&gt;&lt;p&gt;Both preceding and trailing whitespace is significant.&lt;/p&gt;&lt;/li&gt;
                     &lt;li&gt;&lt;p&gt;Different whitespace characters are not interchangable.&lt;/p&gt;&lt;/li&gt;
                     &lt;li&gt;&lt;p&gt;&lt;a href=&apos;http://www.w3.org/TR/2000/REC-xml-20001006#sec-line-ends&apos;/&gt;]&lt;/p&gt;&lt;/li&gt;
                     &lt;li&gt;&lt;p&gt;Sequences of whitespace cannot be compressed to shorter sequences.&lt;/p&gt;&lt;/li&gt;
                  </p>
]]></text>
               </annotation>
            </documentation>
         </datatype>
      </datatypeEntry>
      <datatypeEntry name="INT">
         <datatype isAbstract="false" name="INT" businessName="IntegerNumber" visibility="public" superType="QTY" isMerged="false">
            <documentation>
               <businessName>IntegerNumber</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
Integer numbers (-1,0,1,2, 100, 3398129, etc.) are precise numbers
that are results of counting and enumerating. Integer numbers are
discrete, the set of integers is infinite but countable.  No arbitrary
limit is imposed on the range of integer numbers. Two NULL flavors are
defined for the positive and negative infinity.
    ]]></text>
               </annotation>
               <annotation annotationType="DESIGN_COMMENTS">
                  <text><![CDATA[
<p>
Since the integer number data type includes all of the semantics of
the mathematical integer number concept, the basic operations plus
(addition) and times (multiplication) are defined. These operations
are defined here as characterizing operations in the sense of ISO
11404, and because these operations are needed in other parts of this
specification, namely the semantics of the literal form.
    </p>
<p>
The traditional recursive definitions of addition and multiplication
are due to Grassmann, and use the notion of &lt;object name=&apos;propertyRef&apos;&gt;&lt;param name=&apos;propertyName&apos; value=&apos;successor&apos;/&gt;
                        &lt;param name=&apos;datatypeName&apos; value=&apos;INT&apos;/&gt;&lt;/object&gt;.&lt;object name=&apos;footnote&apos;&gt;H. Grassman. Lehrbuch der Arithmetik. 1861. We prefer
Grassman&apos;s original axioms to the Peano axioms, because Grassman&apos;s
axioms work for all integers, not just for natural numbers. Also, &quot;it
is rather well-known, through Peano&apos;s own acknowledgment, that Peano
borrowed his axioms from Dedekind and made extensive use of
Grassmann&apos;s work in his development of the axioms.&quot; (Hao Wang. The
Axiomatization of Arithmetic. J. Symb. Logic; 1957:22(2); p. 145.)&lt;/object&gt;
				              </p>
]]></text>
               </annotation>
            </documentation>
         </datatype>
      </datatypeEntry>
      <datatypeEntry name="UVP">
         <datatype isAbstract="false" name="UVP" businessName="UncertainValueProbabilistic" visibility="public" superType="T" isMerged="false">
            <documentation>
               <businessName>UncertainValueProbabilistic</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
A generic data type extension used to specify a probability expressing
the information producer's belief that the given value holds.
    ]]></text>
               </annotation>
               <annotation annotationType="DESIGN_COMMENTS">
                  <text><![CDATA[
<p>
How the probability number was arrived at is outside the scope of this
specification.
    </p>
<p>
Probabilities are subjective and (as any data value) must be
interpreted in their individual context, for example, when new
information is found the probability might change. Thus, for any
message (document, or other information representation) the
information &#8212; and particularly the probabilities &#8212; reflect
what the information producer believed was appropriate for the purpose
and at the time the message (document) was created.
    </p>
<p>
For example, at the beginning of the 2000 baseball season (May), the
Las Vegas odds makers may have given the New York Yankees a
probability of 1 in 10 (0.100) of winning the World Series. At the
time of this writing, the Yankees and Mets have won their respective
pennants, but the World Series has yet to begin. The probability of
the Yankees winning the World Series is obviously significantly
greater at this point in time, perhaps 6 in 10 (0.600). The context,
and in particular the time of year, made all the difference in the
world.
    </p>
<p>
Since probabilities are subjective measures of belief, they can be
stated without being &quot;correct&quot; or &quot;incorrect&quot; per se, let alone
&quot;precise&quot; or &quot;imprecise&quot;. Notably, one does not have to conduct
experiments to measure a frequency of some outcome in order to specify
a probability. In fact, whenever statements about individual people or
events are made, it is not possible to confirm such probabilities with
&quot;frequentists&quot; experiments.
    </p>
<p>
Returning to our example, the Las Vegas odds makers can not insist on
the Yankees and Mets playing 1000 trial games prior to the Series;
even if they could, they would not have the fervor of the real Series
and therefore not be accurate. Instead, the odds makers must derive
the probability from past history, player statistics, injuries, etc.
    </p>
<p>
The type T is not formally constrained. In theory, discrete
probabilities can only be stated for discrete data values. Thus,
generally &lt;object name=&apos;itemName&apos;&gt;&lt;param name=&apos;item&apos; value=&apos;datatype&apos;/&gt;&lt;/object&gt; should not be used with &lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;REAL&apos;/&gt;&lt;/object&gt;,
&lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;PQ&apos;/&gt;&lt;/object&gt;, or &lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;MO&apos;/&gt;&lt;/object&gt; values. 
    </p>
]]></text>
               </annotation>
            </documentation>
         </datatype>
      </datatypeEntry>
      <datatypeEntry name="TEL">
         <datatype isAbstract="false" name="TEL" businessName="TelecommunicationAddress" visibility="public" superType="URL" isMerged="false">
            <documentation>
               <businessName>TelecommunicationAddress</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
A telephone number (voice or fax), e-mail address, or other locator
for a resource mediated by telecommunication equipment. The address is
specified as a Universal Resource Locator (URL) qualified by time
specification and use codes that help in deciding which address to use
for a given time and purpose.
    ]]></text>
               </annotation>
               <annotation annotationType="DESIGN_COMMENTS">
                  <text><![CDATA[
<p>
The semantics of a telecommunication address is that a communicating
entity (the responder) listens and responds to that address, and
therefore can be contacted by an other communicating entity (the
initiator.)
    </p>
<p>
The responder of a telecommunication address may be an automatic
service that can respond with information (e.g., FTP or HTTP
services.)  In such case a telecommunication address is a reference to
that information accessible through that address. A telecommunication
address value can thus be resolved to some information (in the form of
encapsulated data, &lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;ED&apos;/&gt;&lt;/object&gt;.)
    </p>
<p>
The telecommunication address is an extension of the Universal
Resource Locator (&lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;URL&apos;/&gt;&lt;/object&gt;) specified according to Internet
standard RFC 2396 [&lt;a href=&apos;http://www.ietf.org/rfc/rfc2396.txt&apos;/&gt;].
The &lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;URL&apos;/&gt;&lt;/object&gt; specifies the protocol and the contact point
defined by that protocol for the resource. Notable use cases for the
telecommunication address data type are for telephone and fax numbers,
e-mail addresses, Hypertext references, FTP references, etc.
    </p>
]]></text>
               </annotation>
            </documentation>
         </datatype>
      </datatypeEntry>
      <datatypeEntry name="BN">
         <datatype isAbstract="false" name="BN" businessName="BooleanNonNull" visibility="private" superType="BL" isMerged="false">
            <documentation>
               <businessName>BooleanNonNull</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
The BooleanNonNull constrains the boolean type so that the value may not be NULL.
This type is created for use within the data types specification where it is not
appropriate for a null value to be used
    ]]></text>
               </annotation>
            </documentation>
         </datatype>
      </datatypeEntry>
      <datatypeEntry name="QTY">
         <datatype isAbstract="true" name="QTY" businessName="Quantity" visibility="public" superType="ANY" isMerged="false">
            <documentation>
               <businessName>Quantity</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
The quantity data type is an abstract generalization for all data
types (1) whose value set has an order relation (less-or-equal) and
(2) where difference is defined in all of the data type's totally
ordered value subsets.  The quantity type abstraction is needed in
defining certain other types, such as the interval and the probability
distribution.
    ]]></text>
               </annotation>
            </documentation>
         </datatype>
      </datatypeEntry>
      <datatypeEntry name="URG">
         <datatype isAbstract="false" name="URG" businessName="UncertainRange" visibility="public" superType="T" isMerged="false">
            <documentation>
               <businessName>UncertainRange</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
					Indicates that the value comes from a range of possible values from an ordered base data type value.
				]]></text>
               </annotation>
               <annotation annotationType="DESIGN_COMMENTS">
                  <text><![CDATA[
<p>
					                &lt;object name=&apos;itemName&apos;&gt;&lt;param name=&apos;item&apos; value=&apos;datatype&apos;/&gt;&lt;/object&gt; is used where the actual value is unknown, but it is known that the 
					value comes from a known range of possible values. 
				</p>
<p>
					                &lt;object name=&apos;itemName&apos;&gt;&lt;param name=&apos;item&apos; value=&apos;datatype&apos;/&gt;&lt;/object&gt; differs from &lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;PPD&apos;/&gt;&lt;/object&gt; in that &lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;PPD&apos;/&gt;&lt;/object&gt; is used to report a 
					particular value along with an associated distribution of uncertainty for the 
					value, or to report the summary distribution of a set of data, whereas &lt;object name=&apos;itemName&apos;&gt;&lt;param name=&apos;item&apos; value=&apos;datatype&apos;/&gt;&lt;/object&gt; indicates
					that there is a single value that, although unknown, must come from a particular range
					of values. No inference regarding distribution of values can be taken. &lt;object name=&apos;itemName&apos;&gt;&lt;param name=&apos;item&apos; value=&apos;datatype&apos;/&gt;&lt;/object&gt; 
					is often associated with an instruction to perform a particular operation at 
					some point within a given time interval.  
				</p>
<p>
					Any ordered type can be the basis of an &lt;object name=&apos;itemName&apos;&gt;&lt;param name=&apos;item&apos; value=&apos;datatype&apos;/&gt;&lt;/object&gt;; it does not matter
					whether the base type is discrete or continuous. If the base data type
					is only partially ordered, all possible values for the &lt;object name=&apos;itemName&apos;&gt;&lt;param name=&apos;item&apos; value=&apos;datatype&apos;/&gt;&lt;/object&gt; are
					elements of a totally ordered subset of the partially ordered data
					type.
				</p>
<p>
					For example, &lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;PQ&apos;/&gt;&lt;/object&gt; is considered ordered. However the
					ordering of &lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;PQ&apos;/&gt;&lt;/object&gt;s is only partial; a total order is only
					defined among comparable quantities (quantities of the same physical
					dimension).  While &lt;object name=&apos;itemName&apos;&gt;&lt;param name=&apos;item&apos; value=&apos;datatype&apos;/&gt;&lt;/object&gt;s between 2 and 4 meter exists, there is no
					&lt;object name=&apos;itemName&apos;&gt;&lt;param name=&apos;item&apos; value=&apos;datatype&apos;/&gt;&lt;/object&gt; between 2 meters and 4 seconds.
				</p>
]]></text>
               </annotation>
               <annotation annotationType="CONSTRAINT">
                  <text><![CDATA[
<p>
                     &lt;param name=&apos;item&apos; value=&apos;datatype&apos;/&gt;
                  </p>
]]></text>
               </annotation>
            </documentation>
         </datatype>
      </datatypeEntry>
      <datatypeEntry name="LIST">
         <datatype isAbstract="false" name="LIST" businessName="Sequence" visibility="public" superType="ANY" isMerged="false">
            <documentation>
               <businessName>Sequence</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
A value that contains other discrete (but not necessarily distinct) values in a defined sequence. 
    ]]></text>
               </annotation>
               <annotation annotationType="DESIGN_COMMENTS">
                  <text><![CDATA[
<p>
A sequence may contain NULL values as items.
    </p>
]]></text>
               </annotation>
            </documentation>
         </datatype>
      </datatypeEntry>
      <datatypeEntry name="URL">
         <datatype isAbstract="false" name="URL" businessName="UniversalResourceLocator" visibility="protected" superType="ANY" isMerged="false">
            <documentation>
               <businessName>UniversalResourceLocator</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
<p></p>
]]></text>
               </annotation>
               <annotation annotationType="DESIGN_COMMENTS">
                  <text><![CDATA[
<p>
The Internet standard RFC 2396 [&lt;a href=&apos;http://www.ietf.org/rfc/rfc2396.txt&apos;/&gt;] defines a URI as
follows:
    </p>
<p>
                     &lt;p&gt;&lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;URL&apos;/&gt;&lt;/object&gt;s provides a framework for
new schemes to be established using protocols other than those defined
in this document.&lt;/p&gt;
                     &lt;p&gt;&lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;URL&apos;/&gt;&lt;/object&gt; scheme.&lt;/p&gt;
                     &lt;p/&gt;
                  </p>
]]></text>
               </annotation>
            </documentation>
         </datatype>
      </datatypeEntry>
      <datatypeEntry name="IVL">
         <datatype isAbstract="false" name="IVL" businessName="Interval" visibility="public" superType="SET" isMerged="false">
            <documentation>
               <businessName>Interval</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
A set of consecutive values of an ordered base data type.
    ]]></text>
               </annotation>
               <annotation annotationType="DESIGN_COMMENTS">
                  <text><![CDATA[
<p>
Any ordered type can be the basis of an interval; it does not matter
whether the base type is discrete or continuous. If the base data type
is only partially ordered, all elements of the interval must be
elements of a totally ordered subset of the partially ordered data
type.
    </p>
<p>
For example, physical quantities are considered ordered. However the
ordering of physical quantities is only partial; a total order is only
defined among comparable quantities (quantities of the same physical
dimension.)  While intervals between 2 and 4 meter exists, there is no
interval between 2 meters and 4 seconds.
    </p>
<p>
Intervals are sets and have all the properties of sets. However, union
and differences of intervals may not be intervals any more, since the
elements of these union and difference sets might not be
contiguous. Intersections of intervals are always intervals.
    </p>
]]></text>
               </annotation>
            </documentation>
         </datatype>
      </datatypeEntry>
      <datatypeEntry name="PPD">
         <datatype isAbstract="false" name="PPD" businessName="ParametricProbabilityDistribution" visibility="public" superType="T" isMerged="false">
            <documentation>
               <businessName>ParametricProbabilityDistribution</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
A generic data type extension specifying uncertainty of quantitative
data using a distribution function and its parameters. Aside from the 
specific parameters of the distribution, a mean (expected value) and 
standard deviation is always given to help maintain a minimum layer
of interoperability if receiving applications cannot deal with a
certain probability distribution.
    ]]></text>
               </annotation>
               <annotation annotationType="DESIGN_COMMENTS">
                  <text><![CDATA[
<p>
For example, the most common college entrance exam in the United
States is the SAT, which is comprised of two parts: verbal and
math. Each part has a minimum score of 400 (no questions answered
correctly) and a perfect score of 800. In 1998, according to the
College Board, 1,172,779 college-bound seniors took the test. The mean
score for the math portion of the test was 512, and the standard
deviation 112. These parameter values (512, 112), tagged as the normal
distribution parameters, paint a pretty good picture of test score
distribution. In most cases, there is no need to specify all
1-million+ points of data when just 2 parameters will do!
    </p>
<p></p>
<p>
Note that the normal distribution is only one of several distributions
defined for HL7.
    </p>
<p>Since a &lt;object name=&apos;itemName&apos;&gt;&lt;param name=&apos;item&apos; value=&apos;datatype&apos;/&gt;&lt;/object&gt; specializes its parameter type T, a simple T value is
the mean (expected value or first moment) of the probability
distribution. Applications that cannot deal with distributions will
take the simple T value neglecting the uncertainty. That simple value
of type T is also used to standardize the data for computing the
distribution.
    </p>
<p>
Probability distributions are defined over integer or real numbers and
normalized to a certain reference point (typically zero) and reference
unit (e.g., standard deviation = 1). When other quantities defined in
this specification are used as base types, the mean and the standard
deviation are used to scale the probability distribution. For example,
if a &lt;object name=&apos;itemName&apos;&gt;&lt;param name=&apos;item&apos; value=&apos;datatype&apos;/&gt;&lt;/object&gt; of PQ for a length is given with mean 20 ft
and a standard deviation of 2 in, the normalized distribution function
&lt;var&gt;f&lt;/var&gt;(&lt;var&gt;x&lt;/var&gt;) that maps a real number &lt;var&gt;x&lt;/var&gt;
to a probability density would be translated to
&lt;var&gt;f&lt;/var&gt;&#8242;(&lt;var&gt;x&lt;/var&gt;&#8242;) that maps a length
&lt;var&gt;x&lt;/var&gt;&#8242; to a probability density as
&lt;var&gt;f&lt;/var&gt;&#8242;(&lt;var&gt;x&lt;/var&gt;&#8242;) =
&lt;var&gt;f&lt;/var&gt;((&lt;var&gt;x&lt;/var&gt;&#8242; - &#956; ) / &#963;).
    </p>
<p>
Where applicable, the &lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;PPD&apos;/&gt;&lt;/object&gt; specification conforms to
the ISO &lt;b&gt;Guide to the Expression of Uncertainty in
Measurement&lt;/b&gt; (GUM) as reflected by NIST publication 1297
&lt;b&gt;Guidelines for Evaluating and Expressing the Uncertainty of NIST
Measurement Results&lt;/b&gt;. The &lt;object name=&apos;itemName&apos;&gt;&lt;param name=&apos;item&apos; value=&apos;datatype&apos;/&gt;&lt;/object&gt; specification does not
describe how uncertainty is to be evaluated but only how it is
expressed. The concept of &quot;standard uncertainty&quot; as set forth by the
ISO GUM corresponds to the &quot;standard deviation&quot; property of the &lt;object name=&apos;itemName&apos;&gt;&lt;param name=&apos;item&apos; value=&apos;datatype&apos;/&gt;&lt;/object&gt;.
    </p>
]]></text>
               </annotation>
            </documentation>
         </datatype>
      </datatypeEntry>
      <datatypeEntry name="BL">
         <datatype isAbstract="false" name="BL" businessName="Boolean" visibility="public" superType="ANY" isMerged="false">
            <documentation>
               <businessName>Boolean</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
<p>true</p>
<p>false</p>
]]></text>
               </annotation>
               <annotation annotationType="DESIGN_COMMENTS">
                  <text><![CDATA[
<p>
With any data value potentially being NULL, the two-valued logic is
effectively extended to a three-valued logic as shown in the following
truth tables:
    </p>
<p>
                     &lt;caption&gt;Truth Table: NOT&lt;/caption&gt;
                     &lt;col width=&apos;10&apos; span=&apos;1&apos;/&gt;
                     &lt;col width=&apos;10&apos; span=&apos;1&apos;/&gt;
                     &lt;thead&gt;&lt;tr&gt;&lt;th&gt;NOT&lt;/th&gt;
                           &lt;th&gt;&#160;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;
                     &lt;tbody&gt;&lt;tr&gt;&lt;th&gt;true&lt;/th&gt;
                           &lt;td&gt;false&lt;/td&gt;&lt;/tr&gt;
                        &lt;tr&gt;&lt;th&gt;false&lt;/th&gt;
                           &lt;td&gt;true&lt;/td&gt;&lt;/tr&gt;
                        &lt;tr&gt;&lt;th&gt;NULL&lt;/th&gt;
                           &lt;td&gt;NULL&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;
                  </p>
<p>
                     &lt;caption&gt;Truth Table: AND&lt;/caption&gt;
                     &lt;thead&gt;&lt;tr&gt;&lt;th&gt;AND&lt;/th&gt;
                           &lt;th&gt;true&lt;/th&gt;
                           &lt;th&gt;false&lt;/th&gt;
                           &lt;th&gt;NULL&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;
                     &lt;tbody&gt;&lt;tr&gt;&lt;th&gt;true&lt;/th&gt;
                           &lt;td&gt;true&lt;/td&gt;
                           &lt;td&gt;false&lt;/td&gt;
                           &lt;td&gt;NULL&lt;/td&gt;&lt;/tr&gt;
                        &lt;tr&gt;&lt;th&gt;false&lt;/th&gt;
                           &lt;td&gt;false&lt;/td&gt;
                           &lt;td&gt;false&lt;/td&gt;
                           &lt;td&gt;false&lt;/td&gt;&lt;/tr&gt;
                        &lt;tr&gt;&lt;th&gt;NULL&lt;/th&gt;
                           &lt;td&gt;NULL&lt;/td&gt;
                           &lt;td&gt;false&lt;/td&gt;
                           &lt;td&gt;NULL&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;
                  </p>
<p>
                     &lt;caption&gt;Truth Table: OR&lt;/caption&gt;
                     &lt;thead&gt;&lt;tr&gt;&lt;th&gt;OR&lt;/th&gt;
                           &lt;th&gt;true&lt;/th&gt;
                           &lt;th&gt;false&lt;/th&gt;
                           &lt;th&gt;NULL&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;
                     &lt;tbody&gt;&lt;tr&gt;&lt;th&gt;true&lt;/th&gt;
                           &lt;td&gt;true&lt;/td&gt;
                           &lt;td&gt;true&lt;/td&gt;
                           &lt;td&gt;true&lt;/td&gt;&lt;/tr&gt;
                        &lt;tr&gt;&lt;th&gt;false&lt;/th&gt;
                           &lt;td&gt;true&lt;/td&gt;
                           &lt;td&gt;false&lt;/td&gt;
                           &lt;td&gt;NULL&lt;/td&gt;&lt;/tr&gt;
                        &lt;tr&gt;&lt;th&gt;NULL&lt;/th&gt;
                           &lt;td&gt;true&lt;/td&gt;
                           &lt;td&gt;NULL&lt;/td&gt;
                           &lt;td&gt;NULL&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;
                  </p>
<p>
Where a boolean operation is performed upon 2 data types with different
nullFlavors, the nullFlavor of the result is the first common ancestor
of the 2 different nullFlavors, though conformant applications may also
create a result that is any common ancestor
    </p>
]]></text>
               </annotation>
            </documentation>
         </datatype>
      </datatypeEntry>
      <datatypeEntry name="TYPE">
         <datatype isAbstract="false" name="TYPE" businessName="DataType" visibility="private" superType="ANY" isMerged="false">
            <documentation>
               <businessName>DataType</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
A meta-type declared in order to allow the formal definitions to speak
about the data type of a value. Any data type defined in this
specification is a value of the type DataType.
        ]]></text>
               </annotation>
            </documentation>
         </datatype>
      </datatypeEntry>
      <datatypeEntry name="II">
         <datatype isAbstract="false" name="II" businessName="InstanceIdentifier" visibility="public" superType="ANY" isMerged="false">
            <documentation>
               <businessName>InstanceIdentifier</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
An identifier that uniquely identifies a thing or object. Examples
are object identifier for HL7 RIM objects, medical record number,
order id, service catalog item id, Vehicle Identification Number
(VIN), etc. Instance identifiers are defined based on ISO object
identifiers.
    ]]></text>
               </annotation>
            </documentation>
         </datatype>
      </datatypeEntry>
      <datatypeEntry name="SC">
         <datatype isAbstract="false" name="SC" businessName="CharacterStringWithCode" visibility="public" superType="ST" isMerged="false">
            <documentation>
               <businessName>CharacterStringWithCode</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
A character string that optionally may have a code attached. The text
must always be present if a code is present.  The code is often a
local code.
    ]]></text>
               </annotation>
               <annotation annotationType="DESIGN_COMMENTS">
                  <text><![CDATA[
<p>
This data type is used in cases where coding is exceptional (e.g.,
user text messages are essentially text messages, and a printable
message is the important content. Yet, sometimes messages come from a
catalog of canned messages, which the SC allows to reference.  
    </p>
]]></text>
               </annotation>
               <annotation annotationType="CONSTRAINT">
                  <text><![CDATA[
Any non-null SC value MAY have a code, however, a code MUST NOT be
given without the text.
      ]]></text>
               </annotation>
            </documentation>
         </datatype>
      </datatypeEntry>
      <datatypeEntry name="REAL">
         <datatype isAbstract="false" name="REAL" businessName="RealNumber" visibility="public" superType="QTY" isMerged="false">
            <documentation>
               <businessName>RealNumber</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
Fractional numbers. Typically used whenever quantities are measured,
estimated, or computed from other real numbers.  The typical
representation is decimal, where the number of significant decimal
digits is known as the precision.
    ]]></text>
               </annotation>
               <annotation annotationType="DESIGN_COMMENTS">
                  <text><![CDATA[
<p>
The term &quot;Real number&quot; in this specification is used to mean that
fractional values are covered without necessarily implying the full
set of the mathematical real numbers that would include irrational
numbers such as &#961;, Euler&apos;s number, etc.&lt;object name=&apos;footnote&apos;&gt;The term &quot;Real&quot; for a fractional number data type originates and is
well established in the Algol, Pascal tradition of programming
languages.&lt;/object&gt;
				              </p>
<p>
This specification offers two choices for a number data type. The
choice is made as follows: Any number attribute is a real if it is not
known for sure that it is an integer. A number is an integer if it is
&lt;b&gt;always&lt;/b&gt; counted, typically representing an ordinal
number. If there are conceivable use cases where such a number would
be estimated or averaged, it is not always an integer and thus should
use the Real data type.
    </p>
<p>
The algebraic operations are specified here as characterizing
operations in the sense of ISO 11404, and because these operations are
needed in other parts of this specification.
    </p>
<p>
Unlike the integer numbers, the real numbers semantics are not
inductively constructed but only intuitively described by their axioms
of their algebraic properties. The completeness axioms are
intentionally left out so as to make no statement about irrational
numbers.
    </p>
]]></text>
               </annotation>
            </documentation>
         </datatype>
      </datatypeEntry>
      <datatypeEntry name="GLIST">
         <datatype isAbstract="false" name="GLIST" businessName="GeneratedSequence" visibility="public" superType="LIST" isMerged="false">
            <documentation>
               <businessName>GeneratedSequence</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
A periodic or monotone sequence of values generated from a few
parameters, rather than being enumerated. Used to specify regular
sampling points for biosignals.
    ]]></text>
               </annotation>
               <annotation annotationType="DESIGN_COMMENTS">
                  <text><![CDATA[
<p>
The item at a certain index in the list is calculated by performing an
integer division on the index (&lt;var&gt;i&lt;/var&gt;) with the
&lt;object name=&apos;propertyRef&apos;&gt;&lt;param name=&apos;propertyName&apos; value=&apos;denominator&apos;/&gt;
                        &lt;param name=&apos;datatypeName&apos; value=&apos;GLIST&apos;/&gt;&lt;/object&gt; (&lt;var&gt;d&lt;/var&gt;) and then take that
value&apos;s remainder with the &lt;object name=&apos;propertyRef&apos;&gt;&lt;param name=&apos;propertyName&apos; value=&apos;period&apos;/&gt;
                        &lt;param name=&apos;datatypeName&apos; value=&apos;GLIST&apos;/&gt;&lt;/object&gt;
(&lt;var&gt;p&lt;/var&gt;). Multiply this value with the
&lt;object name=&apos;propertyRef&apos;&gt;&lt;param name=&apos;propertyName&apos; value=&apos;increment&apos;/&gt;
                        &lt;param name=&apos;datatypeName&apos; value=&apos;GLIST&apos;/&gt;&lt;/object&gt; (&lt;var&gt;&#916;x&lt;/var&gt;) and add to the
&lt;object name=&apos;propertyRef&apos;&gt;&lt;param name=&apos;propertyName&apos; value=&apos;head&apos;/&gt;
                        &lt;param name=&apos;datatypeName&apos; value=&apos;GLIST&apos;/&gt;&lt;/object&gt; (&lt;var&gt;x&lt;/var&gt;
					                &lt;sub&gt;0&lt;/sub&gt;.)
    </p>
<p>
                     &lt;p&gt;&lt;var&gt;x&lt;/var&gt;
						                  &lt;sub&gt;&lt;var&gt;i&lt;/var&gt;&lt;/sub&gt;
=
&lt;var&gt;x&lt;/var&gt;
						                  &lt;sub&gt;0&lt;/sub&gt;
+
&lt;var&gt;&#916;x&lt;/var&gt;
&#215;
(&lt;var&gt;i&lt;/var&gt;/&lt;var&gt;d&lt;/var&gt;)
mod &lt;var&gt;p&lt;/var&gt;&lt;/p&gt;
                  </p>
<p>
                     &lt;caption&gt;Examples for Generated Sequences&lt;/caption&gt;
                     &lt;thead&gt;&lt;tr&gt;&lt;th&gt;head&lt;/th&gt;
                           &lt;th&gt;increment&lt;/th&gt;
                           &lt;th&gt;denominator&lt;/th&gt;
                           &lt;th&gt;period&lt;/th&gt;
                           &lt;th&gt;meaning&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;
                     &lt;tbody&gt;&lt;tr&gt;&lt;td&gt;0&lt;/td&gt;
                           &lt;td&gt;1&lt;/td&gt;
                           &lt;td&gt;1&lt;/td&gt;
                           &lt;td&gt;&#8734;&lt;/td&gt;
                           &lt;td&gt;The identity-sequence where each item is equal to its index.&lt;/td&gt;&lt;/tr&gt;
                        &lt;tr&gt;&lt;td&gt;198706052000&lt;/td&gt;
                           &lt;td&gt;2 hour&lt;/td&gt;
                           &lt;td&gt;1&lt;/td&gt;
                           &lt;td&gt;&#8734;&lt;/td&gt;
                           &lt;td&gt;Sequence starting on June 5, 1987 at 7 PM and
          incrementing every two hours: 9 PM, 11 PM, 1 AM (June 6), 3
          AM, 5 AM, and so on.&lt;/td&gt;&lt;/tr&gt;
                        &lt;tr&gt;&lt;td&gt;0 V&lt;/td&gt;
                           &lt;td&gt;1 mV&lt;/td&gt;
                           &lt;td&gt;1&lt;/td&gt;
                           &lt;td&gt;100&lt;/td&gt;
                           &lt;td&gt;The x-wave of a digital oscillograph scanning between
          0 and 100 mV in 100 steps of 1 mV. The frequency is unknown
          from these data as we do not know how much time elapses
          between each step of the index.&lt;/td&gt;&lt;/tr&gt;
                        &lt;tr&gt;&lt;td&gt;2002072920300&lt;/td&gt;
                           &lt;td&gt;100
          us&lt;/td&gt;
                           &lt;td&gt;1&lt;/td&gt;
                           &lt;td&gt;&#8734;&lt;/td&gt;
                           &lt;td&gt;A timebase from June 29,
          2002 at 8:30 PM with 100 us between each steps of the
          index. If combined with the previous generator as a second
          sampling dimension this would now describe our digital
          oscilloscope&apos;s x-timebase as 1 mV per 100 us. At 100 steps
          per period, the period is 10 ms, which is equal to a
          frequency of 100 Hz.&lt;/td&gt;&lt;/tr&gt;
                        &lt;tr&gt;&lt;td&gt;0 V&lt;/td&gt;
                           &lt;td&gt;1 mV&lt;/td&gt;
                           &lt;td&gt;100&lt;/td&gt;
                           &lt;td&gt;100&lt;/td&gt;
                           &lt;td&gt;Combining this generator to the previous two generators
          could describe a three-dimensional sampling space with two
          voltages and time. This generator also steps at 1 mV and has
          100 steps per period, however, it only steps every 100 index
          increments, so, the first voltage generator makes one full
          cycle before this generator is incremented. One can think of
          the two voltages as &quot;rows&quot; and &quot;columns&quot; of a &quot;sampling
          frame&quot;. With the previous generator as the timebase, this
          results in a scan of sampling frames of 100 mV &#215; 100
          mV with a framerate of 1 Hz.&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;
                  </p>
]]></text>
               </annotation>
            </documentation>
         </datatype>
      </datatypeEntry>
      <datatypeEntry name="CV">
         <datatype isAbstract="false" name="CV" businessName="CodedValue" visibility="protected" superType="CE" isMerged="false">
            <documentation>
               <businessName>CodedValue</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
Coded data, specifying only a code, code system, and optionally
display name and original text. Used only as the data type for other
data types' properties.
    ]]></text>
               </annotation>
               <annotation annotationType="DESIGN_COMMENTS">
                  <text><![CDATA[
<p>
This type is used when any reasonable use case will require only a
single code value to be sent. Thus, it should not be used in
circumstances where multiple alternative codes for a given value are
desired. This type may be used with both the CNE (&lt;b&gt;coded,
non-extensible&lt;/b&gt;) and the CWE (&lt;b&gt;coded, with
extensibility&lt;/b&gt;) domain qualifiers.
    </p>
]]></text>
               </annotation>
            </documentation>
         </datatype>
      </datatypeEntry>
      <datatypeEntry name="PQ.TIME">
         <datatype isAbstract="false" name="PQ.TIME" businessName="LengthOfTime" visibility="public" superType="PQ" isMerged="false">
            <documentation>
               <businessName>LengthOfTime</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
<p>
                     &lt;param name=&apos;item&apos; value=&apos;datatype&apos;/&gt;
                  </p>
<p>
                     &lt;param name=&apos;datatypeName&apos; value=&apos;PQ&apos;/&gt;
                  </p>
]]></text>
               </annotation>
               <annotation annotationType="DESIGN_COMMENTS">
                  <text><![CDATA[
<p>
						The units SHALL be some UCUM code that refers to a measurement of time. Translations are not allowed.
					</p>
]]></text>
               </annotation>
               <annotation annotationType="CONSTRAINT">
                  <text><![CDATA[
]]></text>
               </annotation>
            </documentation>
         </datatype>
      </datatypeEntry>
      <datatypeEntry name="BAG">
         <datatype isAbstract="false" name="BAG" businessName="Bag" visibility="public" superType="ANY" isMerged="false">
            <documentation>
               <businessName>Bag</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
An unordered collection of values, where each value can be contained
more than once in the collection.
    ]]></text>
               </annotation>
            </documentation>
         </datatype>
      </datatypeEntry>
      <datatypeEntry name="CLCY">
         <datatype isAbstract="false" name="CLCY" businessName="CalendarCycle" visibility="private" superType="ANY" isMerged="false">
            <documentation>
               <businessName>CalendarCycle</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[    
A calendar cycle defines one group of decimal digits in the calendar
expression. Examples for calendar cycles are year, month, day, hour,
minute, second, and week.
      ]]></text>
               </annotation>
               <annotation annotationType="DESIGN_COMMENTS">
                  <text><![CDATA[
<p>
A calendar cycle has a name and two codes, a one-letter code and a
two-letter code. The property &lt;b&gt;ndigits&lt;/b&gt; is the number of
decimal digits occupied in the calendar expression. The property
&lt;b&gt;start&lt;/b&gt; specifies where counting starts (i.e., at 0 or 1.)
The &lt;b&gt;next&lt;/b&gt; property is the next lower cycle in the order of
the calendar expression. The max(&lt;b&gt;t&lt;/b&gt;) property is the
maximum number of cycles at time &lt;b&gt;t&lt;/b&gt; (max depends on the
time &lt;b&gt;t&lt;/b&gt; to account for leap years and leap seconds.)  The
property value(&lt;b&gt;t&lt;/b&gt;) is the integer number of cycles shown
in the calendar expression of time &lt;b&gt;t&lt;/b&gt;. The property
sum(&lt;b&gt;t&lt;/b&gt;, &lt;b&gt;n&lt;/b&gt;) is the sum of &lt;b&gt;n&lt;/b&gt;
calendar cycles added to the time &lt;b&gt;t&lt;/b&gt;.
      </p>
]]></text>
               </annotation>
            </documentation>
         </datatype>
      </datatypeEntry>
      <datatypeEntry name="CS">
         <datatype isAbstract="false" name="CS" businessName="CodedSimpleValue" visibility="public" superType="CV" isMerged="false">
            <documentation>
               <businessName>CodedSimpleValue</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
XCoded data in its simplest form, where only the code is not predetermined.
The code system and code system version are fixed by the context in which
the CS value occurs. CS is used for coded attributes that have a single
HL7-defined value set.
    ]]></text>
               </annotation>
               <annotation annotationType="DESIGN_COMMENTS">
                  <text><![CDATA[
<p>
					                &lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;CS&apos;/&gt;&lt;/object&gt; can only be used in either of the following
          cases:
    </p>
<p>
                     &lt;li&gt;&lt;p&gt;&lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;CS&apos;/&gt;&lt;/object&gt; restriction.&lt;/p&gt;&lt;/li&gt;
                     &lt;li&gt;&lt;p&gt;for a property in this specification that is assigned to a single code
system defined either in this specification or defined outside HL7 by a body
that has authority over the concept and the maintenance of that code system.&lt;/p&gt;&lt;/li&gt;
                  </p>
<p>
For example, since the &lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;ED&apos;/&gt;&lt;/object&gt; type subscribes to the MIME
design, it trusts IETF to manage the media type. This includes that this
specification subscribes to the extension mechanism built into the MIME media
type code (e.g., &quot;application/x-myapp&quot;).
    </p>
<p>
For &lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;CS&apos;/&gt;&lt;/object&gt; values, the designation of the domain qualifier
will always be CNE (&lt;b&gt;coded, non-extensible&lt;/b&gt;) and the
context will determine which HL7 values to use. &lt;object name=&apos;footnote&apos;&gt;This is not withstanding the fact that an external referenced domain,
such as the IETF MIME media type may include an extension
mechanism. These extended MIME type codes would not be considered
&quot;extensions&quot; in the sense of violating the CNE provision. The CNE
provision is only violated if an attempt is made in using a different
code system (by means of the CD.codeSystem property), which is not
possible with the  data type.&lt;/object&gt;
				              </p>
]]></text>
               </annotation>
            </documentation>
         </datatype>
      </datatypeEntry>
      <datatypeEntry name="ADXP">
         <datatype isAbstract="false" name="ADXP" businessName="AddressPart" visibility="protected" superType="SC" isMerged="false">
            <documentation>
               <businessName>AddressPart</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
A character string that may have a type-tag signifying its role in the
address. Typical parts that exist in about every address are street,
house number, or post box, postal code, city, country but other roles
may be defined regionally, nationally, or on an enterprise level
(e.g. in military addresses). Addresses are usually broken up into
lines, which are indicated by special line-breaking delimiter elements
(e.g., DEL).
    ]]></text>
               </annotation>
            </documentation>
         </datatype>
      </datatypeEntry>
      <datatypeEntry name="PQR">
         <datatype isAbstract="false" name="PQR" businessName="PhysicalQuantityRepresentation" visibility="protected" superType="CV" isMerged="false">
            <documentation>
               <businessName>PhysicalQuantityRepresentation</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
An extension of the coded value data type representating a physical
quantity using a unit from any code system. Used to show alternative
representation for a physical quantity.
    ]]></text>
               </annotation>
            </documentation>
         </datatype>
      </datatypeEntry>
      <datatypeEntry name="EIVL">
         <datatype isAbstract="false" name="EIVL" businessName="EventRelatedPeriodicInterval" visibility="public" superType="SET" isMerged="false">
            <documentation>
               <businessName>EventRelatedPeriodicInterval</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
Specifies a periodic interval of time where the recurrence is based on
activities of daily living or other important events that are
time-related but not fully determined by time.
    ]]></text>
               </annotation>
               <annotation annotationType="DESIGN_COMMENTS">
                  <text><![CDATA[
<p>
For example, &quot;one hour after breakfast&quot; specifies the beginning of the
interval at one hour after breakfast is finished. Breakfast is assumed
to occur before lunch but is not determined to occur at any specific
time.
    </p>
<p>
An event-related periodic interval of time is a set of time, that is,
one can test whether a particular time or time interval is an element
of the set. Whether an event-related periodic interval of time
contains a given interval of time is decided using a relation event
&#967; time referred to as EVENT(event,
time). The property occurrenceAt(t) is the
occurrence interval that would exist if the event occurred at time
t.
      
invariant(EIVL&lt;T&gt; x, T eventTime, IVL&lt;T&gt; v)
     where v.equal(x.occurrenceAt(eventTime)) {
  v.low.equal(eventTime.plus(x.offset.low));
  v.high.equal(eventTime.plus(x.offset.high));
  v.lowClosed.equal(x.offset.lowClosed);
  v.highClosed.equal(x.offset.highClosed);
};
      
Thus, an event related interval of time contains a point in time
t if there is an event time e with an
occurrence interval v such that v contains
t.
      
invariant(EIVL&lt;T&gt; x, T y) {
  x.contains(y).equal(exists(T e, IVL&lt;T&gt; v)
                           where EVENT(x.event, y)
                            .and(v.resolvedAt(y)) {
                         v.contains(y);
                       });
};
      </p>
]]></text>
               </annotation>
            </documentation>
         </datatype>
      </datatypeEntry>
      <datatypeEntry name="MO">
         <datatype isAbstract="false" name="MO" businessName="MonetaryAmount" visibility="public" superType="QTY" isMerged="false">
            <documentation>
               <businessName>MonetaryAmount</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
A monetary amount is a quantity expressing the amount of money in some
currency. Currencies are the units in which monetary amounts are
denominated in different economic regions. While the monetary amount
is a single kind of quantity (money) the exchange rates between the
different units are variable.  This is the principle difference
between physical quantity and monetary amounts, and the reason why
currency units are not physical units.
    ]]></text>
               </annotation>
            </documentation>
         </datatype>
      </datatypeEntry>
      <datatypeEntry name="GTS">
         <datatype isAbstract="false" name="GTS" businessName="GeneralTimingSpecification" visibility="public" superType="SET" isMerged="false">
            <documentation>
               <businessName>GeneralTimingSpecification</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
A set of points in time, specifying the timing of events and actions
and the cyclical validity-patterns that may exist for certain kinds of
information, such as phone numbers (evening, daytime), addresses (so
called "snowbirds," residing closer to the equator during winter and
farther from the equator during summer) and office hours.
    ]]></text>
               </annotation>
               <annotation annotationType="DESIGN_COMMENTS">
                  <text><![CDATA[
<p>
The GTS data type has the following aspects:
    </p>
<p>
                     &lt;li&gt;&lt;p&gt;&lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;SET&apos;/&gt;&lt;/object&gt;
&lt;&lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;TS&apos;/&gt;&lt;/object&gt;&gt;). From this aspect GTS answers
whether any given point in time falls in the schedule described by the
GTS value.&lt;/p&gt;&lt;/li&gt;
                     &lt;li&gt;&lt;p&gt;GTS as the combination of multiple periodic intervals of time. This
aspect describes how both simple and complex repeat-patterns are
specified with the GTS.&lt;/p&gt;&lt;/li&gt;
                     &lt;li&gt;&lt;p&gt;&lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;LIST&apos;/&gt;&lt;/object&gt;&lt;&lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;IVL&apos;/&gt;&lt;/object&gt;
&lt;&lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;TS&apos;/&gt;&lt;/object&gt;&gt;&gt;).
From this aspect, GTS can generate all occurrence intervals of an event or
action, or all validity periods for a fact.&lt;/p&gt;&lt;/li&gt;
                     &lt;li&gt;&lt;p&gt;GTS as an expression-syntax defined for a calendar. This aspect is the
GTS literal form.&lt;/p&gt;&lt;/li&gt;
                  </p>
<p>
In all cases the GTS is defined as a set of point in time (&lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;SET&apos;/&gt;&lt;/object&gt;
&lt;&lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;TS&apos;/&gt;&lt;/object&gt;&gt;). Using the set operations,
union, intersection and difference, more complex sets of time can be
constructed from simpler ones. Ultimately the building blocks from
which all GTS values are constructed are interval, periodic interval,
and event-related periodic interval. The construction of the GTS can
be specified in the literal form. No special data type structure is
defined that would generate a combination of simpler time-sets from a
given GTS value. While any implementation would have to contain such a
structured representation, it is not needed in order to exchange GTS
values given the literal form.&lt;object name=&apos;footnote&apos;&gt;The GTS is an example of a data type that is only defined
algebraically without giving any definition of a data structure that
might implement the behavior of such a data type. The algebraic
definition looks extremely simple, so that one might assume it is
incomplete. Since at this point we are relying entirely on the literal
form to represent GTS values, all the definition of data structur&lt;/object&gt;
				              </p>
<p>
The GTS data type is defined as using intervals, periodic intervals,
and event-related periodic intervals. Intervals of time have been
defined above
    </p>
<p>
A convex hull is the least interval that is a superset of all
occurrence intervals. As noted in , all
totally ordered sets have a convex hull. Because a GTS is a 
&lt;&gt; and because a 
&lt;&gt; is a totally ordered set, all
GTS values have a convex hull.
      
The convex hull of a GTS can less formally be called &quot;outer bound
interval&quot;. Thus, the convex hull of a GTS describes the absolute
beginning and end of the repeating schedule. For infinite repetitions
(e.g., a simple periodic interval) the convex hull has infinite
bounds.
      
						
						Convex Hull of a Schedule
					</p>
<p>
A  value is a generator of a sequence of time
intervals during which an event or activity occurs, or during which a
state is effective.
      
The nextTo-property maps to every point in
time t the greatest continuous subset (an &quot;occurrence
interval&quot;) v of the  value
S, where v is the interval closest to
t that begins later than t or that contains
t.
      
invariant(GTS S, TS t, IVL&lt;TS&gt; v) {
  v.equal(S.nextTo(t)).equal(
         S.contains(o)
    .and(forall(IVL&lt;TS&gt; u) where x.contains(u) {
           u.contains(v).implies(u.equal(v)); })
    .and(    v.contains(t)
         .or(forall(TS i) where t.lessOrEqual(i)
                           .and(i.lessThan(v.low)) {
               S.conatins(i).not; })));
};
      
The nextAfter-property maps to every point
in time t the greatest continuous subset (an &quot;occurrence
interval&quot;) v of the  value
S, where v is the interval closest to
t that begins later than t.
      
invariant(GTS S, TS t) where {
  S.contains(t).not
     .implies(S.nextAfter(t).equal(S.nextTo(t)));
  S.contains(t)
     .implies(S.nextAfter(t).equal(
            S.except(nextTo(t)).nextTo(t)));
};
      
A  value can be converted into a generic Sequence
of time intervals (&lt;&gt;)
of occurrence intervals.
      
invariant(GTS x) where x.isEmpty { ((LIST&lt;IVL&lt;TS&gt;&gt;)x).isEmpty; };

invariant(GTS x, IVL&lt;TS&gt; first)
    where x.notEmpty
     .and(x.hull.low.nonNull)
     .and(first.equal(x.nextTo(x.hull.low))
{
  ((LIST&lt;IVL&lt;TS&gt;&gt;)x).head.equal(first);
  ((LIST&lt;IVL&lt;TS&gt;&gt;)x).tail.equal(
             (LIST&lt;IVL&lt;TS&gt;&gt;)x.except(first));
};
      </p>
<p>
						
						Interleaving Schedules and Periodic Hull
					
For two  values A and B we
say that A interleaves B if their occurrence
intervals interleave on the time line. This concept is visualized in
Figure 15.
      
For the  values A and B
to interleave the occurrence intervals of both groups can be arranged
in pairs of corresponding occurrence intervals. It must further hold
that for all corresponding occurrence intervals a
&#8838; A and b &#8838; B,
a starts before b starts (or at the same
time) and b ends after a ends (or at the
same time).
      
The interleaves-relation holds when two schedules have the same
average frequency, and when the second schedule never &quot;outpaces&quot; the
first schedule. That is, no occurrence interval in the second schedule
may start before its corresponding occurrence interval in the first
schedule.
      
With two interleaving  values one can derive a
periodic hull such that the occurrence intervals of the periodic hull
is the convex hull of the corresponding occurrence intervals.
      
The periodic hull is important to construct two schedules by combining
 expressions. For example, to construct the periodic
interval from Memorial Day to Labor Day every year, one first needs to
set up the schedules M for Memorial Day (the last Monday
in May) and L for Labor Day (the first Monday in
September) and then combine these two schedules using the periodic
hull of M and L.
      
invariant(GTS A, B) where x.nonNull.and(y.nonNull) {
  A.interleaves(B).equal(
    forall(IVL&lt;TS&gt; a, b, c; TS t)
        where a.equal(A.nextTo(t))
         .and(b.equal(B.nextTo(a.low)))
         .and(c.equal(A.nextTo(b.high))) {
      b.equal(B.nextTo(a.high));
      a.low.lessOrEqual(b.low);
      c.equal(A.nextTo(b.high));
      c.equal(a).or(c.equal(A.nextAfter(a.high)));
    });
};
      
For two  values A and B
where A interleaves B, a periodic hull is
defined as the pair wise convex hull of the corresponding occurrence
intervals of A and B.
      
invariant(GTS A, B, C) where A.interleaves(B) {
  A.periodicHull(B).equal(C).equal(
    forall(IVL&lt;TS&gt; a, b; TS t)
        where a.equal(A.nextTo(t))
         .and(b.equal(B.nextTo(a.low))) {
      C.contains(c).equal(c.equal(a.hull(b)));
    });
};
      
The interleaves-relation is reflexive, asymmetric, and
intransitive. The periodic hull operation is non-commutative and
non-associative.
The interleaves property may appear overly constrained. However, these
constraints are reasonable for the use case for which the interleaves
and periodic hull properties are defined. To safely and predictably
combine two schedules one would want to know which of the operands
sets the start points and which sets the endpoints of the periodic
hull&apos;s occurrence intervals.
          
					</p>
]]></text>
               </annotation>
            </documentation>
         </datatype>
      </datatypeEntry>
      <datatypeEntry name="SLIST">
         <datatype isAbstract="false" name="SLIST" businessName="SampledSequence" visibility="public" superType="LIST" isMerged="false">
            <documentation>
               <businessName>SampledSequence</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
A sequence of sampled values scaled and translated from a list of
integer values.  Used to specify sampled biosignals.
    ]]></text>
               </annotation>
               <annotation annotationType="DESIGN_COMMENTS">
                  <text><![CDATA[
<p>
The item at a certain index (&lt;var&gt;i&lt;/var&gt;) in the list is calculated
by multiplying the item at the same index in the
&lt;object name=&apos;propertyRef&apos;&gt;&lt;param name=&apos;propertyName&apos; value=&apos;digits&apos;/&gt;
                        &lt;param name=&apos;datatypeName&apos; value=&apos;SLIST&apos;/&gt;&lt;/object&gt; sequence
(&lt;var&gt;d&lt;/var&gt;
					                &lt;sub&gt;&lt;var&gt;i&lt;/var&gt;&lt;/sub&gt;) with the &lt;object name=&apos;propertyRef&apos;&gt;&lt;param name=&apos;propertyName&apos; value=&apos;scale&apos;/&gt;
                        &lt;param name=&apos;datatypeName&apos; value=&apos;SLIST&apos;/&gt;&lt;/object&gt; (&lt;var&gt;s&lt;/var&gt;)
          and then add that value to the &lt;object name=&apos;propertyRef&apos;&gt;&lt;param name=&apos;propertyName&apos; value=&apos;origin&apos;/&gt;
                        &lt;param name=&apos;datatypeName&apos; value=&apos;SLIST&apos;/&gt;&lt;/object&gt;
(&lt;var&gt;x&lt;/var&gt;
					                &lt;sub&gt;&lt;var&gt;o&lt;/var&gt;&lt;/sub&gt; ).
    </p>
<p>
                     &lt;p&gt;&lt;var&gt;x&lt;/var&gt;
						                  &lt;sub&gt;&lt;var&gt;i&lt;/var&gt;&lt;/sub&gt;
=
&lt;var&gt;x&lt;/var&gt;
						                  &lt;sub&gt;&lt;var&gt;o&lt;/var&gt;&lt;/sub&gt;
+
&lt;var&gt;s&lt;/var&gt;
&#215;
&lt;var&gt;d&lt;/var&gt;
						                  &lt;sub&gt;&lt;var&gt;i&lt;/var&gt;&lt;/sub&gt;&lt;/p&gt;
                  </p>
]]></text>
               </annotation>
            </documentation>
         </datatype>
      </datatypeEntry>
      <datatypeEntry name="AD">
         <datatype isAbstract="false" name="AD" businessName="PostalAddress" visibility="public" superType="LIST" isMerged="false">
            <documentation>
               <businessName>PostalAddress</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
Mailing and home or office addresses. A sequence of address parts,
such as street or post office Box, city, postal code, country, etc.
    ]]></text>
               </annotation>
               <annotation annotationType="DESIGN_COMMENTS">
                  <text><![CDATA[
<p>
The &lt;object name=&apos;itemName&apos;&gt;&lt;param name=&apos;item&apos; value=&apos;datatype&apos;/&gt;&lt;/object&gt; is primarily used to communicate data that will allow
printing mail labels, that will allow a person to physically visit
that address. The postal address data type is not supposed to be a
container for additional information that might be useful for finding
geographic locations (e.g., GPS coordinates) or for performing
epidemiological studies. Such additional information is captured by
other, more appropriate HL7 elements.
    </p>
<p>
Addresses are conceptualized as text with added logical mark-up. The
mark-up may break the address into lines and may describe in detail
the role of each address part if it is known. Address parts occur in
the address in the order in which they would be printed on a mailing
label. The approach is similar to HTML or XML markup of text (but it
is not technically limited to XML representations.)
    </p>
<p>
Addresses are essentially sequences of address parts, but add a &quot;use&quot;
code and a valid time range for information about if and when the
address can be used for a given purpose.
    </p>
]]></text>
               </annotation>
            </documentation>
         </datatype>
      </datatypeEntry>
      <datatypeEntry name="EN">
         <datatype isAbstract="false" name="EN" businessName="EntityName" visibility="public" superType="LIST" isMerged="false">
            <documentation>
               <businessName>EntityName</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
A name for a person, organization, place or thing. A sequence of name
parts, such as given name or family name, prefix, suffix, etc.
Examples for entity name values are "Jim Bob Walton, Jr.", "Health
Level Seven, Inc.", "Lake Tahoe", etc. An entity name may be as simple
as a character string or may consist of several entity name parts,
such as, "Jim", "Bob", "Walton", and "Jr.", "Health Level Seven" and
"Inc.", "Lake" and "Tahoe".
    ]]></text>
               </annotation>
               <annotation annotationType="DESIGN_COMMENTS">
                  <text><![CDATA[
<p>
Entity names are conceptualized as text with added logical mark-up.
Name parts occur in a natural order in which they would be displayed,
as opposed to in a order detemined by name part. The ordeing of the
name parts is significant a feature that replaces the need for a
separate &quot;display name&quot; property. Applications may change that
ordering of name parts to account for their user&apos;s customary ordering
of name parts. The approach is similar to HTML or XML markup of text
(but it is not technically limited to XML representations.)
    </p>
<p>
Entity names are essentially sequences of entity name parts, but add a
&quot;use&quot; code and a valid time range for information about when the name
was used and how to choose between multiple aliases that may be valid
at the same point in time.
    </p>
<p>
Three restrictions to Entity Name are defined in order to allow making
specific constraints for certain kinds of entities, trivial name
(&lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;TN&apos;/&gt;&lt;/object&gt;), person name (&lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;PN&apos;/&gt;&lt;/object&gt;), and
organization name (&lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;ON&apos;/&gt;&lt;/object&gt;).
    </p>
<p>
A very simple encoding of  &quot;Adam A. Everyman&quot; would be:
      

  Adam
  A.
  Everyman

					
None of the special qualifiers need to be mentioned if they are
unknown or irrelevant. The next example shows extensive use of
multiple given names, prefixes, suffixes, for academic degrees,
nobility titles, vorvoegsels (&quot;van&quot;), and professional
designations.
      

  Dr. phil. 
  Regina
  Johanna
  Maria
  Gr&#228;fin 
  Hochheim-Weilenfels
  NCFSA


The next example is an organization name, &quot;Health Level Seven, Inc.&quot;
in simple string form:
      
Health Level Seven, Inc.
					
and as a fully parsed name
      
Health Level Seven, Inc.

					
The following example shows a Japanese name in the three forms:
ideographic (Kanji), syllabic (Hiragana), and alphabetic (Romaji).
      

  &#26408;&#26449;
  &#36890;&#30007;


  &#12365;&#12416;&#12425;
  &#12415;&#12385;&#12362;


  KIMURA
  MICHIO

					</p>
]]></text>
               </annotation>
            </documentation>
         </datatype>
      </datatypeEntry>
      <datatypeEntry name="CE">
         <datatype isAbstract="false" name="CE" businessName="CodedWithEquivalents" visibility="public" superType="CD" isMerged="false">
            <documentation>
               <businessName>CodedWithEquivalents</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
Coded data that consists of a coded value (CV) and, optionally, coded
value(s) from other coding systems that identify the same
concept. Used when alternative codes may exist.
    ]]></text>
               </annotation>
               <annotation annotationType="DESIGN_COMMENTS">
                  <text><![CDATA[
<p>
The &lt;object name=&apos;itemName&apos;&gt;&lt;param name=&apos;item&apos; value=&apos;datatype&apos;/&gt;&lt;/object&gt; type is used when the use case indicates that alternative
codes may exist and where it is useful to communicate these. The
&lt;object name=&apos;itemName&apos;&gt;&lt;param name=&apos;item&apos; value=&apos;datatype&apos;/&gt;&lt;/object&gt; type provides for a primary code value, plus a set of
alternative or equivalent representations.
    </p>
]]></text>
               </annotation>
            </documentation>
         </datatype>
      </datatypeEntry>
      <datatypeEntry name="PQ">
         <datatype isAbstract="false" name="PQ" businessName="PhysicalQuantity" visibility="public" superType="QTY" isMerged="false">
            <documentation>
               <businessName>PhysicalQuantity</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
A dimensioned quantity expressing the result of measuring.
    ]]></text>
               </annotation>
            </documentation>
         </datatype>
      </datatypeEntry>
      <datatypeEntry name="CD">
         <datatype isAbstract="false" name="CD" businessName="ConceptDescriptor" visibility="public" superType="ANY" isMerged="false">
            <documentation>
               <businessName>ConceptDescriptor</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
A concept descriptor represents any kind of concept usually by
giving a code defined in a code system.

A concept descriptor can contain the original text or phrase that
served as the basis of the coding and one or more translations into
different coding systems.

A concept descriptor can also contain qualifiers to describe, e.g., the
concept of a "left foot" as a postcoordinated term built from the
primary code "FOOT" and the qualifier "LEFT".

In cases of an exceptional value, the concept descriptor need not contain a code
but only the original text describing that concept.
    ]]></text>
               </annotation>
               <annotation annotationType="DESIGN_COMMENTS">
                  <text><![CDATA[
<p>
The concept descriptor is mostly used in one of its restricted or
&#8220;profiled&#8221; forms, CS, CE, CV.
    </p>
<p>
Use of the full concept descriptor data type is not common. It
requires a conscious decision and documented rationale. In all other
cases, one of the &lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;CD&apos;/&gt;&lt;/object&gt; restrictions shall be
used.&lt;object name=&apos;footnote&apos;&gt;The advantage of the concept descriptor data type is its expressiveness,
however, if all of its features, such as coding exceptions, text, translations 
and qualifiers are used at all times, implementation and use become very 
difficult and unsafe. Therefore, the  type is most often
used in a restricted form with reduced features.&lt;/object&gt;
				              </p>
<p>
All &lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;CD&apos;/&gt;&lt;/object&gt; restrictions constrain certain properties of the
&lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;CD&apos;/&gt;&lt;/object&gt;. Properties may be constrained to the extent that
only one value may be allowed for that property, in which case
mentioning the property becomes redundant. Constraining a property to
one value is referred to as suppressing that property. Although,
conceptually a suppressed property is still semantically applicable,
it is safe for an HL7 interface to assume the implicit default value
without testing.
  </p>
]]></text>
               </annotation>
            </documentation>
         </datatype>
      </datatypeEntry>
      <datatypeEntry name="CR">
         <datatype isAbstract="false" name="CR" businessName="ConceptRole" visibility="protected" superType="ANY" isMerged="false">
            <documentation>
               <businessName>ConceptRole</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
A concept qualifier code with optionally named role.  Both qualifier
role and value codes must be defined by the coding system of the CD containing
the concept qualifier.  For example, if SNOMED RT defines a concept "leg", a
role relation "has-laterality", and another concept "left", the concept role
relation allows to add the qualifier "has-laterality: left" to a
primary code "leg" to construct the meaning "left leg".
    ]]></text>
               </annotation>
               <annotation annotationType="DESIGN_COMMENTS">
                  <text><![CDATA[
<p>
The use of qualifiers is strictly governed by the code system
used. The &lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;CD&apos;/&gt;&lt;/object&gt; data type does not permit using code
qualifiers with code systems that do not provide for qualifiers
(e.g. pre-coordinated systems, such as LOINC, ICD-10 PCS.)
    </p>
]]></text>
               </annotation>
            </documentation>
         </datatype>
      </datatypeEntry>
      <datatypeEntry name="CO">
         <datatype isAbstract="false" name="CO" businessName="CodedOrdinal" visibility="public" superType="CV" isMerged="false">
            <documentation>
               <businessName>CodedOrdinal</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
Coded data, where the domain from which the codeset comes is ordered. The
Coded Ordinal data type adds semantics related to ordering so that models
that make use of such domains may introduce model elements that involve
statements about the order of the terms in a domain.
    ]]></text>
               </annotation>
               <annotation annotationType="DESIGN_COMMENTS">
                  <text><![CDATA[
<p>
The relative order of this type&apos;s values need not be independently
obvious in their literal representation. It is expected that an
application will look up the ordering of these values from some
table.
    </p>
]]></text>
               </annotation>
            </documentation>
         </datatype>
      </datatypeEntry>
      <datatypeEntry name="NPPD">
         <datatype isAbstract="false" name="NPPD" businessName="NonParametricProbabilityDistribution" visibility="public" superType="SET" isMerged="false">
            <documentation>
               <businessName>NonParametricProbabilityDistribution</businessName>
               <annotation annotationType="DEFINITION">
                  <text><![CDATA[
A set of uncertain values with probabilities (also known as
histogram.) All the elements in the set are considered alternatives
and are rated each with its probability expressing the belief (or
frequency) that each given value holds.
    ]]></text>
               </annotation>
               <annotation annotationType="DESIGN_COMMENTS">
                  <text><![CDATA[
<p>
The purpose of the non-parametric probability distribution is chiefly
to support statistical data reporting as it occurs in measurements
taken from many subjects and consolidated in a histogram. This occurs
in epidemiology, veterinary medicine, laboratory medicine, but also in
cost controlling and business process engineering.
    </p>
<p>
Semantically, the information of a stated value exists in contrast to
the complement set of unstated possible values. Thus, semantically, a
non-parametric probability distribution contains &lt;b&gt;all&lt;/b&gt;
possible values and assigns probabilities to each of them.
    </p>
<p>
The easiest way to visualize this is a bar chart as shown in
    </p>
<p></p>
<p>
This example illustrates the probability of selected major league
baseball teams winning the World Series (prior to the season
start). Each team is mutually exclusive, and were we to include all of
the teams, the sum of the probabilities would equal 1 (i.e., it is
certain that one of the teams will win).
    </p>
<p>
Just as with &lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;UVP&apos;/&gt;&lt;/object&gt;, the type T is not formally
constrained, even though there are reasonable and unreasonable
uses. Typically one would use the &lt;object name=&apos;itemName&apos;&gt;&lt;param name=&apos;item&apos; value=&apos;datatype&apos;/&gt;&lt;/object&gt; for unordered types, if
only a &quot;small&quot; set of possible values is assigned explicit
probabilities, or if the probability distribution cannot (or should
not) be approximated with parametric methods. For other cases, one may
prefer &lt;object name=&apos;datatypeRef&apos;&gt;&lt;param name=&apos;datatypeName&apos; value=&apos;PPD&apos;/&gt;&lt;/object&gt;.
    </p>
]]></text>
               </annotation>
            </documentation>
         </datatype>
      </datatypeEntry>
   </parentDatatypeSet>
</datatypeSet>